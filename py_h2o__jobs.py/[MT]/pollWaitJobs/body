def pollWaitJobs(pattern=None, errorIfCancelled=False, timeoutSecs=30, pollTimeoutSecs=30, retryDelaySecs=5, benchmarkLogging=None, stallForNJobs=None):
    wait = True
    waitTime = 0
    ignoredJobs = set()
    while wait:
        a = h2o.nodes[0].jobs_admin(timeoutSecs=pollTimeoutSecs)
        h2o.verboseprint('jobs_admin():', h2o.dump_json(a))
        jobs = a['jobs']
        busy = 0
        for j in jobs:
            if (errorIfCancelled and j['cancelled']):
                h2o.check_sandbox_for_errors()
                print ("ERROR: not stopping, but: pollWaitJobs found a cancelled job when it shouldn't have:\n %s" % h2o.dump_json(j))
                print 'Continuing so maybe a json response will give more info'
            if (j['end_time'] == ''):
                if (not pattern):
                    print 'time:', time.strftime('%I:%M:%S'), 'progress:', j['progress'], j['destination_key']
                    h2o.verboseprint('description:', j['description'], 'end_time:', j['end_time'])
                    busy += 1
                    h2o.verboseprint(('pollWaitJobs: found a busy job, now: %s' % busy))
                elif ((pattern in j['key']) or (pattern in j['destination_key']) or (pattern in j['description'])):
                    busy += 1
                    h2o.verboseprint(('pollWaitJobs: found a pattern-matched busy job, now %s' % busy))
                    print 'time:', time.strftime('%I:%M:%S'), 'progress:', j['progress'], j['destination_key'],
                elif (j['key'] not in ignoredJobs):
                    jobMsg = ('%s %s %s' % (j['key'], j['description'], j['destination_key']))
                    h2o.verboseprint((" %s job in progress but we're ignoring it. Doesn't match pattern." % jobMsg))
                    ignoredJobs.add(j['key'])
        if stallForNJobs:
            waitFor = stallForNJobs
        else:
            waitFor = 0
        print (' %s jobs in progress.' % busy), ('Waiting until %s in progress.' % waitFor)
        wait = (busy > waitFor)
        if (not wait):
            break
        if (wait and (waitTime > timeoutSecs)):
            print h2o.dump_json(jobs)
            raise Exception("Some queued jobs haven't completed after", timeoutSecs, 'seconds')
        sys.stdout.write('.')
        sys.stdout.flush()
        time.sleep(retryDelaySecs)
        waitTime += retryDelaySecs
        if benchmarkLogging:
            h2o.cloudPerfH2O.get_log_save(benchmarkLogging)
        h2o.check_sandbox_for_errors()
    patternKeys = []
    for j in jobs:
        if (pattern and (pattern in j['destination_key'])):
            patternKeys.append(j['destination_key'])
    return patternKeys
