{
  final int nrows=chunks[0]._len;
  double[] nums=MemoryManager.malloc8d(_nums);
  int[] cats=MemoryManager.malloc4(_cats);
  final int step=_complement ? _step : 1;
  final int start=_complement ? _offset : 0;
  OUTER:   for (int r=start; r < nrows; r+=step) {
    if (_step > step && (r % _step) == _offset)     continue;
    for (    Chunk c : chunks)     if (c.isNA0(r))     continue OUTER;
    int i=0, ncats=0;
    for (; i < _cats; ++i) {
      int c=(int)chunks[i].at80(r);
      if (c != 0)       cats[ncats++]=c + _catOffsets[i] - 1;
    }
    for (; i < chunks.length - 1; ++i)     nums[i - _cats]=(chunks[i].at0(r) - _normSub[i - _cats]) * _normMul[i - _cats];
    double y=chunks[chunks.length - 1].at0(r);
    if (_caseMode != CaseMode.none)     y=(_caseMode.isCase(y,_caseVal)) ? 1 : 0;
    processRow(nums,ncats,cats,y);
  }
}
