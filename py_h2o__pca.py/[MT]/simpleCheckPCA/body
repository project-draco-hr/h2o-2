def simpleCheckPCA(self, pca, **kwargs):
    warnings = None
    if ('warnings' in pca):
        warnings = pca['warnings']
        x = re.compile('[Ff]ailed')
        for w in warnings:
            print '\nwarning:', w
            if re.search(x, w):
                raise Exception(w)
    destination_key = pca['destination_key']
    pcaResult = h2o_cmd.runInspect(key=destination_key, view=100)
    h2o.verboseprint('pcaResult Inspect:', h2o.dump_json(pcaResult))
    print 'Checking sdevs...'
    sdevs = pcaResult['PCAModel']['stdDev']
    h2o.verboseprint('pca sdevs:', h2o.dump_json(sdevs))
    for (PC, s) in sdevs.iteritems():
        if math.isnan(s):
            raise Exception(('sdev %s is NaN: %s' % (PC, s)))
    print 'Checking propVars...',
    propVars = pcaResult['PCAModel']['propVar']
    h2o.verboseprint('pca propVars:', h2o.dump_json(propVars))
    for (PC, propvar) in propVars.iteritems():
        if math.isnan(propvar):
            raise Exception('propVar %s is NaN: %s', (PC, propvar))
    print ' Good!'
    print 'Checking eigenvectors...',
    pcs = pcaResult['PCAModel']['eigenvectors']
    h2o.verboseprint('pca eigenvectors:', h2o.dump_json(pcs))
    for (i, s) in enumerate(pcs):
        for (r, e) in s.iteritems():
            if math.isnan(e):
                raise Exception('Component %s has NaN: %s eigenvector %s', (i, e, s))
    print ' Good!'
    print 'How many components did we get? (after enum col dropping): %s', len(pcs)
    import operator
    print 'Just look at the sort for the first row in pca eigenvectors'
    i = 0
    s = pcs[i]
    sorted_s = sorted(s.iteritems(), key=(lambda t: abs(t[1])))
    num = min(10, len(s))
    print ('\n%s First (smallest) %d. sorted_pcs[0:9]: %s\n' % (i, num, sorted_s[0:(num - 1)]))
    print "The first entry from the eigenvector, should have the largest std dev, because it's sorted"
    print "Rule of thumb is we can then look at the sorted values, and guess it's related to column importance"
    print 'The sort should be on the abs(), since the signs can be + or -'
    print ('\n%s Last %d (largest) sorted_s[-10:]: %s\n' % (i, num, sorted_s[(- num):]))
    h2o.check_sandbox_for_errors()
    return warnings
