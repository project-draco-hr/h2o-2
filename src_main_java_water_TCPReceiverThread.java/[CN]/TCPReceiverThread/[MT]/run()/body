{
  Thread.currentThread().setPriority(Thread.MAX_PRIORITY - 1);
  ServerSocketChannel errsock=null;
  boolean saw_error=false;
  while (true) {
    try {
      if (errsock != null) {
        final ServerSocketChannel tmp2=errsock;
        errsock=null;
        tmp2.close();
      }
      if (saw_error)       Thread.sleep(1000);
      saw_error=false;
      if (SOCK == null) {
        SOCK=ServerSocketChannel.open();
        SOCK.socket().bind(H2O.SELF._key);
      }
      AutoBuffer ab=new AutoBuffer(SOCK.accept());
      int ctrl=ab.getCtrl();
      ab._h2o._last_heard_from=System.currentTimeMillis();
switch (UDP.udp.UDPS[ctrl]) {
case exec:
        H2O.submitTsk(new FJPacket(ab));
      break;
case ack:
    RPC.tcp_ack(ab);
  break;
case ackack:
UDP.udp.UDPS[ctrl]._udp.call(ab).close();
break;
case timeline:
TimeLine.tcp_call(ab);
break;
default :
throw new RuntimeException("Unknown Packet Type: " + ab.getCtrl());
}
}
 catch (java.nio.channels.AsynchronousCloseException ex) {
break;
}
catch (Exception e) {
System.err.println("IO error on TCP port " + H2O.UDP_PORT + ": "+ e);
e.printStackTrace();
saw_error=true;
errsock=SOCK;
SOCK=null;
}
}
}
