def test_parse_libsvm(self):
    SYNDATASETS_DIR = h2o.make_syn_dir()
    importFolderPath = 'libsvm'
    csvFilenameList = [('mnist_train.svm', 'cM', 30, 0, 9.0, False, False), ('covtype.binary.svm', 'cC', 30, 1, 2.0, True, True), ('duke.svm', 'cD', 30, (-1.0), 1.0, False, False), ('colon-cancer.svm', 'cA', 30, (-1.0), 1.0, False, False), ('news20.svm', 'cH', 30, 1, 20.0, False, False), ('connect4.svm', 'cB', 30, (-1), 1.0, False, False), ('gisette_scale.svm', 'cF', 30, (-1), 1.0, False, False), ('mushrooms.svm', 'cG', 30, 1, 2.0, False, False)]
    lenNodes = len(h2o.nodes)
    firstDone = False
    for (csvFilename, hex_key, timeoutSecs, expectedCol0Min, expectedCol0Max, enableDownloadReparse, enableSizeChecks) in csvFilenameList:
        csvPathname = ((importFolderPath + '/') + csvFilename)
        parseResult = h2i.import_parse(bucket='home-0xdiag-datasets', path=csvPathname, hex_key=hex_key, timeoutSecs=2000)
        print csvPathname, 'parse time:', parseResult['response']['time']
        print "Parse result['destination_key']:", parseResult['destination_key']
        start = time.time()
        inspectFirst = h2o_cmd.runInspect(None, parseResult['destination_key'], timeoutSecs=360)
        print 'Inspect:', parseResult['destination_key'], 'took', (time.time() - start), 'seconds'
        h2o_cmd.infoFromInspect(inspectFirst, csvFilename)
        imin = float(inspectFirst['cols'][0]['min'])
        imax = float(inspectFirst['cols'][0]['max'])
        if expectedCol0Min:
            self.assertEqual(imin, expectedCol0Min, msg=('col %s min %s is not equal to expected min %s' % (0, imin, expectedCol0Min)))
        if expectedCol0Max:
            h2o_util.assertApproxEqual(imax, expectedCol0Max, tol=1e-08, msg=('col %s max %s is not equal to expected max %s' % (0, imax, expectedCol0Max)))
        print '\nmin/max for col0:', imin, imax
        if DO_SUMMARY:
            goodX = h2o_glm.goodXFromColumnInfo(y=0, key=parseResult['destination_key'], timeoutSecs=300, noPrint=True)
            summaryResult = h2o_cmd.runSummary(key=hex_key, timeoutSecs=360)
            h2o_cmd.infoFromSummary(summaryResult, noPrint=True)
        if (DO_DOWNLOAD_REPARSE and enableDownloadReparse):
            missingValuesListA = h2o_cmd.infoFromInspect(inspectFirst, csvPathname)
            num_colsA = inspectFirst['num_cols']
            num_rowsA = inspectFirst['num_rows']
            row_sizeA = inspectFirst['row_size']
            value_size_bytesA = inspectFirst['value_size_bytes']
            csvDownloadPathname = (((SYNDATASETS_DIR + '/') + csvFilename) + '_csvDownload.csv')
            print 'Trying csvDownload of', csvDownloadPathname
            h2o.nodes[0].csv_download(src_key=hex_key, csvPathname=csvDownloadPathname)
            start = time.time()
            hex_keyB = (hex_key + '_B')
            parseResultB = h2o_cmd.parseResult = h2i.import_parse(path=csvDownloadPathname, schema='put', hex_key=hex_keyB)
            print csvDownloadPathname, 'download/reparse (B) parse end. Original data from', csvFilename, 'took', (time.time() - start), 'seconds'
            inspect = h2o_cmd.runInspect(key=hex_keyB)
            missingValuesListB = h2o_cmd.infoFromInspect(inspect, csvPathname)
            num_colsB = inspect['num_cols']
            num_rowsB = inspect['num_rows']
            row_sizeB = inspect['row_size']
            value_size_bytesB = inspect['value_size_bytes']
            df = h2o_util.JsonDiff(inspectFirst, inspect, with_values=True)
            print 'df.difference:', h2o.dump_json(df.difference)
            for (i, d) in enumerate(df.difference):
                if (('variance' in d) or ('response.time' in d) or ('key' in d) or ('value_size_bytes' in d) or ('row_size' in d)):
                    pass
                else:
                    raise Exception(('testing %s, found unexpected mismatch in df.difference[%d]: %s' % (csvPathname, i, d)))
            if (DO_SIZE_CHECKS and enableSizeChecks):
                print 'Comparing original inspect to the inspect after parsing the downloaded csv'
                filtered = [v for v in df.difference if (not ('variance' in v))]
                self.assertLess(len(filtered), 3, msg=('Want < 3, not %d differences between the two rfView json responses. %s' % (len(filtered), h2o.dump_json(filtered))))
                self.assertEqual(row_sizeA, row_sizeB, ('row_size mismatches after re-parse of downloadCsv result %d %d' % (row_sizeA, row_sizeB)))
                h2o_util.assertApproxEqual(value_size_bytesA, value_size_bytesB, tol=1e-08, msg=('value_size_bytes mismatches after re-parse of downloadCsv result %d %d' % (value_size_bytesA, value_size_bytesB)))
            print 'missingValuesListA:', missingValuesListA
            print 'missingValuesListB:', missingValuesListB
            self.assertEqual(missingValuesListA, missingValuesListB, 'missingValuesList mismatches after re-parse of downloadCsv result')
            self.assertEqual(num_colsA, num_colsB, ('num_cols mismatches after re-parse of downloadCsv result %d %d' % (num_colsA, num_colsB)))
            self.assertEqual(num_rowsA, num_rowsB, ('num_rows mismatches after re-parse of downloadCsv result %d %d' % (num_rowsA, num_rowsB)))
        h2o.check_sandbox_for_errors()
