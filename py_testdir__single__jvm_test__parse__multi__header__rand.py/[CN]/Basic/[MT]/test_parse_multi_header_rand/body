def test_parse_multi_header_rand(self):
    h2b.browseTheCloud()
    SYNDATASETS_DIR = h2o.make_syn_dir()
    csvFilename = 'syn_ints.csv'
    csvPathname = ((SYNDATASETS_DIR + '/') + csvFilename)
    headerList = [['aA', 'aB', 'aC', 'aD', 'aE', 'aF', 'aG', 'aH', 'aI', 'output']]
    tryList = [(1, 5, 9, 'cA', 60, 0), (7, 300, 10, 'cA', 60, 0)]
    for trial in range(20):
        (fileNum, rowCount, colCount, key2, timeoutSecs, dataRowsWithHeader) = random.choice(tryList)
        print fileNum, rowCount, colCount, key2, timeoutSecs, dataRowsWithHeader
        print 'Wait while', fileNum, 'synthetic files are created in', SYNDATASETS_DIR
        rowxcol = ((str(rowCount) + 'x') + str(colCount))
        totalCols = (colCount + 1)
        totalDataRows = 0
        totalHeaderRows = 0
        HEADER_HAS_HDR_ROW = random.randint(0, 1)
        DATA_HAS_HDR_ROW = random.randint(0, 1)
        PARSE_PATTERN_INCLUDES_HEADER = random.randint(0, 1)
        print "TEMPORARY: don't put any comments in"
        DATA_FIRST_IS_COMMENT = 0
        HEADER_FIRST_IS_COMMENT = 0
        SEP_CHAR_GEN = random.choice(paramsDict['separator'])
        print '\nHEADER_HAS_HDR_ROW:', HEADER_HAS_HDR_ROW
        print 'DATA_HAS_HDR_ROW:', DATA_HAS_HDR_ROW
        print 'PARSE_PATTERN_INCLUDES_HEADER', PARSE_PATTERN_INCLUDES_HEADER
        print 'DATA_FIRST_IS_COMMENT:', DATA_FIRST_IS_COMMENT
        print 'HEADER_FIRST_IS_COMMENT:', HEADER_FIRST_IS_COMMENT
        print 'SEP_CHAR_GEN:', SEP_CHAR_GEN
        headerForHeader = SEP_CHAR_GEN.join(random.choice(headerList))
        headerForData = SEP_CHAR_GEN.join(random.choice(headerList))
        kwargs = {}
        for (k, v) in paramsDict.items():
            aChoice = random.choice(v)
            if (k == 'separator'):
                if aChoice:
                    sepChar = aChoice
                    sepCharInt = ord(aChoice)
                else:
                    sepChar = ','
                    sepCharInt = None
                aChoice = sepCharInt
            kwargs[k] = aChoice
        if kwargs['separator']:
            if ((SEP_CHAR_GEN == ' ') or (SEP_CHAR_GEN == ',')):
                del kwargs['separator']
            else:
                kwargs['separator'] = ord(SEP_CHAR_GEN)
        for fileN in range(fileNum):
            csvFilename = (((((((('syn_data_' + str(fileN)) + '_') + str(SEED)) + '_') + str(trial)) + '_') + rowxcol) + '.csv')
            csvPathname = ((SYNDATASETS_DIR + '/') + csvFilename)
            rList = rand_rowData(colCount, sepChar=SEP_CHAR_GEN)
            (headerRowsDone, dataRowsDone) = write_syn_dataset(csvPathname, rowCount, headerString=(headerForData if DATA_HAS_HDR_ROW else None), rList=rList, commentFirst=DATA_FIRST_IS_COMMENT, sepChar=SEP_CHAR_GEN)
            totalDataRows += dataRowsDone
            totalHeaderRows += headerRowsDone
        hdrFilename = (((((('syn_header_' + str(SEED)) + '_') + str(trial)) + '_') + rowxcol) + '.csv')
        hdrPathname = ((SYNDATASETS_DIR + '/') + hdrFilename)
        (headerRowsDone, dataRowsDone) = write_syn_dataset(hdrPathname, dataRowsWithHeader, headerString=(headerForHeader if HEADER_HAS_HDR_ROW else None), rList=rList, commentFirst=HEADER_FIRST_IS_COMMENT, sepChar=SEP_CHAR_GEN)
        if PARSE_PATTERN_INCLUDES_HEADER:
            totalDataRows += dataRowsDone
        totalHeaderRows += headerRowsDone
        key = ('syn_' + str(trial))
        key2 = (('syn_' + str(trial)) + '.hex')
        xs = h2o.nodes[0].import_files(SYNDATASETS_DIR)['keys']
        headerKey = [x for x in xs if (hdrFilename in x)][0]
        dataKey = [x for x in xs if (csvFilename not in x)][0]
        print 'Header Key =', headerKey
        if (kwargs['header_from_file'] == 'syn_header'):
            kwargs['header_from_file'] = headerKey
        elif (kwargs['header_from_file'] == 'syn_data'):
            kwargs['header_from_file'] = dataKey
        print 'If header_from_file= is used, we are currently required to force header=1 for h2o'
        if kwargs['header_from_file']:
            kwargs['header'] = 1
        elif DATA_HAS_HDR_ROW:
            kwargs['header'] = 1
        else:
            kwargs['header'] = 0
        start = time.time()
        if PARSE_PATTERN_INCLUDES_HEADER:
            pattern = (((('*syn_*' + str(trial)) + '_') + rowxcol) + '*')
        else:
            pattern = (((('*syn_data_*' + str(trial)) + '_') + rowxcol) + '*')
        parseKey = h2o.nodes[0].parse(pattern, key2=key2, timeoutSecs=timeoutSecs, **kwargs)
        print ("parseKey['destination_key']: " + parseKey['destination_key'])
        print 'parse time:', parseKey['response']['time']
        inspect = h2o_cmd.runInspect(None, parseKey['destination_key'])
        h2o_cmd.infoFromInspect(inspect, csvPathname)
        print ('\n' + csvPathname), '    num_rows:', '{:,}'.format(inspect['num_rows']), '    num_cols:', '{:,}'.format(inspect['num_cols'])
        h2o_cmd.columnInfoFromInspect(parseKey['destination_key'], exceptionOnMissingValues=False)
        self.assertEqual(inspect['num_cols'], totalCols, ('parse created result with the wrong number of cols %s %s' % (inspect['num_cols'], totalCols)))
        h2oLosesOneData = ((headerRowsDone == 0) and (kwargs['header'] == 1) and (not DATA_HAS_HDR_ROW))
        print 'h2oLosesOneData:', h2oLosesOneData
        if h2oLosesOneData:
            totalDataRows -= 1
        self.assertEqual(inspect['num_rows'], totalDataRows, ("parse created result with the wrong number of rows (header rows don't count) h2o: %s gen'ed: %s" % (inspect['num_rows'], totalDataRows)))
        h2oShouldSeeHeader = ((HEADER_HAS_HDR_ROW and (kwargs['header_from_file'] == 1)) or DATA_HAS_HDR_ROW)
        if h2oShouldSeeHeader:
            kwargs = {'sample': 75, 'depth': 25, 'ntree': 1, 'ignore': 'A', }
        else:
            kwargs = {'sample': 75, 'depth': 25, 'ntree': 1, }
        start = time.time()
        elapsed = (time.time() - start)
        print ('%d pct. of timeout' % ((elapsed / timeoutSecs) * 100))
        print 'trial #', trial, 'totalDataRows:', totalDataRows, 'parse end on ', csvFilename, 'took', (time.time() - start), 'seconds'
        h2o.check_sandbox_for_errors()
