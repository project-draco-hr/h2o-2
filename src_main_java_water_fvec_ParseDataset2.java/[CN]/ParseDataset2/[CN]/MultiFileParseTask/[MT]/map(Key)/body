{
  ByteVec vec=(ByteVec)getVec(key);
  Compression cpr=guessCompressionMethod(vec);
  CustomParser.ParserSetup localSetup;
  byte[] bits=Inspect.getFirstBytes(DKV.get(key));
switch (_setup._pType) {
case SVMLight:
    localSetup=CustomParser.ParserSetup.makeSVMLightSetup(0,null);
  break;
case CSV:
localSetup=CsvParser.guessSetup(bits,_setup._separator);
break;
default :
throw H2O.unimpl();
}
if (!_setup.isCompatible(localSetup)) {
_parserr="Conflicting file layouts, expecting: " + _setup + " but found "+ localSetup;
return;
}
boolean has_hdr=_setup._header && localSetup._header;
if (has_hdr) {
for (int i=0; i < localSetup._columnNames.length; ++i) has_hdr=localSetup._columnNames[i].equalsIgnoreCase(_setup._columnNames[i]);
if (!has_hdr) localSetup=CustomParser.ParserSetup.makeCSVSetup(localSetup._separator,false,localSetup._data,localSetup._ncols);
}
final int ncols=_setup._ncols;
_vecs=new Vec[ncols];
Key[] keys=vec.group().addVecs(ncols);
for (int i=0; i < ncols; i++) _vecs[i]=new AppendableVec(keys[i]);
try {
switch (cpr) {
case NONE:
distroParse(vec,localSetup);
break;
case ZIP:
{
ZipInputStream zis=new ZipInputStream(vec.openStream(_progress));
ZipEntry ze=zis.getNextEntry();
if (ze != null && !ze.isDirectory()) streamParse(zis,localSetup);
 else zis.close();
break;
}
case GZIP:
streamParse(new GZIPInputStream(vec.openStream(_progress)),localSetup);
break;
}
}
 catch (IOException ioe) {
_parserr=ioe.toString();
return;
}
}
