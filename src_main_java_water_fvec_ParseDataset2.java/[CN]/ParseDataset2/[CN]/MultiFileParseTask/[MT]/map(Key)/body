{
  ByteVec vec=(ByteVec)getVec(key);
  byte[] bits=vec.elem2BV(0)._mem;
  Compression cpr=guessCompressionMethod(vec);
  CustomParser.ParserSetup localSetup=ParseDataset.guessSetup(Utils.unzipBytes(bits,cpr),_setup._pType,_setup._separator);
  if (!_setup.isCompatible(localSetup)) {
    _parserr="Conflicting file layouts, expecting: " + _setup + " but found "+ localSetup;
    return;
  }
  boolean has_hdr=_setup._header && localSetup._header;
  if (has_hdr) {
    for (int i=0; i < localSetup._columnNames.length; ++i)     has_hdr=localSetup._columnNames[i].equalsIgnoreCase(_setup._columnNames[i]);
    if (!has_hdr)     localSetup=CustomParser.ParserSetup.makeCSVSetup(localSetup._separator,false,localSetup._data,localSetup._ncols);
  }
  final int ncols=_setup._ncols;
  _vecs=new Vec[ncols];
  Key[] keys=vec.group().addVecs(ncols);
  for (int i=0; i < ncols; i++)   _vecs[i]=new AppendableVec(keys[i]);
  try {
switch (cpr) {
case NONE:
      if (localSetup._pType.parallelParseSupported)       distroParse(vec,localSetup);
 else       streamParse(vec.openStream(_progress),localSetup);
    break;
case ZIP:
{
    ZipInputStream zis=new ZipInputStream(vec.openStream(_progress));
    ZipEntry ze=zis.getNextEntry();
    if (ze != null && !ze.isDirectory())     streamParse(zis,localSetup);
 else     zis.close();
    break;
  }
case GZIP:
streamParse(new GZIPInputStream(vec.openStream(_progress)),localSetup);
break;
}
}
 catch (IOException ioe) {
_parserr=ioe.toString();
return;
}
}
