{
  Timer t_inhale=new Timer();
  RFModel rfmodel=_drf._rfmodel;
  final ValueArray ary=DKV.get(rfmodel._dataKey).get();
  final int[] modelDataMap=rfmodel.columnMapping(ary.colNames());
  final DataAdapter dapt=new DataAdapter(ary,rfmodel,modelDataMap,getRowCount(keys),getChunkId(keys),_drf._params._seed,_drf._params._binLimit,_drf._params._classWt);
  checkAndLimitFeatureUsedPerSplit(dapt);
  final int ncolumns=rfmodel._va._cols.length;
  ArrayList<RecursiveAction> dataInhaleJobs=new ArrayList<RecursiveAction>();
  int start_row=0;
  for (  final Key k : keys) {
    final int S=start_row;
    if (!k.home())     continue;
    final int rows=ary.rpc(ValueArray.getChunkIndex(k));
    dataInhaleJobs.add(new RecursiveAction(){
      @Override protected void compute(){
        AutoBuffer bits=ary.getChunk(k);
        for (int j=0; j < rows; ++j) {
          int rowNum=S + j;
          boolean rowIsValid=false;
          for (int c=0; c < ncolumns; ++c) {
            final int col=modelDataMap[c];
            if (ary.isNA(bits,j,col)) {
              dapt.addBad(rowNum,c);
              continue;
            }
            float f=(float)ary.datad(bits,j,col);
            if (!dapt.isValid(c,f)) {
              dapt.addBad(rowNum,c);
              continue;
            }
            dapt.add(f,rowNum,c);
            if (c != ncolumns - 1)             rowIsValid|=true;
          }
          if (!rowIsValid)           dapt.markIgnoredRow(j);
        }
      }
    }
);
    start_row+=rows;
  }
  ForkJoinTask.invokeAll(dataInhaleJobs);
  dapt.shrink();
  Log.debug2(Sys.RANDF,"Inhale done in " + t_inhale);
  return dapt;
}
