{
  double[] fullBeta=(_activeCols == null || newBeta == null) ? newBeta : expandVec(newBeta,_activeCols);
  if (fullBeta == null) {
    fullBeta=MemoryManager.malloc8d(_dinfo.fullN() + 1);
    fullBeta[fullBeta.length - 1]=_glm.linkInv(_ymu);
  }
 else   if (_noffsets > 0) {
    fullBeta=Arrays.copyOf(fullBeta,fullBeta.length + _noffsets);
    fullBeta[fullBeta.length - 1]=fullBeta[fullBeta.length - 1 - _noffsets];
  }
  if (_noffsets > 0) {
    for (int i=fullBeta.length - 1 - _noffsets; i < fullBeta.length - 1; ++i)     fullBeta[i]=1;
  }
  final double[] newBetaDeNorm;
  if (_dinfo._predictor_transform == DataInfo.TransformType.STANDARDIZE) {
    newBetaDeNorm=fullBeta.clone();
    double norm=0.0;
    final int numoff=_dinfo.numStart();
    for (int i=numoff; i < fullBeta.length - 1; i++) {
      double b=newBetaDeNorm[i] * _dinfo._normMul[i - numoff];
      norm+=b * _dinfo._normSub[i - numoff];
      newBetaDeNorm[i]=b;
    }
    newBetaDeNorm[newBetaDeNorm.length - 1]-=norm;
  }
 else   newBetaDeNorm=null;
  GLMModel.setSubmodel(cmp,dest(),_currentLambda,newBetaDeNorm == null ? fullBeta : newBetaDeNorm,newBetaDeNorm == null ? null : fullBeta,(_iter + 1),System.currentTimeMillis() - start_time,_dinfo.fullN() >= sparseCoefThreshold,val);
  return fullBeta;
}
