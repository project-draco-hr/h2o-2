{
  final ASTOp op=env.fcn(-1);
  Frame fr=env.ary(-3);
  final int ncols=fr.numCols();
  int cols[];
  if (!env.isAry(-2)) {
    if (Double.isNaN(env.dbl(-2)))     throw new IllegalArgumentException("NA not a valid column");
    cols=new int[]{(int)env.dbl(-2) - 1};
  }
 else {
    Frame cs=env.ary(-2);
    if (cs.numCols() != 1)     throw new IllegalArgumentException("Only one column-of-columns for column selection");
    if (cs.numRows() > 1000)     throw new IllegalArgumentException("Too many columns selected");
    cols=new int[(int)cs.numRows()];
    Vec vec=cs.vecs()[0];
    for (int i=0; i < cols.length; i++)     if (vec.isNA(i))     throw new IllegalArgumentException("NA not a valid column");
 else     cols[i]=(int)vec.at8(i) - 1;
  }
  for (  int c : cols)   if (c < 0 || c >= fr.numCols())   throw new IllegalArgumentException("Column " + (c + 1) + " out of range for frame columns "+ fr.numCols());
  ddplyPass1 p1=new ddplyPass1(cols).doAll(fr);
  ddplyPass2 p2=new ddplyPass2(p1).invokeOnAllNodes();
  Vec vecs[]=p2.close();
  int csz=H2O.CLOUD.size();
  Futures fs=new Futures();
  Frame frs[]=new Frame[p1._groups.size()];
  int grpnum=0;
  for (  Group g : p1._groups.keySet()) {
    Vec rows=vecs[grpnum];
    Vec[] data=fr.vecs();
    Vec[] gvecs=new Vec[data.length];
    Key[] keys=rows.group().addVecs(data.length);
    for (int c=0; c < data.length; c++)     gvecs[c]=new SubsetVec(rows._key,data[c]._key,keys[c],rows._espc);
    Frame fg=frs[grpnum++]=new Frame(fr._names,gvecs);
    fs.add(RPC.call(H2O.CLOUD._memary[g.hashCode() % csz],new RemoteExec(g._ds,fg)));
  }
  fs.blockForPending();
  for (  Frame fr2 : frs)   fr2.delete();
  for (  Vec v : vecs)   UKV.remove(v._key);
  env.pop(4);
  env.push(new Frame(new String[0],new Vec[0]));
}
