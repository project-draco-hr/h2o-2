{
  Frame fr=env.ary(-3);
  int cols[];
  if (!env.isAry(-2)) {
    if (Double.isNaN(env.dbl(-2)))     throw new IllegalArgumentException("NA not a valid column");
    cols=new int[]{(int)env.dbl(-2) - 1};
  }
 else {
    Frame cs=env.ary(-2);
    if (cs.numCols() != 1)     throw new IllegalArgumentException("Only one column-of-columns for column selection");
    if (cs.numRows() > 1000)     throw new IllegalArgumentException("Too many columns selected");
    cols=new int[(int)cs.numRows()];
    Vec vec=cs.vecs()[0];
    for (int i=0; i < cols.length; i++)     if (vec.isNA(i))     throw new IllegalArgumentException("NA not a valid column");
 else     cols[i]=(int)vec.at8(i) - 1;
  }
  for (  int c : cols)   if (c < 0 || c >= fr.numCols())   throw new IllegalArgumentException("Column " + (c + 1) + " out of range for frame columns "+ fr.numCols());
  ddplyPass1 p1=new ddplyPass1(cols).doAll(fr);
  int numgrps=p1._groups.size();
  int csz=H2O.CLOUD.size();
  ddplyPass2 p2=new ddplyPass2(p1,numgrps,csz).invokeOnAllNodes();
  Vec vecs[]=p2.close();
  Key envkey=Key.make();
  UKV.put(envkey,env);
  Futures fs=new Futures();
  int grpnum=0;
  int nlocals[]=new int[csz];
  RemoteExec re=null;
  for (  Group g : p1._groups.keySet()) {
    Vec rows=vecs[grpnum++];
    Vec[] data=fr.vecs();
    Vec[] gvecs=new Vec[data.length];
    Key[] keys=rows.group().addVecs(data.length);
    for (int c=0; c < data.length; c++)     gvecs[c]=new SubsetVec(rows._key,data[c]._key,keys[c],rows._espc);
    Frame fg=new Frame(fr._names,gvecs);
    final int nidx=g.hashCode() % csz;
    fs.add(RPC.call(H2O.CLOUD._memary[nidx],(re=new RemoteExec(nlocals[nidx]++,p2._nlocals[nidx],g._ds,fg,envkey))));
  }
  fs.blockForPending();
  Vec vres[]=new ddplyPass4(envkey,cols.length,re._ncols).invokeOnAllNodes().close();
  String[] names=new String[cols.length + re._ncols];
  for (int i=0; i < cols.length; i++)   names[i]=fr._names[cols[i]];
  for (int i=cols.length; i < names.length; i++)   names[i]="C" + (i - cols.length + 1);
  Frame res=new Frame(names,vres);
  for (  Vec v : vecs)   UKV.remove(v._key);
  UKV.remove(envkey);
  env.pop(4);
  env.push(res);
}
