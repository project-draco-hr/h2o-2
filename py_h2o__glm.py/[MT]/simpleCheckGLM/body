def simpleCheckGLM(self, glm, colX, allowFailWarning=False, allowZeroCoeff=False, prettyPrint=False, noPrint=False, maxExpectedIterations=None, doNormalized=False, **kwargs):
    if h2o.beta_features:
        GLMModel = glm['glm_model']
    else:
        GLMModel = glm['GLMModel']
    if (not GLMModel):
        raise Exception(("GLMModel didn't exist in the glm response? %s" % h2o.dump_json(glm)))
    warnings = None
    if (('warnings' in GLMModel) and GLMModel['warnings']):
        warnings = GLMModel['warnings']
        x = re.compile('failed', re.IGNORECASE)
        c = re.compile('converge', re.IGNORECASE)
        for w in warnings:
            print '\nwarning:', w
            if (re.search(x, w) and (not allowFailWarning)):
                if re.search(c, w):
                    pass
                else:
                    raise Exception(w)
    if h2o.beta_features:
        GLMParams = GLMModel['glm']
    else:
        GLMParams = GLMModel['GLMParams']
    family = GLMParams['family']
    if h2o.beta_features:
        if (len(GLMModel['submodels']) < 2):
            raise Exception('Always should have a minimum of 2 submodels in GLM2 response', len(submodels))
        lambdas = GLMModel['lambdas']
        if (len(lambdas) < 2):
            raise Exception('Always should have a minimum of 2 lambdas in GLM2 response', len(submodels))
        submodels0 = GLMModel['submodels'][0]
        submodels1 = GLMModel['submodels'][1]
        lambdaMax = lambdas[0]
        if (lambdaMax <= lambdas[1]):
            raise Exception(("lambdaMax %s should always be < the lambda result %s we're checking" % (lambdaMax, lambdas[1])))
        best_lambda_idx = GLMModel['best_lambda_idx']
        if (best_lambda_idx != 1):
            raise Exception(('best_lamda_idx %s should point to the one lamda we specified? %s' % (best_lamda_idx, lamdas[1])))
        print 'lambdaMax:', lambdaMax
        iterations = submodels1['iteration']
    else:
        iterations = GLMModel['iterations']
    print 'GLMModel/iterations:', iterations
    if ((maxExpectedIterations is not None) and (iterations > maxExpectedIterations)):
        raise Exception(('Convergence issue? GLM did iterations: %d which is greater than expected: %d' % (iterations, maxExpectedIterations)))
    if h2o.beta_features:
        if ('validation' not in submodels1):
            raise Exception(("Should be a 'validation' key in submodels1: %s" % h2o.dump_json(submodels1)))
        validationsList = submodels1['validation']
        validations = validationsList
    else:
        if ('validations' not in GLMModel):
            raise Exception(("Should be a 'validations' key in GLMModel: %s" % h2o.dump_json(GLMModel)))
        validationsList = GLMModel['validations']
        validations = validationsList[0]
    n_folds = kwargs.setdefault('n_folds', None)
    if (not h2o.beta_features):
        if (not ('xval_models' in validations)):
            if (n_folds > 1):
                raise Exception(('No cross validation models returned. Asked for ' + n_folds))
        else:
            xval_models = validations['xval_models']
            if (n_folds and (n_folds > 1)):
                if (len(xval_models) != n_folds):
                    raise Exception(((len(xval_models) + ' cross validation models returned. Asked for ') + n_folds))
            elif (len(xval_models) != 10):
                raise Exception((str(len(xval_models)) + ' cross validation models returned. Default should be 10'))
    if h2o.beta_features:
        print 'GLMModel/validations'
        validations['avg_err'] = h2o_util.cleanseInfNan(validations['avg_err'])
        validations['null_deviance'] = h2o_util.cleanseInfNan(validations['null_deviance'])
        validations['residual_deviance'] = h2o_util.cleanseInfNan(validations['residual_deviance'])
        print ('%15s %s' % ('avg_err:\t', validations['avg_err']))
        print ('%15s %s' % ('null_deviance:\t', validations['null_deviance']))
        print ('%15s %s' % ('residual_deviance:\t', validations['residual_deviance']))
    else:
        print 'GLMModel/validations'
        validations['err'] = h2o_util.cleanseInfNan(validations['err'])
        validations['nullDev'] = h2o_util.cleanseInfNan(validations['nullDev'])
        validations['resDev'] = h2o_util.cleanseInfNan(validations['resDev'])
        print ('%15s %s' % ('err:\t', validations['err']))
        print ('%15s %s' % ('nullDev:\t', validations['nullDev']))
        print ('%15s %s' % ('resDev:\t', validations['resDev']))
    if (family == 'binomial'):
        print ('%15s %s' % ('auc:\t', validations['auc']))
        if h2o.beta_features:
            print ('%15s %s' % ('best_threshold:\t', validations['best_threshold']))
            print "We're just going to print the middle '_cms' ..that must be threshold 0.5?. this isn't above best_threshold"
            cms = glm['glm_model']['submodels'][0]['validation']['_cms']
            mid = (len(cms) / 2)
            cm = cms[mid]
            print 'cm:', h2o.dump_json(cm['_arr'])
            predErr = cm['_predErr']
            classErr = cm['_classErr']
            pctWrong = h2o_gbm.pp_cm_summary(cm['_arr'])
            print 'predErr:', predErr
            print 'calculated pctWrong from cm:', pctWrong
            print 'classErr:', classErr
            print '\nTrain\n==========\n'
            print h2o_gbm.pp_cm(cm['_arr'])
        else:
            print ('%15s %s' % ('threshold:\t', validations['threshold']))
    if ((family == 'poisson') or (family == 'gaussian')):
        print ('%15s %s' % ('aic:\t', validations['aic']))
    if (not h2o.beta_features):
        if math.isnan(validations['err']):
            emsg = ("Why is this err = 'nan'?? %6s %s" % ('err:\t', validations['err']))
            raise Exception(emsg)
        if math.isnan(validations['resDev']):
            emsg = ("Why is this resDev = 'nan'?? %6s %s" % ('resDev:\t', validations['resDev']))
            raise Exception(emsg)
        if math.isnan(validations['nullDev']):
            pass
    if h2o.beta_features:
        coefficients_names = GLMModel['coefficients_names']
        idxs = submodels1['idxs']
        column_names = coefficients_names
        norm_beta = submodels1['norm_beta']
        if (norm_beta and (len(column_names) != len(norm_beta))):
            print len(column_names), len(norm_beta)
            raise Exception(('column_names and normalized_norm_beta from h2o json not same length. column_names: %s normalized_norm_beta: %s' % (column_names, norm_beta)))
        beta = submodels1['beta']
        if (len(column_names) != len(beta)):
            print len(column_names), len(beta)
            raise Exception(('column_names and beta from h2o json not same length. column_names: %s beta: %s' % (column_names, beta)))
        if doNormalized:
            beta_used = norm_beta
        else:
            beta_used = beta
        coefficients = {}
        for (n, b) in zip(column_names, beta_used):
            coefficients[n] = b
        print 'coefficients:', coefficients
        print 'beta:', beta
        print 'norm_beta:', norm_beta
        print 'intercept demapping info:', 'column_names[-i]:', column_names[(-1)], 'idxs[-1]:', idxs[(-1)], 'coefficients_names[[idxs[-1]]:', coefficients_names[idxs[(-1)]], 'beta_used[-1]:', beta_used[(-1)], "coefficients['Intercept']", coefficients['Intercept']
        for i in idxs:
            if (beta_used[i] == 0.0):
                raise Exception("idxs shouldn't point to any 0 coefficients i: %s beta_used[i]:"(i, beta_used[i]))
        intercept = coefficients.pop('Intercept', None)
        column_names.pop()
    else:
        if doNormalized:
            coefficients = GLMModel['normalized_coefficients'].copy()
        else:
            coefficients = GLMModel['coefficients'].copy()
        column_names = GLMModel['column_names']
        intercept = coefficients.pop('Intercept', None)
        print 'First intercept:', intercept
    if h2o.beta_features:
        y = kwargs['response']
    else:
        y = kwargs['y']

    def add_to_coefficient_list_and_string(c, cList, cString):
        if (c in coefficients):
            cValue = coefficients[c]
            cValueString = ('%s: %.5e   ' % (c, cValue))
        else:
            print (("Warning: didn't see '" + c) + "' in json coefficient response."), "Inserting 'None' with assumption it was dropped due to constant column)"
            cValue = None
            cValueString = ('%s: %s   ' % (c, cValue))
        cList.append(cValue)
        if prettyPrint:
            cValueString = (('H2O coefficient ' + cValueString) + '\n')
        return (cString + cValueString)
    cString = ''
    cList = []
    for c in column_names:
        cString = add_to_coefficient_list_and_string(c, cList, cString)
    if prettyPrint:
        print ('\nH2O intercept:\t\t%.5e' % intercept)
        print cString
    elif (not noPrint):
        print '\nintercept:', intercept, cString
    print '\nTotal # of coefficients:', len(column_names)
    if ((not allowZeroCoeff) and (colX is not None)):
        absXCoeff = abs(float(coefficients[str(colX)]))
        self.assertGreater(absXCoeff, 1e-26, ((((("abs. value of GLM coefficients['" + str(colX)) + "'] is ") + str(absXCoeff)) + ', not >= 1e-26 for X=') + str(colX)))
    absIntercept = abs(float(intercept))
    self.assertGreater(absIntercept, 1e-26, (("abs. value of GLM coefficients['Intercept'] is " + str(absIntercept)) + ', not >= 1e-26 for Intercept'))
    if (len(coefficients) > 0):
        maxKey = max([(abs(coefficients[x]), x) for x in coefficients])[1]
        print 'H2O Largest abs. coefficient value:', maxKey, coefficients[maxKey]
        minKey = min([(abs(coefficients[x]), x) for x in coefficients])[1]
        print 'H2O Smallest abs. coefficient value:', minKey, coefficients[minKey]
    else:
        print 'Warning, no coefficients returned. Must be intercept only?'
    if ((not allowZeroCoeff) and (len(coefficients) > 1)):
        s = 0.0
        for c in coefficients:
            v = coefficients[c]
            s += abs(float(v))
        self.assertGreater(s, 1e-26, (('sum of abs. value of GLM coefficients/intercept is ' + str(s)) + ', not >= 1e-26'))
    if h2o.beta_features:
        print 'submodels1, run_time (milliseconds):', submodels1['run_time']
    else:
        print 'GLMModel model time (milliseconds):', GLMModel['model_time']
        print 'GLMModel validation time (milliseconds):', validations['val_time']
        print 'GLMModel lsm time (milliseconds):', GLMModel['lsm_time']
    h2o.check_sandbox_for_errors()
    return (warnings, cList, intercept)
