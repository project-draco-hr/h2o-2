{
  Frame x=env.ary(-2);
  Vec xv=x.theVec("Argument #1 in Quantile contains more than 1 column.");
  Vec pv=env.ary(-1).theVec("Argument #2 in Quantile contains more than 1 column.");
  double p[]=new double[(int)pv.length()];
  for (int i=0; i < pv.length(); i++) {
    if ((p[i]=pv.at((long)i)) < 0 || p[i] > 1)     throw new IllegalArgumentException("Quantile: probs must be in the range of [0, 1].");
  }
  if (xv.isEnum()) {
    throw new IllegalArgumentException("Quantile: column type cannot be Enum.");
  }
  Futures fs=new Futures();
  xv.rollupStats(fs);
  fs.blockForPending();
  Key key=Vec.VectorGroup.VG_LEN1.addVecs(1)[0];
  AppendableVec av=new AppendableVec(key);
  NewChunk nc=new NewChunk(av,0);
  Quantiles[] qbins1=null;
  Quantiles[] qbinsM=null;
  final int MAX_ITERATIONS=16;
  final int MAX_QBINS=1000;
  final boolean MULTIPASS=true;
  final int INTERPOLATION=7;
  double result;
  double valStart=xv.min();
  double valEnd=xv.max();
  double[] quantiles_to_do=new double[1];
  qbins1=new Quantiles.BinTask2(MAX_QBINS,valStart,valEnd,MULTIPASS).doAll(xv)._qbins;
  for (  double quantile : p) {
    result=Double.NaN;
    for (int iteration=1; iteration <= MAX_ITERATIONS; iteration++) {
      if (iteration == 1) {
        if (qbins1 == null)         break;
        quantiles_to_do[0]=quantile;
        qbins1[0].finishUp(xv,quantiles_to_do,INTERPOLATION);
        Log.debug("\nQ_ 1st multipass iteration: " + iteration + " valStart: "+ valStart+ " valEnd: "+ valEnd+ " valBinSize: "+ qbins1[0]._valBinSize);
        if (qbins1[0]._done) {
          result=qbins1[0]._pctile[0];
          break;
        }
        valStart=qbins1[0]._newValStart;
        valEnd=qbins1[0]._newValEnd;
      }
      if (iteration > 1) {
        if (qbinsM == null)         break;
        quantiles_to_do[0]=quantile;
        qbinsM[0].finishUp(xv,quantiles_to_do,INTERPOLATION);
        Log.debug("\nQ_ multipass iteration: " + iteration + " valStart: "+ valStart+ " valEnd: "+ valEnd+ " valBinSize: "+ qbinsM[0]._valBinSize);
        if (qbinsM[0]._done) {
          result=qbinsM[0]._pctile[0];
          break;
        }
        valStart=qbinsM[0]._newValStart;
        valEnd=qbinsM[0]._newValEnd;
      }
      qbinsM=new Quantiles.BinTask2(MAX_QBINS,valStart,valEnd,MULTIPASS).doAll(xv)._qbins;
    }
    qbinsM=null;
    nc.addNum(result);
  }
  qbins1=null;
  nc.close(0,null);
  Vec v=av.close(null);
  env.poppush(argcnt,new Frame(new String[]{"Quantile"},new Vec[]{v}),null);
}
