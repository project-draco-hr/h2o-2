{
  Frame fr0=null, fr1=null;
  double d0=0, d1=0;
  if (env.isAry())   fr1=env.popAry();
 else   d1=env.popDbl();
  String k0=env.key();
  if (env.isAry())   fr0=env.popAry();
 else   d0=env.popDbl();
  String k1=env.key();
  if (fr0 == null && fr1 == null) {
    env.poppush(op(d0,d1));
    return;
  }
  final boolean lf=fr0 != null;
  final boolean rf=fr1 != null;
  final double fd0=d0;
  final double fd1=d1;
  Frame fr=null;
  int ncols=0;
  if (fr0 != null) {
    ncols=fr0.numCols();
    if (fr1 != null) {
      if (fr0.numCols() != fr1.numCols() || fr0.numRows() != fr1.numRows())       throw new IllegalArgumentException("Arrays must be same size: " + fr0 + " vs "+ fr1);
      fr=new Frame(fr0).add(fr1,true);
    }
 else {
      fr=fr0;
    }
  }
 else {
    ncols=fr1.numCols();
    fr=fr1;
  }
  final ASTBinOp bin=this;
  Frame fr2=new MRTask2(){
    @Override public void map(    Chunk chks[],    NewChunk nchks[]){
      for (int i=0; i < nchks.length; i++) {
        NewChunk n=nchks[i];
        Chunk c0=!lf ? null : chks[i];
        Chunk c1=!rf ? null : chks[i + (lf ? nchks.length : 0)];
        int rlen=(lf ? c0 : c1)._len;
        for (int r=0; r < rlen; r++) {
          if (chks[i]._vec.isEnum())           n.addNA();
 else           n.addNum(bin.op(lf ? c0.at0(r) : fd0,rf ? c1.at0(r) : fd1));
        }
      }
    }
  }
.doAll(ncols,fr).outputFrame((lf ? fr0 : fr1)._names,(lf ? fr0 : fr1).domains());
  if (fr0 != null)   env.subRef(fr0,k0);
  if (fr1 != null)   env.subRef(fr1,k1);
  env.pop();
  env.push(fr2);
}
