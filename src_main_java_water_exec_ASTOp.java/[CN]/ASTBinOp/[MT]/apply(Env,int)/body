{
  Frame fr0=null, fr1=null;
  double d0=0, d1=0;
  if (env.isFrame())   fr1=env.popFrame();
 else   d1=env.popDbl();
  if (env.isFrame())   fr0=env.popFrame();
 else   d0=env.popDbl();
  if (fr0 == null && fr1 == null) {
    env.poppush(op(d0,d1));
    return;
  }
  final boolean lf=fr0 != null;
  final boolean rf=fr1 != null;
  final double fd0=d0;
  final double fd1=d1;
  Frame fr=null;
  int ncols=0;
  if (fr0 != null) {
    ncols=fr0.numCols();
    if (fr1 != null) {
      if (fr0.numCols() != fr1.numCols() || fr0.numRows() != fr1.numRows())       throw new IllegalArgumentException("Arrays must be same size: " + fr0 + " vs "+ fr1);
      fr=new Frame(fr0).add(fr1);
    }
 else {
      fr=fr0;
    }
  }
 else {
    ncols=fr1.numCols();
    fr=fr1;
  }
  final ASTBinOp bin=this;
  Frame fr2=new MRTask2(){
    @Override public void map(    Chunk chks[],    NewChunk nchks[]){
      for (int i=0; i < nchks.length; i++) {
        NewChunk n=nchks[i];
        Chunk c0=!lf ? null : chks[i];
        Chunk c1=!rf ? null : chks[i + (lf ? nchks.length : 0)];
        int rlen=(lf ? c0 : c1)._len;
        for (int r=0; r < rlen; r++)         n.addNum(bin.op(lf ? c0.at0(r) : fd0,rf ? c1.at0(r) : fd1));
      }
    }
  }
.doAll(ncols,fr).outputFrame(fr._names,fr.domains());
  if (fr0 != null)   env.subRef(fr0);
  if (fr1 != null)   env.subRef(fr1);
  env.pop();
  env.push(fr2);
}
