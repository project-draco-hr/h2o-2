{
  Frame frtst=null, frtru=null, frfal=null;
  double dtst=0, dtru=0, dfal=0;
  if (env.isFrame())   frfal=env.popFrame();
 else   dfal=env.popDbl();
  if (env.isFrame())   frtru=env.popFrame();
 else   dtru=env.popDbl();
  if (env.isFrame())   frtst=env.popFrame();
 else   dtst=env.popDbl();
  if (frtst == null) {
    if (frtru == null && frfal != null || frtru != null && frfal == null)     throw H2O.unimpl();
    if (frtru == null)     env.push(dtst == 0 ? dfal : dtru);
 else {
      Frame fr=dtst == 0 ? frfal : frtru;
      env.subRef(dtst == 0 ? frtru : frfal);
      env.push(1);
      env._fr[env._sp - 1]=fr;
    }
    return;
  }
  Frame fr=new Frame(frtst);
  final int ncols=frtst.numCols();
  final long nrows=frtst.numRows();
  if (frtru != null) {
    if (frtru.numCols() != ncols || frtru.numRows() != nrows)     throw new IllegalArgumentException("Arrays must be same size: " + frtst + " vs "+ frtru);
    fr.add(frtru);
  }
  if (frfal != null) {
    if (frfal.numCols() != ncols || frfal.numRows() != nrows)     throw new IllegalArgumentException("Arrays must be same size: " + frtst + " vs "+ frfal);
    fr.add(frfal);
  }
  final boolean t=frtru != null;
  final boolean f=frfal != null;
  final double fdtru=dtru;
  final double fdfal=dfal;
  Frame fr2=new MRTask2(){
    @Override public void map(    Chunk chks[],    NewChunk nchks[]){
      for (int i=0; i < nchks.length; i++) {
        NewChunk n=nchks[i];
        int off=i;
        Chunk ctst=chks[off];
        Chunk ctru=t ? chks[off+=ncols] : null;
        Chunk cfal=f ? chks[off+=ncols] : null;
        int rlen=ctst._len;
        for (int r=0; r < rlen; r++)         if (ctst.isNA0(r))         n.addNA();
 else         n.addNum(ctst.at0(r) != 0 ? (t ? ctru.at0(r) : fdtru) : (f ? cfal.at0(r) : fdfal));
      }
    }
  }
.doAll(ncols,fr).outputFrame(fr._names,fr.domains());
  env.subRef(frtst);
  if (frtru != null)   env.subRef(frtru);
  if (frfal != null)   env.subRef(frfal);
  env.pop();
  env.push(fr2);
}
