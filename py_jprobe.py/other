import random, jenkinsapi, getpass, re, os, argparse, shutil, json, logging
import string
from jenkinsapi.jenkins import Jenkins
from see import see
parse = argparse.ArgumentParser()
group = parse.add_mutually_exclusive_group()
group.add_argument('-e', help='job number from a list of ec2 known jobs', type=int, action='store', default=None)
group.add_argument('-x', help='job number from a list of 164 known jobs', type=int, action='store', default=None)
group.add_argument('-j', '--jobname', help='jobname. Correct url is found', action='store', default=None)
parse.add_argument('-l', '--logging', help='turn on logging.DEBUG msgs to see allUrls used', action='store_true')
args = parse.parse_args()
print 'creates jsandbox (cleaned), and puts aTxt.txt and aConsole.txt in there, along with artifacts'
print ' also creates fails* and regress* in there'
allowedJobsX = ['h2o_master_test', 'h2o_release_tests', 'h2o_release_tests2', 'h2o_release_tests_164', 'h2o_release_tests_c10_only', 'h2o_perf_test', 'h2o_release_Runit']
allowedJobsE = ['h2o.tests.single.jvm', 'h2o.tests.single.jvm.fvec', 'h2o.multi.vm.temporary', 'h2o.tests.ec2.multi.jvm', 'h2o.tests.ec2.multi.jvm.fvec', 'h2o.tests.ec2.hosts']
allUrls = {'ec2': 'http://test.0xdata.com', '164': 'http://192.168.1.164:8080', }
all164Jobs = ['do all', 'h2o_master_test', 'h2o_master_test2', 'h2o_perf_test', 'h2o_private_json_vers_Runit', 'h2o_release_Runit', 'h2o_release_tests', 'h2o_release_tests2', 'h2o_release_tests_164', 'h2o_release_tests_c10_only', 'h2o_release_tests_cdh3', 'h2o_release_tests_cdh4', 'h2o_release_tests_cdh4_yarn', 'h2o_release_tests_cdh5', 'h2o_release_tests_cdh5_yarn', 'h2o_release_tests_hdp1.3', 'h2o_release_tests_hdp2.0.6', 'h2o_release_tests_mapr', 'selenium12']
allEc2Jobs = ['generic.h2o.build.branch', 'h2o.branch.api-dev', 'h2o.branch.cliffc-drf', 'h2o.branch.hilbert', 'h2o.branch.jobs', 'h2o.branch.jobs1', 'h2o.branch.json_versioning', 'h2o.branch.rel-ito', 'h2o.build', 'h2o.build.api-dev', 'h2o.build.gauss', 'h2o.build.godel', 'h2o.build.h2oscala', 'h2o.build.hilbert', 'h2o.build.jobs', 'h2o.build.master', 'h2o.build.rel-ito', 'h2o.build.rel-ivory', 'h2o.build.rel-iwasawa', 'h2o.build.rel-jacobi', 'h2o.build.rel-jordan', 'h2o.build.rest_api_versioning', 'h2o.build.ux-client', 'h2o.build.va_defaults_renamed', 'h2o.clone', 'h2o.datasets', 'h2o.download.latest', 'h2o.ec2.start', 'h2o.ec2.stop', 'h2o.findbugs', 'h2o.multi.vm.temporary', 'h2o.multi.vm.temporary.cliffc-no-limits', 'h2o.nightly', 'h2o.nightly.1', 'h2o.nightly.cliffc-lock', 'h2o.nightly.ec2', 'h2o.nightly.ec2.cliffc-no-limits', 'h2o.nightly.ec2.erdos', 'h2o.nightly.ec2.hilbert', 'h2o.nightly.ec2.rel-ito', 'h2o.nightly.ec2.rel-jacobi', 'h2o.nightly.ec2.rel-jordan', 'h2o.nightly.fourier', 'h2o.nightly.godel', 'h2o.nightly.multi.vm', 'h2o.nightly.rel-ivory', 'h2o.nightly.rel-iwasawa', 'h2o.nightly.rel-jacobi', 'h2o.nightly.rel-jordan', 'h2o.nightly.va_defaults_renamed', 'h2o.post.push', 'h2o.private.nightly', 'h2o.tests.ec2', 'h2o.tests.ec2.hosts', 'h2o.tests.ec2.multi.jvm', 'h2o.tests.ec2.multi.jvm.fvec', 'h2o.tests.golden', 'h2o.tests.junit', 'h2o.tests.multi.jvm', 'h2o.tests.multi.jvm.fvec', 'h2o.tests.single.jvm', 'h2o.tests.single.jvm.fvec', 'h2o.tests.test']
if args.logging:
    logging.basicConfig(level=logging.DEBUG)
if (args.jobname and (args.e or args.x)):
    raise Exception("Don't use both -j and -x or -e args")
if (args.e and args.x):
    raise Exception("Don't use both -e and -x args")
if (args.e is not None):
    if ((args.e < 0) or (args.e > (len(allowedJobsE) - 1))):
        raise Exception(('ec2 job number %s is outside allowed range: 0-%s' % (args.e, (len(allowedJobsE) - 1))))
    jobname = allowedJobsE[args.e]
elif (args.x is not None):
    if ((args.x < 0) or (args.x > (len(allowedJobsX) - 1))):
        raise Exception(('0xdata job number %s is outside allowed range: 0-%s' % (args.x, (len(allowedJobsX) - 1))))
    jobname = allowedJobsX[args.x]
else:
    jobname = allowedJobsE[0]
if args.jobname:
    if (args.jobname not in allowedJobs):
        raise Exception(('%s not in list of legal jobs' % args.jobname))
    jobname = args.jobname
if (jobname in allEc2Jobs):
    machine = 'ec2'
elif (jobname in all164Jobs):
    machine = '164'
else:
    raise Exception(('%s not in lists of known jobs' % jobname))
if (machine not in allUrls):
    raise Exception(('%s not in allUrls dict' % machine))
jenkins_url = allUrls[machine]
print 'machine:', machine
(username, password) = login(machine)
LOG_DIR = clean_sandbox('sandbox')
J = Jenkins(jenkins_url, username, password)
print ('\nCurrent jobs available at %s' % jenkins_url)
print J.keys()
print '\nChecking this job:', J[jobname]
job = J[jobname]
print ('\nGetting %s job config' % jobname)
print job.get_config
s = ('%s' % job.get_config)
print s
import xml.dom.minidom
xml = xml.dom.minidom.parseString(s)
pretty_xml = xml.toprettyxml()
print '#************************'
print 'Pretty Xml for job config'
print pretty_xml
print '#************************'
print '\nlast good build:'
lgb = job.get_last_good_build()
print '\nlast good build revision:'
print lgb.get_revision()
if (1 == 0):
    expr = 'commands.log'
    print ('testing search_artifact_by_regexp with expression %s' % expr)
    from jenkinsapi.api import search_artifact_by_regexp
    artifact_regexp = re.compile(expr)
    result = search_artifact_by_regexp(jenkins_url, jobname, artifact_regexp)
    print ('tested search_artifact_by_regexp', repr(result))
print 'last_good_buildnumber', job.get_last_good_buildnumber()
print 'last_buildnumber', job.get_last_buildnumber()
print ('Using last_buildnumber %s for result set' % job.get_last_buildnumber())
build = job.get_build(job.get_last_good_buildnumber())
af = build.get_artifacts()
dict_af = build.get_artifact_dict()
buildstatus = build.get_status()
print 'build get_status', buildstatus
buildname = build.name
print 'build name', buildname
buildnumber = build.get_number()
print 'build number', buildnumber
buildrevision = build.get_revision()
print 'build revision', buildrevision
buildbranch = build.get_revision_branch()
print 'build revision branch', buildbranch
buildduration = build.get_duration()
print 'build duration', buildduration
buildupstream = build.get_upstream_job_name()
print 'build upstream job name', buildupstream
buildgood = build.is_good()
print 'build is_good', buildgood
buildtimestamp = build.get_timestamp()
print 'build timestamp', buildtimestamp
consoleTxt = open((LOG_DIR + '/console.txt'), 'a')
print 'getting build console (how to buffer this write?)'
print 'probably better to figure how to save it as file'
c = build.get_console()
consoleTxt.write(c)
consoleTxt.close()
print 'build has result set', build.has_resultset()
print 'build get result set'
rs = build.get_resultset()
print 'build result set name', rs.name
print 
aTxt = open((LOG_DIR + '/artifacts.txt'), 'a')
PRINTALL = False
see(buildtimestamp)
t = buildtimestamp
hm = ('%s_%s' % (t.hour, t.minute))
hms = ('%s_%s' % (hm, t.second))
failName = ('%s_%s_%s_%s%s' % ('fail', jobname, buildnumber, hm, '.txt'))
print 'failName:', failName
regressName = ('%s_%s_%s_%s%s' % ('regress', jobname, buildnumber, hm, '.txt'))
print 'regressName:', regressName
stats = {}
for (i, (k, v)) in enumerate(rs.items()):
    if (v.status in stats):
        stats[v.status] += 1
    else:
        stats[v.status] = 1
    e1 = '\n******************************************************************************'
    e2 = ('%s %s %s' % (i, jobname, v))
    aTxt.write((e1 + '\n'))
    aTxt.write((e2 + '\n'))
    if (v.status != 'PASSED'):
        fTxt = open(((LOG_DIR + '/') + failName), 'a')
        printStuff()
        fTxt.close()
    if (v.status == 'REGRESSION'):
        fTxt = open(((LOG_DIR + '/') + regressName), 'a')
        printStuff()
        fTxt.close()
    if PRINTALL:
        fprint(i, 'k', k)
        fprint(i, 'v', v)
        fprint(i, 'v.errorDetails', v.errorDetails)
        fprint(i, 'v.age', v.age)
        fprint(i, 'v.className', v.className)
        fprint(i, 'v.identifier()', v.identifier())
        fprint(i, 'v.name', v.name)
        fprint(i, 'v.skipped', v.age)
        fprint(i, 'v.skippedMessage', v.skippedMessage)
        fprint(i, 'v.status', v.status)
        fprint(i, 'v.stdout', v.stdout)
if (1 == 1):
    for a in af:
        e = ('%s %s %s %s\n' % ('#', a.filename, a.url, '########### artifact saved ####################'))
        aTxt.write((e + '\n'))
        a.save_to_dir(LOG_DIR)
        consoleTxt.close()
aTxt.close()
print '#***********************************************'
print 'Build:', buildname
print buildtimestamp
print 'Status:', buildstatus
if buildgood:
    print 'Build is good'
else:
    print 'Build is bad'
print 'Build number', buildnumber
print buildbranch
print 'Duration', buildduration
print 'Upstream job', buildupstream
print 'Test summary'
for s in stats:
    print s, stats[s]
dirname = ('%s_%s_%s_%s' % ('sandbox', jobname, buildnumber, hm))
if os.path.exists(dirname):
    shutil.rmtree(dirname)
os.rename(LOG_DIR, dirname)
print 'Results are in', dirname
print '#***********************************************'
