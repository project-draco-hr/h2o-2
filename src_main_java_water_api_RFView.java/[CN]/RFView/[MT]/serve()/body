{
  int tasks=0;
  int finished=0;
  RFModel model=_modelKey.value();
  double[] weights=_weights.value();
  tasks=model._totalTrees;
  finished=model.size();
  JsonObject response=defaultJsonResponse();
  if (!_noCM.value()) {
    int modelSize=tasks * _refreshTresholdCM.value() / 100;
    modelSize=modelSize == 0 || finished == tasks ? finished : modelSize * (finished / modelSize);
    Confusion confusion=Confusion.make(model,modelSize,_dataKey.value()._key,_classCol.value(),weights,_oobee.value());
    response.addProperty(JSON_CONFUSION_KEY,confusion.keyFor().toString());
    if (confusion.isValid() && modelSize > 0) {
      JsonObject cm=new JsonObject();
      JsonArray cmHeader=new JsonArray();
      JsonArray matrix=new JsonArray();
      cm.addProperty(JSON_CM_TYPE,_oobee.value() ? "OOB error estimate" : "full scoring");
      cm.addProperty(JSON_CM_CLASS_ERR,confusion.classError());
      cm.addProperty(JSON_CM_ROWS_SKIPPED,confusion.skippedRows());
      cm.addProperty(JSON_CM_ROWS,confusion.rows());
      for (      String s : cfDomain(confusion,1024))       cmHeader.add(new JsonPrimitive(s));
      cm.add(JSON_CM_HEADER,cmHeader);
      final int nclasses=confusion.dimension();
      JsonArray classErrors=new JsonArray();
      for (int crow=0; crow < nclasses; ++crow) {
        JsonArray row=new JsonArray();
        int classHitScore=0;
        for (int ccol=0; ccol < nclasses; ++ccol) {
          row.add(new JsonPrimitive(confusion._matrix[crow][ccol]));
          if (crow != ccol)           classHitScore+=confusion._matrix[crow][ccol];
        }
        classErrors.add(new JsonPrimitive((float)classHitScore / (classHitScore + confusion._matrix[crow][crow])));
        matrix.add(row);
      }
      cm.add(JSON_CM_CLASSES_ERRORS,classErrors);
      cm.add(JSON_CM_MATRIX,matrix);
      cm.addProperty(JSON_CM_TREES,confusion._treesUsed);
      response.add(JSON_CM,cm);
    }
  }
  JsonObject trees=new JsonObject();
  trees.addProperty(Constants.TREE_COUNT,model.size());
  if (model.size() > 0) {
    trees.add(Constants.TREE_DEPTH,model.depth().toJson());
    trees.add(Constants.TREE_LEAVES,model.leaves().toJson());
  }
  response.add(Constants.TREES,trees);
  Response r;
  if (finished == tasks) {
    r=jobDone(response);
    r.addHeader("<div class='alert'>" + RFScore.link(model._selfKey,MODEL_KEY,"Use this model for scoring.") + " </div>");
  }
 else {
    r=Response.poll(response,finished,tasks);
  }
  r.setBuilder(JSON_CM,new ConfusionMatrixBuilder());
  r.setBuilder(TREES,new TreeListBuilder());
  return r;
}
