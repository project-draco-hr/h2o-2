def test_rf_predict3_10pct_fvec(self):
    h2o.beta_features = True
    SYNDATASETS_DIR = h2o.make_syn_dir()
    timeoutSecs = 60
    predictHexKey = 'predict.hex'
    predictCsv = 'predict.csv'
    if (1 == 0):
        skipSrcHeader = True
        trees = 6
        bucket = 'smalldata'
        csvPathname = 'iris/iris2.csv'
        hexKey = 'iris2.csv.hex'
        translate = {'setosa': 0.0, 'versicolor': 1.0, 'virginica': 2.0, }
        translate = {'setosa': 'setosa', 'versicolor': 'versicolor', 'virginica': 'virginica', }
    elif (1 == 1):
        skipSrcHeader = False
        trees = 6
        bucket = 'home-0xdiag-datasets'
        csvPathname = 'standard/covtype.shuffled.10pct.data'
        hexKey = 'covtype.shuffled.10pct.data.hex'
        translate = {'1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, }
    else:
        skipSrcHeader = False
        trees = 6
        bucket = 'home-0xdiag-datasets'
        csvPathname = 'standard/covtype.data'
        hexKey = 'covtype.data.hex'
        translate = {'1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, }
    csvPredictPathname = ((SYNDATASETS_DIR + '/') + predictCsv)
    csvFullname = h2i.find_folder_and_filename(bucket, csvPathname, schema='put', returnFullPath=True)

    def predict_and_compare_csvs(model_key, translate=None):
        start = time.time()
        predict = h2o.nodes[0].generate_predictions(model_key=model_key, data_key=hexKey, destination_key=predictHexKey)
        print 'generate_predictions end on ', hexKey, ' took', (time.time() - start), 'seconds'
        h2o.check_sandbox_for_errors()
        inspect = h2o_cmd.runInspect(key=predictHexKey)
        h2o_cmd.infoFromInspect(inspect, 'predict.hex')
        h2o.nodes[0].csv_download(src_key=predictHexKey, csvPathname=csvPredictPathname)
        h2o.check_sandbox_for_errors()
        print 'Do a check of the original output col against predicted output'
        (rowNum1, originalOutput) = compare_csv(csvFullname, col=(-1), msg='Original', translate=translate, skipHeader=skipSrcHeader)
        (rowNum2, predictOutput) = compare_csv(csvPredictPathname, col=0, msg='Predicted', skipHeader=True)
        expHeaderMismatch = (0 if skipSrcHeader else 1)
        if ((rowNum1 + expHeaderMismatch) != rowNum2):
            raise Exception(('original rowNum1: %s + %s not same as downloaded predict rowNum2: %s' % (rowNum1, expHeaderMismatch, rowNum2)))
        wrong = 0
        for (rowNum, (o, p)) in enumerate(zip(originalOutput, predictOutput)):
            if (str(o) != str(p)):
                if (wrong == 10):
                    print 'Not printing any more mismatches\n'
                elif (wrong < 10):
                    msg = ('Comparing original output col vs predicted. row %s differs.                             original: %s predicted: %s' % (rowNum, o, p))
                    print msg
                wrong += 1
        print '\nTotal wrong:', wrong
        print 'Total:', len(originalOutput)
        pctWrong = ((100.0 * wrong) / len(originalOutput))
        print 'pctWrong: (wrong/Total * 100) = ', pctWrong
        if (pctWrong > 2.0):
            raise Exception("pct wrong too high. Expect < 2% error because it's reusing training data")
    parseResult = h2i.import_parse(bucket=bucket, path=csvPathname, schema='put', hex_key=hexKey)
    kwargs = {'destination_key': 'rf_model', 'ntrees': trees, }
    rfResult = h2o_cmd.runRF(parseResult=parseResult, timeoutSecs=timeoutSecs, **kwargs)
    (classification_error, classErrorPctList, totalScores) = h2o_rf.simpleCheckRFView(rfv=rfResult)
    print 'Use H2O GeneratePredictionsPage with a H2O generated model and the same data key.'
    print "Does this work? (feeding in same data key)if you're predicting, "
    print "don't you need one less column (the last is output?)"
    print 'WARNING: max_iter set to 8 for benchmark comparisons'
    predict_and_compare_csvs(model_key='rf_model', translate=translate)
