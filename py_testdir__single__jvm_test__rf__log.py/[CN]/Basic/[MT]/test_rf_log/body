def test_rf_log(self):
    SYNDATASETS_DIR = h2o.make_syn_dir()
    tryList = [(10000, 10, 'cA', 300)]
    for (rowCount, colCount, hex_key, timeoutSecs) in tryList:
        SEEDPERFILE = random.randint(0, sys.maxint)
        csvFilename = (((('syn_test_' + str(rowCount)) + 'x') + str(colCount)) + '.csv')
        csvPathname = ((SYNDATASETS_DIR + '/') + csvFilename)
        print 'Creating random', csvPathname
        write_syn_dataset(csvPathname, rowCount, colCount, SEEDPERFILE)
        testParseResult = h2i.import_parse(path=csvPathname, hex_key=hex_key, schema='put', timeoutSecs=10)
        print "Test Parse result['destination_key']:", testParseResult['destination_key']
        dataKeyTest = testParseResult['destination_key']
        csvFilename = (((('syn_train_' + str(rowCount)) + 'x') + str(colCount)) + '.csv')
        csvPathname = ((SYNDATASETS_DIR + '/') + csvFilename)
        print 'Creating random', csvPathname
        write_syn_dataset(csvPathname, rowCount, colCount, SEEDPERFILE)
        trainParseResult = h2i.import_parse(path=csvPathname, hex_key=hex_key, schema='put', timeoutSecs=10)
        print "Train Parse result['destination_key']:", trainParseResult['destination_key']
        dataKeyTrain = trainParseResult['destination_key']
        kwargs = paramDict.copy()
        timeoutSecs = (30 + (kwargs['ntree'] * 20))
        start = time.time()
        kwargs['out_of_bag_error_estimate'] = 1
        kwargs['response_variable'] = colCount
        rfv = h2o_cmd.runRF(parseResult=trainParseResult, timeoutSecs=timeoutSecs, **kwargs)
        elapsed = (time.time() - start)
        print 'RF end on ', csvPathname, 'took', elapsed, 'seconds.', ('%d pct. of timeout' % ((elapsed / timeoutSecs) * 100))
        oobeTrainPctRight = (100 * (1.0 - rfv['confusion_matrix']['classification_error']))
        expectTrainPctRight = 98
        self.assertAlmostEqual(oobeTrainPctRight, expectTrainPctRight, msg=('OOBE: pct. right for training not close enough %6.2f %6.2f' % (oobeTrainPctRight, expectTrainPctRight)), delta=1)
        print 'Now score with the 2nd random dataset'
        model_key = rfv['model_key']
        kwargs.pop('model_key', None)
        data_key = rfv['data_key']
        kwargs.pop('data_key', None)
        ntree = rfv['ntree']
        kwargs.pop('ntree', None)
        kwargs['iterative_cm'] = 1
        kwargs['out_of_bag_error_estimate'] = 0
        rfv = h2o_cmd.runRFView(None, dataKeyTest, model_key, ntree, timeoutSecs, retryDelaySecs=1, print_params=True, **kwargs)
        (classification_error, classErrorPctList, totalScores) = h2o_rf.simpleCheckRFView(rfv=rfv, ntree=ntree)
        self.assertAlmostEqual(classification_error, 0.03, delta=0.5, msg=('Classification error %s differs too much' % classification_error))
        predict = h2o.nodes[0].generate_predictions(model_key=model_key, data_key=dataKeyTest)
        fullScorePctRight = (100 * (1.0 - rfv['confusion_matrix']['classification_error']))
        expectScorePctRight = 99
        self.assertAlmostEqual(fullScorePctRight, expectScorePctRight, msg=('Full: pct. right for scoring not close enough %6.2f %6.2f' % (fullScorePctRight, expectScorePctRight)), delta=1)
