{
  double[] ds=new double[_cols.size()];
  for (int i=0; i < ds.length; i++) {
    Double D=(Double)row.get(_cols.get(i));
    if (D == null)     throw new RuntimeException("row is missing column " + _cols.get(i) + ", contains "+ row.keySet());
    ds[i]=D;
  }
  int votes[]=new int[_classes.length + 1];
  for (  byte[] tree : _trees)   votes[(int)Tree.classify(new AutoBuffer(tree),ds,_classes.length)]++;
  int result=0;
  int tied=1;
  for (int i=1; i < votes.length - 1; i++)   if (votes[i] > votes[result]) {
    result=i;
    tied=1;
  }
 else   if (votes[i] == votes[result]) {
    tied++;
  }
  if (tied == 1)   return (short)result;
  Random rand=null;
  int j=rand == null ? 0 : rand.nextInt(tied);
  int k=0;
  for (int i=0; i < votes.length - 1; i++)   if (votes[i] == votes[result] && (k++ >= j))   return (short)i;
  throw H2O.unimpl();
}
