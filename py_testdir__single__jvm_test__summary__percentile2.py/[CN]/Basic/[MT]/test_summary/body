def test_summary(self):
    SYNDATASETS_DIR = h2o.make_syn_dir()
    tryList = [(500000, 1, 'cD', 300, 0, 9), (500000, 2, 'cE', 300, 1, 10), (500000, 2, 'cF', 300, 2, 11)]
    timeoutSecs = 10
    trial = 1
    n = h2o.nodes[0]
    lenNodes = len(h2o.nodes)
    x = 0
    for (rowCount, colCount, hex_key, timeoutSecs, expectedMin, expectedMax) in tryList:
        SEEDPERFILE = random.randint(0, sys.maxint)
        x += 1
        csvFilename = (((((('syn_' + 'binary') + '_') + str(rowCount)) + 'x') + str(colCount)) + '.csv')
        csvPathname = ((SYNDATASETS_DIR + '/') + csvFilename)
        print 'Creating random', csvPathname
        legalValues = {}
        for x in range(expectedMin, expectedMax):
            legalValues[x] = x
        write_syn_dataset(csvPathname, rowCount, colCount, expectedMin, expectedMax, SEEDPERFILE)
        parseResult = h2i.import_parse(path=csvPathname, schema='put', hex_key=hex_key, timeoutSecs=10, doSummary=False)
        print csvFilename, 'parse time:', parseResult['response']['time']
        print "Parse result['destination_key']:", parseResult['destination_key']
        inspect = h2o_cmd.runInspect(None, parseResult['destination_key'])
        print ('\n' + csvFilename)
        summaryResult = h2o_cmd.runSummary(key=hex_key, cols=0, max_ncols=1)
        if h2o.verbose:
            print 'summaryResult', h2o.dump_json(summaryResult)
        h2o_cmd.infoFromSummary(summaryResult, noPrint=False)
        summary = summaryResult['summary']
        columnsList = summary['columns']
        for columns in columnsList:
            N = columns['N']
            self.assertEqual(N, rowCount)
            name = columns['name']
            stype = columns['type']
            self.assertEqual(stype, 'number')
            histogram = columns['histogram']
            bin_size = histogram['bin_size']
            self.assertEqual(bin_size, 1)
            bin_names = histogram['bin_names']
            bins = histogram['bins']
            nbins = histogram['bins']
            for b in bins:
                e = (0.1 * rowCount)
                self.assertAlmostEqual(b, (0.1 * rowCount), delta=(0.01 * rowCount), msg=('Bins not right. b: %s e: %s' % (b, e)))
            if (stype != 'enum'):
                smax = columns['max']
                smin = columns['min']
                percentiles = columns['percentiles']
                thresholds = percentiles['thresholds']
                values = percentiles['values']
                mean = columns['mean']
                sigma = columns['sigma']
                self.assertEqual(smax[0], expectedMax)
                self.assertEqual(smax[1], (expectedMax - 1))
                self.assertEqual(smax[2], (expectedMax - 2))
                self.assertEqual(smax[3], (expectedMax - 3))
                self.assertEqual(smax[4], (expectedMax - 4))
                self.assertEqual(smin[0], expectedMin)
                self.assertEqual(smin[1], (expectedMin + 1))
                self.assertEqual(smin[2], (expectedMin + 2))
                self.assertEqual(smin[3], (expectedMin + 3))
                self.assertEqual(smin[4], (expectedMin + 4))
                for v in values:
                    self.assertTrue((v >= expectedMin), ('Percentile value %s should all be >= the min dataset value %s' % (v, expectedMin)))
                    self.assertTrue((v <= expectedMax), ('Percentile value %s should all be <= the max dataset value %s' % (v, expectedMax)))
                self.assertAlmostEqual(mean, ((expectedMax + expectedMin) / 2.0), delta=0.1)
                self.assertAlmostEqual(sigma, 2.9, delta=0.1)
                eV1 = [1.0, 1.0, 1.0, 3.0, 4.0, 5.0, 7.0, 8.0, 9.0, 10.0, 10.0]
                if (expectedMin == 1):
                    eV = eV1
                elif (expectedMin == 0):
                    eV = [(e - 1) for e in eV1]
                elif (expectedMin == 2):
                    eV = [(e + 1) for e in eV1]
                else:
                    raise Exception(("Test doesn't have the expected values for expectedMin: %s" % expectedMin))
                for (t, v, e) in zip(thresholds, values, eV):
                    m = ('Percentile threshold: %s with value %s should ~= %s' % (t, v, e))
                    self.assertAlmostEqual(v, e, delta=0.5, msg=m)
        trial += 1
        if (1 == 0):
            generate_scipy_comparison(csvPathname)
