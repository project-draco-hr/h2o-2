{
  if (setup == null) {
    ArrayList<Key> ks=new ArrayList<Key>(keys.length);
    for (    Key k : keys)     ks.add(k);
    PSetupGuess guess=guessSetup(ks,null,new ParserSetup(),true);
    if (!guess.valid())     throw new RuntimeException("can not parse this dataset, did not find working setup");
    setup=guess._setup;
  }
  setup.checkColumnNames();
  int j=0;
  new ValueArray(job.dest(),0).delete_and_lock(job.self());
  Key[] nonEmptyKeys=new Key[keys.length];
  for (int i=0; i < keys.length; ++i) {
    Value v=DKV.get(keys[i]);
    if (v == null || v.length() > 0)     nonEmptyKeys[j++]=keys[i];
  }
  if (j < nonEmptyKeys.length)   keys=Arrays.copyOf(nonEmptyKeys,j);
  if (keys.length == 0) {
    job.cancel();
    return;
  }
  if (setup == null || setup._pType == ParserType.XLS) {
    DParseTask p1=tryParseXls(DKV.get(keys[0]),job);
    if (p1 != null) {
      if (keys.length == 1) {
        DParseTask p2=p1.createPassTwo();
        p2.passTwo();
        p2.createValueArrayHeader();
        Lockable.delete(keys[0]);
        job.remove();
        return;
      }
 else       throw H2O.unimpl();
    }
  }
  UnzipAndParseTask tsk=new UnzipAndParseTask(job,setup);
  tsk.invoke(keys);
  DParseTask[] p2s=new DParseTask[keys.length];
  DParseTask phaseTwo=tsk._tsk.createPassTwo();
  HashMap<Key,FileInfo> fileInfo=new HashMap<Key,FileInfo>();
  long rowCount=0;
  for (int i=0; i < tsk._fileInfo.length; ++i)   fileInfo.put(tsk._fileInfo[i]._ikey,tsk._fileInfo[i]);
  for (int i=0; i < keys.length; ++i) {
    FileInfo finfo=fileInfo.get(keys[i]);
    Key k=finfo._okey;
    long nrows=finfo._nrows[finfo._nrows.length - 1];
    for (j=0; j < finfo._nrows.length; ++j)     finfo._nrows[j]+=rowCount;
    rowCount+=nrows;
    p2s[i]=phaseTwo.makePhase2Clone(finfo).dfork(k);
  }
  phaseTwo._sigma=new double[phaseTwo._ncolumns];
  phaseTwo._invalidValues=new long[phaseTwo._ncolumns];
  for (int i=0; i < p2s.length; ++i) {
    DParseTask t=p2s[i];
    try {
      p2s[i].get();
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
    Utils.add(phaseTwo._sigma,t._sigma);
    Utils.add(phaseTwo._invalidValues,t._invalidValues);
    if ((t._error != null) && !t._error.isEmpty()) {
      System.err.println(phaseTwo._error);
      throw new RuntimeException("The dataset format is not recognized/supported");
    }
    FileInfo finfo=fileInfo.get(keys[i]);
    Value val=DKV.get(finfo._okey);
    if (val.isArray())     ((ValueArray)val.get()).delete();
 else     DKV.remove(finfo._okey);
  }
  phaseTwo.normalizeSigma();
  phaseTwo._colNames=setup._columnNames;
  if (setup._header)   phaseTwo.setColumnNames(setup._columnNames);
  phaseTwo.createValueArrayHeader();
}
