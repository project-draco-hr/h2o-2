{
  if (data._modelDataMap.length != eigvec.length)   throw new RuntimeException("Mismatched dimensions! Model matrix has " + data._modelDataMap.length + " features, while eigenvector matrix has "+ eigvec.length+ " features");
  final Frame origModel=data.modelAsFrame();
  final PCAScoreJob job=new PCAScoreJob(origModel,dataKey,destKey,standardize);
  final H2OCountedCompleter fjtask=new H2OCountedCompleter(){
    @Override public void compute2(){
      Frame lmatrix=origModel;
      if (standardize) {
        int ncol=origModel.numCols();
        Vec[] vecs=Arrays.copyOf(origModel.vecs(),2 * ncol);
        for (int i=0; i < ncol; i++)         vecs[ncol + i]=vecs[0].makeZero();
        StandardizeTask tsk=new StandardizeTask(job,data._normSub,data._normMul).doAll(vecs);
        Vec[] outputVecs=Arrays.copyOfRange(tsk._fr.vecs(),ncol,2 * ncol);
        lmatrix=new Frame(origModel.names(),outputVecs);
      }
      final int ncomp=Math.min(ncol,eigvec[0].length);
      final int nfeat=Math.min(nrow,lmatrix.numCols());
      Vec[] vecs=Arrays.copyOf(lmatrix.vecs(),nfeat + ncomp);
      VectorGroup vg=lmatrix.vecs()[0].group();
      Key[] keys=vg.addVecs(ncomp);
      for (int i=0; i < ncomp; i++) {
        vecs[nfeat + i]=vecs[0].makeZero();
      }
      ScoreTask tsk=new ScoreTask(job,nfeat,ncomp,eigvec).doAll(vecs);
      Vec[] outputVecs=Arrays.copyOfRange(tsk._fr.vecs(),nfeat,nfeat + ncomp);
      String[] names=new String[ncomp];
      for (int i=0; i < ncomp; i++)       names[i]="PC" + i;
      Frame f=new Frame(names,outputVecs);
      DKV.put(destKey,f);
      job.remove();
    }
  }
;
  H2O.submitTask(job.start(fjtask));
  return job;
}
