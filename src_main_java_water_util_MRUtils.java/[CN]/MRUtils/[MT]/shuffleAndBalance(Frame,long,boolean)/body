{
  int cores=0;
  for (  H2ONode node : H2O.CLOUD._memary)   cores+=node._heartbeat._num_cpus;
  final int splits=4 * cores;
  Vec[] vecs=fr.vecs();
  if (vecs[0].nChunks() < splits || shuffle) {
    long[] idx=null;
    if (shuffle) {
      idx=new long[(int)fr.numRows()];
      for (int r=0; r < idx.length; ++r)       idx[r]=r;
      Utils.shuffleArray(idx,seed);
    }
    Key keys[]=new Vec.VectorGroup().addVecs(vecs.length);
    for (int v=0; v < vecs.length; v++) {
      AppendableVec vec=new AppendableVec(keys[v]);
      final long rows=fr.numRows();
      for (int split=0; split < splits; split++) {
        long off=rows * split / splits;
        long lim=rows * (split + 1) / splits;
        assert(lim <= Integer.MAX_VALUE);
        NewChunk chunk=new NewChunk(vec,split);
        for (long r=off; r < lim; r++) {
          if (shuffle)           chunk.addNum(fr.vecs()[v].at(idx[(int)r]));
 else           chunk.addNum(fr.vecs()[v].at(r));
        }
        chunk.close(split,null);
      }
      Vec t=vec.close(null);
      t._domain=vecs[v]._domain;
      vecs[v]=t;
    }
  }
  fr.reloadVecs();
  return new Frame(fr.names(),vecs);
}
