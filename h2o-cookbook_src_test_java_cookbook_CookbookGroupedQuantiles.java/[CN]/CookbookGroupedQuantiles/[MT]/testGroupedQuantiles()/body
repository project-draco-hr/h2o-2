{
  final String INPUT_FILE_NAME="../smalldata/airlines/allyears2k_headers.zip";
  final String KEY_STRING="airlines.hex";
  final String GROUP_COLUMN_NAME="CRSDepTime";
  final String VALUE_COLUMN_NAME="Distance";
  final String WEIGHT_COLUMN_NAME="";
  Key k=Key.make(KEY_STRING);
  Frame fr=parseFrame(k,INPUT_FILE_NAME);
  Log.info("");
  Log.info("Pass 0, add group number columns to frame");
  Log.info("");
  fr.add("sparse_group_number",fr.anyVec().makeZero());
  fr.add("dense_group_number",fr.anyVec().makeZero());
  Futures fs=new Futures();
  UKV.put(k,fr,fs);
  fs.blockForPending();
  Log.info("");
  Log.info("Pass 1, assign group numbers to rows");
  Log.info("");
  final int cyl_idx=fr.find(GROUP_COLUMN_NAME);
  final int sg_idx=fr.find("sparse_group_number");
  final int dg_idx=fr.find("dense_group_number");
  final int val_idx=fr.find(VALUE_COLUMN_NAME);
  final int wt_idx=fr.find(WEIGHT_COLUMN_NAME);
  new AddSparseGroupNumber(cyl_idx,sg_idx).doAll(fr);
  Log.info("");
  Log.info("Pass 2, compact group numbers");
  Log.info("");
  IcedHashMap<IcedLong,IcedLong> sparse_group_number_set=new CompactGroupNumber(sg_idx).doAll(fr).sparse_group_number_set;
  int ng=1;
  for (  IcedLong key : sparse_group_number_set.keySet())   sparse_group_number_set.put(key,new IcedLong(ng++));
  Log.info("");
  Log.info("Pass 3, assign dense group numbers");
  Log.info("");
  new AssignCompactGroupNumber(sparse_group_number_set,sg_idx,dg_idx).doAll(fr);
  Log.info("");
  Log.info("Pass 4, collect basic stats for each dense group");
  Log.info("");
  IcedHashMap<IcedLong,BasicSummary> basic_summaries=fr.with(new MyGroupBy(dg_idx)).with(new BasicSummary(val_idx)).doit();
  Log.info("");
  Log.info("Pass 5, calculate histograms");
  Log.info("");
  IcedHashMap<IcedLong,Histogram> histograms=fr.with(new MyGroupBy(dg_idx)).with(new Histogram(dg_idx,val_idx,wt_idx,false,basic_summaries)).doit();
  Log.info("");
  Log.info("Debug Step 6 (not a real pass), put histograms into a frame for display");
  Log.info("");
  AppendableVec gidVec=new AppendableVec("GID");
  AppendableVec[] avecs=new AppendableVec[1001];
  Vec[] vecs=new Vec[1001];
  NewChunk[] chunks=new NewChunk[1001];
  for (int i=1; i < 1001; i++) {
    avecs[i]=new AppendableVec("Bin_" + i);
    chunks[i]=new NewChunk(avecs[i],0);
  }
  avecs[0]=gidVec;
  chunks[0]=new NewChunk(avecs[0],0);
  fs=new Futures();
  for (  IcedLong key : histograms.keySet()) {
    Histogram hist=histograms.get(key);
    chunks[0].addNum(key._val);
    chunks[0].addNum(key._val);
    double[] bins=hist._bins;
    double[] vals=hist._values;
    for (int i=1; i < 1001; i++) {
      if (i - 1 < bins.length) {
        chunks[i].addNum(bins[i - 1]);
        chunks[i].addNum(vals[i - 1]);
      }
 else {
        chunks[i].addNum(Double.NaN);
        chunks[i].addNum(Double.NaN);
      }
    }
  }
  for (int i=0; i < chunks.length; i++) {
    chunks[i].close(0,fs);
    vecs[i]=avecs[i].close(fs);
  }
  fs.blockForPending();
  String[] vnames=new String[1001];
  vnames[0]="GID";
  for (int i=1; i < 1001; i++)   vnames[i]="Bin_" + (i - 1);
  Frame histfr=new Frame(vnames,vecs);
  Key histfr_key=Key.make("histograms.hex");
  fs=new Futures();
  UKV.put(histfr_key,histfr,fs);
  fs.blockForPending();
  UKV.remove(k);
  UKV.remove(histfr_key);
}
