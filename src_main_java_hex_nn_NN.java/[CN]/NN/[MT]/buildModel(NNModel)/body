{
  Frame[] valid_adapted=null;
  Frame valid=null, validScoreFrame=null;
  Frame train=null, trainScoreFrame=null;
  try {
    lock_data();
    logStart();
    if (model == null) {
      model=UKV.get(dest());
    }
    model.write_lock(self());
    final long model_size=model.model_info().size();
    Log.info("Number of model parameters (weights/biases): " + String.format("%,d",model_size));
    Log.info("Memory usage of the model: " + String.format("%.2f",(double)model_size * Float.SIZE / (1 << 23)) + " MB.");
    train=reBalance(model.model_info().data_info()._adaptedFrame,seed);
    trainScoreFrame=sampleFrame(train,score_training_samples,seed);
    Log.info("Number of chunks of the training data: " + train.anyVec().nChunks());
    if (validation != null) {
      valid_adapted=model.adapt(validation,false);
      valid=reBalance(valid_adapted[0],seed + 1);
      validScoreFrame=sampleFrame(valid,score_validation_samples,seed + 1);
      Log.info("Number of chunks of the validation data: " + valid.anyVec().nChunks());
    }
    if (mini_batch > train.numRows()) {
      Log.warn("Setting mini_batch (" + mini_batch + ") to the number of rows of the training data ("+ (mini_batch=train.numRows())+ ").");
    }
    final float sync_fraction=mini_batch == 0l ? 1.0f : (float)mini_batch / train.numRows();
    if (!quiet_mode)     Log.info("Initial model:\n" + model.model_info());
    Log.info("Starting to train the Neural Net model.");
    long timeStart=System.currentTimeMillis();
    long iter=0;
    Frame newtrain=new Frame(train);
    do {
      model.set_model_info(new NNTask(model.model_info(),sync_fraction).doAll(newtrain).model_info());
      if (++iter % 10 != 0 && shuffle_training_data) {
        Frame newtrain2=reBalance(newtrain,seed + iter);
        if (newtrain != newtrain2) {
          newtrain.delete();
          newtrain=newtrain2;
          trainScoreFrame=sampleFrame(newtrain,score_training_samples,seed + iter + 0xDADDAAAA);
        }
      }
    }
 while (model.doScoring(trainScoreFrame,validScoreFrame,timeStart,self()));
    Log.info("Finished training the Neural Net model.");
    return model;
  }
  finally {
    model.unlock(self());
    if (validScoreFrame != null && validScoreFrame != valid)     validScoreFrame.delete();
    if (trainScoreFrame != null && trainScoreFrame != train)     trainScoreFrame.delete();
    if (validation != null)     valid_adapted[1].delete();
    unlock_data();
  }
}
