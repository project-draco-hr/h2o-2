{
  final int[] distL=new int[d.classes()], distR=dist.clone();
  final double upperBoundReduction=upperBoundReduction(d.classes());
  double maxReduction=-1;
  int bestSplit=-1;
  for (int i=0; i < _columnDists[col].length - 1; ++i) {
    for (int j=0; j < distL.length; ++j) {
      double v=_columnDists[col][i][j];
      distL[j]+=v;
      distR[j]-=v;
    }
    int totL=0, totR=0;
    for (    int e : distL)     totL+=e;
    if (totL == 0)     continue;
    for (    int e : distR)     totR+=e;
    if (totR == 0)     continue;
    double eL=0, eR=0;
    for (    int e : distL)     eL+=gain(e,totL);
    for (    int e : distR)     eR+=gain(e,totR);
    double eReduction=upperBoundReduction - ((eL * totL + eR * totR) / (totL + totR));
    if (eReduction == maxReduction) {
      if (rand.nextInt(10) < 2)       bestSplit=i;
    }
 else     if (eReduction > maxReduction) {
      bestSplit=i;
      maxReduction=eReduction;
    }
  }
  return bestSplit == -1 ? Split.impossible(Utils.maxIndex(dist,_random)) : Split.split(col,bestSplit,maxReduction);
}
