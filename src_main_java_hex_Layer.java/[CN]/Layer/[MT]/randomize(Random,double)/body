{
  if (_w == null)   return;
  if (initial_weight_distribution == NeuralNet.InitialWeightDistribution.UniformAdaptive) {
    final double range=prefactor * Math.sqrt(6. / (_previous.units + units));
    for (int i=0; i < _w.length; i++)     _w[i]=(float)uniformDist(rng,-range,range);
  }
 else {
    if (initial_weight_distribution == NeuralNet.InitialWeightDistribution.Uniform) {
      for (int i=0; i < _w.length; i++) {
        _w[i]=(float)uniformDist(rng,-initial_weight_scale,initial_weight_scale);
      }
    }
 else     if (initial_weight_distribution == NeuralNet.InitialWeightDistribution.Normal) {
      for (int i=0; i < _w.length; i++) {
        _w[i]=(float)(0 + rng.nextGaussian() * initial_weight_scale);
      }
    }
  }
}
