{
  int[] modelDataMap=ary.getColumnIds(_va.colNames());
  if (!isCompatible(modelDataMap))   throw new GLMException("incompatible dataset");
  DataFrame data=new DataFrame(ary,modelDataMap,s,false,true);
  double ymu=ary._cols[modelDataMap[modelDataMap.length - 1]]._mean;
  if (_glmParams._caseMode != CaseMode.none || Double.isNaN(ymu)) {
    final CaseMode caseMode=_glmParams._caseMode;
    final double caseVal=_glmParams._caseVal;
    ymu=new RowFunc<YMUVal>(){
      @Override public YMUVal newResult(){
        return new YMUVal();
      }
      @Override public void processRow(      YMUVal res,      double[] x,      int[] indexes){
        for (        double d : x)         if (Double.isNaN(d))         return;
        double y=x[x.length - 1];
        if (caseMode != CaseMode.none)         y=caseMode.isCase(y,caseVal) ? 1 : 0;
        res.add(y);
      }
      @Override public YMUVal reduce(      YMUVal x,      YMUVal y){
        return x.add(y);
      }
    }
.apply(null,data).val();
  }
  GLMValidationFunc f=new GLMValidationFunc(this,_glmParams,_beta,thresholds,ymu);
  GLMValidation val=f.apply(job,data);
  val._modelKey=_selfKey;
  if (_vals == null)   _vals=new GLMValidation[]{val};
 else {
    int n=_vals.length;
    _vals=Arrays.copyOf(_vals,n + 1);
    _vals[n]=val;
  }
  return val;
}
