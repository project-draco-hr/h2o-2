{
  _errMetric=m;
  _modelKey=models[0]._selfKey;
  _dataKey=models[0]._dataKey;
  _modelKeys=new Key[models.length];
  int i=0;
  boolean solved=true;
  for (  GLMModel xm : models) {
    _modelKeys[i++]=xm._selfKey;
    if (!xm.isSolved())     solved=false;
  }
  if (!solved) {
    _aic=Double.NaN;
    _dof=-1;
    _auc=Double.NaN;
    _deviance=Double.NaN;
    _nullDeviance=Double.NaN;
    _err=Double.NaN;
    _n=-1;
    return;
  }
  long n=0;
  double nDev=0;
  double dev=0;
  double err=0;
  if (models[0]._vals[0]._cm != null) {
    int nthresholds=models[0]._vals[0]._cm.length;
    _cm=new ConfusionMatrix[nthresholds];
    for (int t=0; t < nthresholds; ++t)     _cm[t]=models[0]._vals[0]._cm[t];
    n+=models[0]._vals[0]._n;
    dev=models[0]._vals[0]._deviance;
    nDev=models[0]._vals[0]._nullDeviance;
    for (i=1; i < models.length; ++i) {
      n+=models[i]._vals[0]._n;
      dev+=models[0]._vals[0]._deviance;
      nDev+=models[0]._vals[0]._nullDeviance;
      for (int t=0; t < nthresholds; ++t)       _cm[t].add(models[i]._vals[0]._cm[t]);
    }
    _thresholds=thresholds;
    computeBestThreshold(m);
    computeAUC();
  }
 else {
    for (    GLMModel xm : models) {
      n+=xm._vals[0]._n;
      dev+=xm._vals[0]._deviance;
      nDev+=xm._vals[0]._nullDeviance;
      err+=xm._vals[0]._err;
    }
  }
  _err=err;
  _deviance=dev;
  _nullDeviance=nDev;
  _n=n;
  _aic=models[0]._glmParams._family.aic(_deviance,_n,models[0]._beta.length);
  _dof=_n - models[0]._beta.length - 1;
}
