{
  Frame fr2=adapt(fr,exact);
  Vec v=fr2.anyVec().makeZero();
  v._domain=_domains[_domains.length - 1];
  fr2.add("predict",v);
  if (nclasses() > 1)   for (int c=0; c < nclasses(); c++)   fr2.add(classNames()[c],fr2.anyVec().makeZero());
  new MRTask2(){
    @Override public void map(    Chunk chks[]){
      double tmp[]=new double[_names.length];
      float preds[]=new float[nclasses()];
      Chunk p=chks[_names.length - 1];
      for (int i=0; i < p._len; i++) {
        score0(chks,i,tmp,preds);
        p.set0(i,Utils.maxIndex(preds));
        if (nclasses() > 1)         for (int c=0; c < nclasses(); c++)         chks[_names.length + c].set0(i,preds[c]);
      }
    }
  }
.doAll(fr2);
  int x=_names.length - 1, y=fr2.numCols();
  return new Frame(Arrays.copyOfRange(fr2._names,x,y),Arrays.copyOfRange(fr2.vecs(),x,y));
}
