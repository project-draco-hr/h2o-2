{
  Frame[] adaptFrms=adapt(fr,exact);
  Frame adaptFrm=adaptFrms[0];
  Frame onlyAdaptFrm=adaptFrms[1];
  Vec v=adaptFrm.anyVec().makeZero();
  v._domain=_domains[_domains.length - 1];
  adaptFrm.add("predict",v);
  if (nclasses() > 1)   for (int c=0; c < nclasses(); c++)   adaptFrm.add(classNames()[c],adaptFrm.anyVec().makeZero());
  new MRTask2(){
    @Override public void map(    Chunk chks[]){
      double tmp[]=new double[_names.length];
      float preds[]=new float[nclasses()];
      Chunk p=chks[_names.length - 1];
      for (int i=0; i < p._len; i++) {
        score0(chks,i,tmp,preds);
        if (nclasses() > 1) {
          p.set0(i,Utils.maxIndex(preds));
          for (int c=0; c < nclasses(); c++)           chks[_names.length + c].set0(i,preds[c]);
        }
 else {
          p.set0(i,preds[0]);
        }
      }
    }
  }
.doAll(adaptFrm);
  int x=_names.length - 1, y=adaptFrm.numCols();
  Frame output=adaptFrm.extractFrame(x,y);
  onlyAdaptFrm.remove();
  return output;
}
