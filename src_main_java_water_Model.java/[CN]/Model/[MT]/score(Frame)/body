{
  int ridx=fr.find(_names[_names.length - 1]);
  if (ridx != -1) {
    fr=new Frame(fr);
    fr.remove(ridx);
  }
  Frame[] adaptFrms=adapt(fr,false);
  Frame adaptFrm=adaptFrms[0];
  Frame onlyAdaptFrm=adaptFrms[1];
  Vec v=adaptFrm.anyVec().makeZero();
  v._domain=_domains[_domains.length - 1];
  adaptFrm.add("predict",v);
  if (nclasses() > 1) {
    String prefix="";
    for (int c=0; c < nclasses(); c++)     if (contains(adaptFrm._names,classNames()[c])) {
      prefix="class_";
      break;
    }
    for (int c=0; c < nclasses(); c++)     adaptFrm.add(prefix + classNames()[c],adaptFrm.anyVec().makeZero());
  }
  new MRTask2(){
    @Override public void map(    Chunk chks[]){
      double tmp[]=new double[_names.length];
      float preds[]=new float[nclasses()];
      Chunk p=chks[_names.length - 1];
      for (int i=0; i < p._len; i++) {
        float[] out=score0(chks,i,tmp,preds);
        if (nclasses() > 1) {
          if (Float.isNaN(out[0]))           p.setNA0(i);
 else           p.set0(i,Utils.maxIndex(out));
          for (int c=0; c < nclasses(); c++)           chks[_names.length + c].set0(i,out[c]);
        }
 else {
          p.set0(i,out[0]);
        }
      }
    }
  }
.doAll(adaptFrm);
  int x=_names.length - 1, y=adaptFrm.numCols();
  Frame output=adaptFrm.extractFrame(x,y);
  onlyAdaptFrm.remove();
  return output;
}
