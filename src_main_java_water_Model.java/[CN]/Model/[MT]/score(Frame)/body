{
  int ridx=fr.find(_names[_names.length - 1]);
  if (ridx != -1) {
    fr=new Frame(fr);
    fr.remove(ridx);
  }
  Frame[] adaptFrms=adapt(fr,false);
  Frame adaptFrm=adaptFrms[0];
  Frame onlyAdaptFrm=adaptFrms[1];
  Vec v=adaptFrm.anyVec().makeZero();
  v._domain=_domains[_domains.length - 1];
  adaptFrm.add("predict",v);
  if (nclasses() > 1) {
    String prefix="";
    for (int c=0; c < nclasses(); c++)     if (contains(adaptFrm._names,classNames()[c])) {
      prefix="class_";
      break;
    }
    for (int c=0; c < nclasses(); c++)     adaptFrm.add(prefix + classNames()[c],adaptFrm.anyVec().makeZero());
  }
  new MRTask2(){
    @Override public void map(    Chunk chks[]){
      double tmp[]=new double[_names.length];
      float preds[]=new float[nclasses() == 1 ? 1 : nclasses() + 1];
      int len=chks[0]._len;
      for (int row=0; row < len; row++) {
        float p[]=score0(chks,row,tmp,preds);
        for (int c=0; c < preds.length; c++)         chks[_names.length - 1 + c].set0(row,p[c]);
      }
    }
  }
.doAll(adaptFrm);
  int x=_names.length - 1, y=adaptFrm.numCols();
  Frame output=adaptFrm.extractFrame(x,y);
  onlyAdaptFrm.delete();
  return output;
}
