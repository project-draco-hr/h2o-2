{
  SB sb=new SB();
  sb.p("\n");
  sb.p("class ").p(_selfKey.toString()).p(" {\n");
  sb.p("  public static final String NAMES[] = ").p(_names).p(";\n");
  sb.p("  public static final int NCLASSES = ").p(nclasses()).p(";\n");
  toJavaInit(sb);
  sb.p("\n");
  sb.p("  // Pass in data in a double[], pre-aligned to the Model's requirements.\n");
  sb.p("  // Jam predictions into the preds[] array; preds[0] is reserved for the\n");
  sb.p("  // main prediction (class for classifiers or value for regression),\n");
  sb.p("  // and remaining columns hold a probability distribution for classifiers.\n");
  sb.p("  float[] predict( double data[], float preds[] ) {\n");
  toJavaPredict(sb);
  sb.p("\n");
  sb.p("    return preds;\n");
  sb.p("  }\n");
  sb.p("  double[] map( java.util.HashMap<String,Double> row, double data[] ) {\n");
  sb.p("    for( int i=0; i<NAMES.length-1; i++ ) {\n");
  sb.p("      Double d = row.get(NAMES[i]);\n");
  sb.p("      data[i] = d==null ? Double.NaN : d;\n");
  sb.p("    }\n");
  sb.p("    return data;\n");
  sb.p("  }\n");
  sb.p("  // Does the mapping lookup for every row, no allocation\n");
  sb.p("  float[] predict( java.util.HashMap<String,Double> row, double data[], float preds[] ) {\n");
  sb.p("    return predict(map(row,data),preds);\n");
  sb.p("  }\n");
  sb.p("  // Allocates a double[] for every row\n");
  sb.p("  float[] predict( java.util.HashMap<String,Double> row, float preds[] ) {\n");
  sb.p("    return predict(map(row,new double[NAMES.length]),preds);\n");
  sb.p("  }\n");
  sb.p("  // Allocates a double[] and a float[] for every row\n");
  sb.p("  float[] predict( java.util.HashMap<String,Double> row ) {\n");
  sb.p("    return predict(map(row,new double[NAMES.length]),new float[NCLASSES+1]);\n");
  sb.p("  }\n");
  sb.p("}\n");
  return sb.toString();
}
