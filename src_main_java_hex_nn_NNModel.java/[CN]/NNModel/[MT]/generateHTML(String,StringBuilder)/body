{
  if (_key == null) {
    DocGen.HTML.title(sb,"No model yet");
    return true;
  }
  final String mse_format="%g";
  final String cross_entropy_format="%2.6f";
  DocGen.HTML.title(sb,title);
  DocGen.HTML.paragraph(sb,"Model type: " + (model_info().parameters.classification ? " Classification" : " Regression"));
  DocGen.HTML.paragraph(sb,"Model Key: " + _key);
  DocGen.HTML.paragraph(sb,"Job Key: " + jobKey);
  Inspect2 is2=new Inspect2();
  DocGen.HTML.paragraph(sb,"Training Data Key: " + _dataKey);
  if (model_info.parameters.validation != null) {
    DocGen.HTML.paragraph(sb,"Validation Data Key: " + model_info.parameters.validation._key);
  }
  DocGen.HTML.paragraph(sb,"Number of model parameters (weights/biases): " + String.format("%,d",model_info().size()));
  model_info.job().toHTML(sb);
  sb.append("<div class='alert'>Actions: " + (Job.isRunning(jobKey) ? Cancel.link(jobKey,"Cancel job") + ", " : "") + is2.link("Inspect training data",_dataKey)+ ", "+ (model_info().parameters.validation != null ? (is2.link("Inspect validation data",model_info().parameters.validation._key) + ", ") : "")+ water.api.Predict.link(_key,"Score on dataset")+ ", "+ NN.link(_dataKey,"Compute new model")+ "</div>");
  final Errors error=errors[errors.length - 1];
  assert(error != null);
  if (errors.length > 1) {
    if (isClassifier()) {
      float[] err=new float[errors.length];
      float[] samples=new float[errors.length];
      for (int i=0; i < err.length; ++i) {
        err[i]=(float)errors[i].train_err;
        samples[i]=errors[i].training_samples;
      }
      new D3Plot(samples,err,"training samples","classification error","Classification Error on Training Set").generate(sb);
      if (model_info.parameters.validation != null) {
        for (int i=0; i < err.length; ++i) {
          err[i]=(float)errors[i].valid_err;
        }
        new D3Plot(samples,err,"training samples","classification error","Classification Error on Validation Set").generate(sb);
      }
    }
 else {
      float[] err=new float[errors.length - 1];
      float[] samples=new float[errors.length - 1];
      for (int i=0; i < err.length; ++i) {
        err[i]=(float)errors[i + 1].train_mse;
        samples[i]=errors[i + 1].training_samples;
      }
      new D3Plot(samples,err,"training samples","MSE","Regression Error on Training Set").generate(sb);
      if (model_info.parameters.validation != null) {
        for (int i=0; i < err.length; ++i) {
          err[i]=(float)errors[i + 1].valid_mse;
        }
        new D3Plot(samples,err,"training samples","MSE","Regression Error on Validation Set").generate(sb);
      }
    }
  }
  DocGen.HTML.section(sb,"Predicting: " + responseName());
  if (isClassifier()) {
    DocGen.HTML.section(sb,"Training classification error: " + formatPct(error.train_err));
    if (error.validation) {
      DocGen.HTML.section(sb,"Validation classification error: " + formatPct(error.valid_err));
    }
  }
 else {
    DocGen.HTML.section(sb,"Training mean squared error: " + String.format(mse_format,error.train_mse));
    if (error.validation) {
      DocGen.HTML.section(sb,"Validation mean squared error: " + String.format(mse_format,error.valid_mse));
    }
  }
  if (error.training_time_ms > 0)   DocGen.HTML.section(sb,"Training speed: " + error.training_samples * 1000 / error.training_time_ms + " samples/s");
  if (model_info.parameters != null && model_info.parameters.diagnostics) {
    DocGen.HTML.section(sb,"Status of Neuron Layers");
    sb.append("<table class='table table-striped table-bordered table-condensed'>");
    sb.append("<tr>");
    sb.append("<th>").append("#").append("</th>");
    sb.append("<th>").append("Units").append("</th>");
    sb.append("<th>").append("Type").append("</th>");
    sb.append("<th>").append("Dropout").append("</th>");
    sb.append("<th>").append("Rate").append("</th>");
    sb.append("<th>").append("L1").append("</th>");
    sb.append("<th>").append("L2").append("</th>");
    sb.append("<th>").append("Momentum").append("</th>");
    sb.append("<th>").append("Weight (Mean, RMS)").append("</th>");
    sb.append("<th>").append("Bias (Mean, RMS)").append("</th>");
    sb.append("</tr>");
    Neurons[] neurons=NNTask.makeNeuronsForTesting(model_info());
    for (int i=0; i < neurons.length; ++i) {
      sb.append("<tr>");
      sb.append("<td>").append("<b>").append(i + 1).append("</b>").append("</td>");
      sb.append("<td>").append("<b>").append(neurons[i].units).append("</b>").append("</td>");
      sb.append("<td>").append(neurons[i].getClass().getSimpleName()).append("</td>");
      if (i == 0) {
        sb.append("<td>");
        sb.append(formatPct(neurons[i].params.input_dropout_ratio));
        sb.append("</td>");
        sb.append("<td></td>");
        sb.append("<td></td>");
        sb.append("<td></td>");
        sb.append("<td></td>");
        sb.append("<td></td>");
        sb.append("<td></td>");
        continue;
      }
 else       if (i < neurons.length - 1) {
        sb.append("<td>");
        sb.append(neurons[i] instanceof Neurons.TanhDropout || neurons[i] instanceof Neurons.RectifierDropout || neurons[i] instanceof Neurons.MaxoutDropout ? "50%" : "0%");
        sb.append("</td>");
      }
 else {
        sb.append("<td></td>");
      }
      sb.append("<td>").append(String.format("%.5g",neurons[i].rate(error.training_samples))).append("</td>");
      sb.append("<td>").append(neurons[i].params.l1).append("</td>");
      sb.append("<td>").append(neurons[i].params.l2).append("</td>");
      final String format="%g";
      sb.append("<td>").append(String.format("%.5f",neurons[i].momentum(error.training_samples))).append("</td>");
      sb.append("<td>(").append(String.format(format,model_info.mean_weight[i])).append(", ").append(String.format(format,model_info.rms_weight[i])).append(")</td>");
      sb.append("<td>(").append(String.format(format,model_info.mean_bias[i])).append(", ").append(String.format(format,model_info.rms_bias[i])).append(")</td>");
      sb.append("</tr>");
    }
    sb.append("</table>");
  }
  if (model_info.unstable()) {
    final String msg="Job was aborted due to observed numerical instability (exponential growth)." + " Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.";
    DocGen.HTML.section(sb,"=======================================================================================");
    DocGen.HTML.section(sb,msg);
    DocGen.HTML.section(sb,"=======================================================================================");
  }
  long score_valid=error.score_validation_samples;
  long score_train=error.score_training_samples;
  final boolean fulltrain=score_train == 0 || score_train == model_info().data_info()._adaptedFrame.numRows();
  final boolean fullvalid=score_valid == 0 || score_valid == model_info().get_params().validation.numRows();
  if (isClassifier()) {
    final String cmTitle="Confusion Matrix on " + (error.validation ? "Validation Data" + (fullvalid ? "" : " (" + score_valid + " samples)") : "Training Data" + (fulltrain ? "" : " (" + score_train + " samples)"));
    DocGen.HTML.section(sb,cmTitle);
    if (error.train_confusion_matrix != null) {
      if (error.train_confusion_matrix.cm != null && error.train_confusion_matrix.cm.length < 100) {
        if (error.validation && error.valid_confusion_matrix != null && error.valid_confusion_matrix.cm != null)         error.valid_confusion_matrix.toHTML(sb);
 else         if (error.train_confusion_matrix != null)         error.train_confusion_matrix.toHTML(sb);
      }
 else {
        sb.append("<h5>Not shown here (too large).</h5>");
      }
    }
 else     sb.append("<h5>Not yet computed.</h5>");
  }
  sb.append("<h3>" + "Progress" + "</h3>");
  sb.append("<h4>" + "Epochs: " + String.format("%.3f",epoch_counter) + "</h4>");
  String training="Number of training set samples for scoring: " + (fulltrain ? "all " + model_info().data_info()._adaptedFrame.numRows() : score_train);
  if (score_train > 0) {
    if (score_train < 1000 && model_info().data_info()._adaptedFrame.numRows() >= 1000)     training+=" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)";
    if (score_train > 100000)     training+=" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)";
  }
  DocGen.HTML.section(sb,training);
  if (error.validation) {
    String validation="Number of validation set samples for scoring: " + (fullvalid ? "all " + model_info().get_params().validation.numRows() : score_valid);
    if (score_valid > 0) {
      if (score_valid < 1000 && model_info().get_params().validation.numRows() >= 1000)       validation+=" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)";
      if (score_valid > 100000)       validation+=" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)";
    }
    DocGen.HTML.section(sb,validation);
  }
  if (error.validation) {
  }
  sb.append("<table class='table table-striped table-bordered table-condensed'>");
  sb.append("<tr>");
  sb.append("<th>Training Time</th>");
  sb.append("<th>Training Epochs</th>");
  sb.append("<th>Training Samples</th>");
  if (isClassifier()) {
    sb.append("<th>Training Error</th>");
  }
 else {
    sb.append("<th>Training MSE</th>");
  }
  if (error.validation) {
    if (isClassifier()) {
      sb.append("<th>Validation Error</th>");
    }
 else {
      sb.append("<th>Validation MSE</th>");
    }
  }
  sb.append("</tr>");
  for (int i=errors.length - 1; i >= 0; i--) {
    final Errors e=errors[i];
    sb.append("<tr>");
    sb.append("<td>" + PrettyPrint.msecs(e.training_time_ms,true) + "</td>");
    sb.append("<td>" + String.format("%g",e.epoch_counter) + "</td>");
    sb.append("<td>" + String.format("%,d",e.training_samples) + "</td>");
    if (isClassifier()) {
      sb.append("<td>" + formatPct(e.train_err) + "</td>");
    }
 else {
      sb.append("<td>" + String.format(mse_format,e.train_mse) + "</td>");
    }
    if (e.validation) {
      if (isClassifier()) {
        sb.append("<td>" + formatPct(e.valid_err) + "</td>");
      }
 else {
        sb.append("<td>" + String.format(mse_format,e.valid_mse) + "</td>");
      }
    }
    sb.append("</tr>");
  }
  sb.append("</table>");
  return true;
}
