{
  epoch_counter=(float)model_info().get_processed_total() / data_info._adaptedFrame.numRows();
  run_time=(System.currentTimeMillis() - start_time);
  boolean keep_running=(epoch_counter < model_info().parameters.epochs);
  _now=System.currentTimeMillis();
  _sinceLastScore=_now - _timeLastScoreStart;
  final long samples=model_info().get_processed_total();
  Log.info("Training time: " + PrettyPrint.msecs(_now - start_time,true) + " processed "+ samples+ " samples"+ " ("+ String.format("%.3f",epoch_counter)+ " epochs)."+ " Speed: "+ String.format("%.3f",(double)samples / ((_now - start_time) / 1000.))+ " samples/sec.");
  if (!keep_running || (_now - timeStart < 30000) || (_sinceLastScore > model_info().parameters.score_interval * 1000)) {
    Log.info("Scoring the model.");
    _timeLastScoreStart=_now;
    boolean printCM=false;
    Errors err=new Errors();
    err.training_time_ms=_now - timeStart;
    err.epoch_counter=epoch_counter;
    err.validation=ftest != null;
    err.training_samples=model_info().get_processed_total();
    err.train_confusion_matrix=new ConfusionMatrix();
    err.train_err=classificationError(ftrain,"Classification error on training data:",printCM,err.train_confusion_matrix);
    if (ftest != null) {
      err.valid_confusion_matrix=new ConfusionMatrix();
      err.valid_err=classificationError(ftest,"Classification error on validation data:",printCM,err.valid_confusion_matrix);
    }
    if (errors == null) {
      errors=new Errors[]{err};
    }
 else {
      Errors[] err2=new Errors[errors.length + 1];
      System.arraycopy(errors,0,err2,0,errors.length);
      err2[err2.length - 1]=err;
      errors=err2;
    }
    for (    String s : toString().split("\n"))     Log.info(s);
    Log.info("Scoring time: " + PrettyPrint.msecs(System.currentTimeMillis() - _now,true));
  }
  if (model_info().unstable()) {
    Log.err("Canceling job since the model is unstable (exponential growth observed).");
    Log.err("Try using L1/L2/max_w2 regularization, a different activation function, or more synchronization in multi-node operation.");
    keep_running=false;
  }
  update(dest_key);
  return keep_running;
}
