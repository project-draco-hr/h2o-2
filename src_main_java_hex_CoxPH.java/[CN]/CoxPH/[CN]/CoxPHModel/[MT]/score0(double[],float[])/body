{
  final int n_time=time.length;
  final int n_coef=coef.length;
  final int n_cats=data_info._cats;
  final int n_num=data_info._nums;
  final int n_data=n_cats + n_num;
  final int numStart=data_info.numStart();
  boolean catsAllNA=true;
  boolean catsHasNA=false;
  boolean numsHasNA=false;
  for (int j=0; j < n_cats; ++j) {
    catsAllNA&=Double.isNaN(data[j]);
    catsHasNA|=Double.isNaN(data[j]);
  }
  for (int j=n_cats; j < n_data; ++j)   numsHasNA|=Double.isNaN(data[j]);
  if (numsHasNA || (catsHasNA && !catsAllNA) || (n_num == 0 && catsAllNA)) {
    for (int i=1; i <= 2 * n_time; ++i)     preds[i]=Float.NaN;
  }
 else {
    double[] full_data=MemoryManager.malloc8d(n_coef);
    for (int j=0; j < n_cats; ++j)     if (Double.isNaN(data[j])) {
      for (int k=data_info._catOffsets[j]; k < data_info._catOffsets[j + 1]; ++k)       full_data[k]=this.x_mean_cat[k];
    }
 else     if (data[j] != 0)     full_data[data_info._catOffsets[j] + (int)(data[j] - 1)]=1;
    for (int j=0; j < n_num; ++j)     full_data[numStart + j]=data[n_cats + j] - data_info._normSub[j];
    double logRisk=0;
    for (int j=0; j < n_coef; ++j)     logRisk+=full_data[j] * coef[j];
    final double risk=Math.exp(logRisk);
    for (int t=0; t < n_time; ++t)     preds[t + 1]=(float)(risk * cumhaz_0[t]);
    for (int t=0; t < n_time; ++t) {
      double var_cumhaz_2_t=0;
      for (int j=0; j < n_coef; ++j) {
        double sum=0;
        for (int k=0; k < n_coef; ++k)         sum+=var_coef[j][k] * (full_data[k] * cumhaz_0[t] - var_cumhaz_2[k][t]);
        var_cumhaz_2_t+=(full_data[j] * cumhaz_0[t] - var_cumhaz_2[j][t]) * sum;
      }
      preds[t + 1 + n_time]=(float)(risk * Math.sqrt(var_cumhaz_1[t] + var_cumhaz_2_t));
    }
  }
  preds[0]=Float.NaN;
  return preds;
}
