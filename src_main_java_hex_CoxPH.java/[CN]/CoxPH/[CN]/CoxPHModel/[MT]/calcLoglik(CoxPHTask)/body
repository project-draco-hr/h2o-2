{
  final int n_coef=coef.length;
  double newLoglik=0;
  for (int j=0; j < n_coef; ++j) {
    gradient[j]=0;
    for (int k=0; k < n_coef; ++k)     hessian[j][k]=0;
  }
switch (parameters.ties) {
case efron:
    for (int t=coxMR.sizeEvents.length - 1; t >= 0; --t) {
      final double sizeEvents_t=coxMR.sizeEvents[t];
      if (sizeEvents_t > 0) {
        final long countEvents_t=coxMR.countEvents[t];
        final double sumLogRiskEvents_t=coxMR.sumLogRiskEvents[t];
        final double sumRiskEvents_t=coxMR.sumRiskEvents[t];
        final double rcumsumRisk_t=coxMR.rcumsumRisk[t];
        final double avgSize=sizeEvents_t / countEvents_t;
        newLoglik+=sumLogRiskEvents_t;
        for (int j=0; j < n_coef; ++j)         gradient[j]+=coxMR.sumXEvents[t][j];
        for (long e=0; e < countEvents_t; ++e) {
          final double frac=((double)e) / ((double)countEvents_t);
          final double term=rcumsumRisk_t - frac * sumRiskEvents_t;
          newLoglik-=avgSize * Math.log(term);
          for (int j=0; j < n_coef; ++j) {
            final double djTerm=coxMR.rcumsumXRisk[t][j] - frac * coxMR.sumXRiskEvents[t][j];
            final double djLogTerm=djTerm / term;
            gradient[j]-=avgSize * djLogTerm;
            for (int k=0; k < n_coef; ++k) {
              final double dkTerm=coxMR.rcumsumXRisk[t][k] - frac * coxMR.sumXRiskEvents[t][k];
              final double djkTerm=coxMR.rcumsumXXRisk[t][j][k] - frac * coxMR.sumXXRiskEvents[t][j][k];
              hessian[j][k]-=avgSize * (djkTerm / term - (djLogTerm * (dkTerm / term)));
            }
          }
        }
      }
    }
  break;
case breslow:
for (int t=coxMR.sizeEvents.length - 1; t >= 0; --t) {
  final double sizeEvents_t=coxMR.sizeEvents[t];
  if (sizeEvents_t > 0) {
    final double sumLogRiskEvents_t=coxMR.sumLogRiskEvents[t];
    final double rcumsumRisk_t=coxMR.rcumsumRisk[t];
    newLoglik+=sumLogRiskEvents_t;
    newLoglik-=sizeEvents_t * Math.log(rcumsumRisk_t);
    for (int j=0; j < n_coef; ++j) {
      final double dlogTerm=coxMR.rcumsumXRisk[t][j] / rcumsumRisk_t;
      gradient[j]+=coxMR.sumXEvents[t][j];
      gradient[j]-=sizeEvents_t * dlogTerm;
      for (int k=0; k < n_coef; ++k)       hessian[j][k]-=sizeEvents_t * (((coxMR.rcumsumXXRisk[t][j][k] / rcumsumRisk_t) - (dlogTerm * (coxMR.rcumsumXRisk[t][k] / rcumsumRisk_t))));
    }
  }
}
break;
default :
throw new IllegalArgumentException("ties method must be either efron or breslow");
}
return newLoglik;
}
