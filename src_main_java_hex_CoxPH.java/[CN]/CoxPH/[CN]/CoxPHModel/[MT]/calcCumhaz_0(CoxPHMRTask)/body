{
  final int n_coef=coef.length;
  int nz=0;
switch (parameters.ties) {
case efron:
    for (int t=0; t < coxMR.countEvents.length; ++t) {
      if (coxMR.countEvents[t] > 0 || coxMR.countCensored[t] > 0) {
        cumhaz_0[nz]=0;
        var_cumhaz_1[nz]=0;
        for (int j=0; j < n_coef; ++j)         var_cumhaz_2[j][nz]=0;
        for (long e=0; e < coxMR.countEvents[t]; ++e) {
          final double frac=((double)e) / ((double)coxMR.countEvents[t]);
          final double haz=1 / (coxMR.rcumsumRisk[t] - frac * coxMR.sumRiskEvents[t]);
          final double haz_sq=haz * haz;
          cumhaz_0[nz]+=haz;
          var_cumhaz_1[nz]+=haz_sq;
          for (int j=0; j < n_coef; ++j)           var_cumhaz_2[j][nz]+=(coxMR.rcumsumXRisk[j][t] - frac * coxMR.sumXRiskEvents[j][t]) * haz_sq;
        }
        nz++;
      }
    }
  break;
case breslow:
for (int t=0; t < coxMR.countEvents.length; ++t) {
  if (coxMR.countEvents[t] > 0 || coxMR.countCensored[t] > 0) {
    cumhaz_0[nz]=coxMR.countEvents[t] / coxMR.rcumsumRisk[t];
    var_cumhaz_1[nz]=coxMR.countEvents[t] / (coxMR.rcumsumRisk[t] * coxMR.rcumsumRisk[t]);
    for (int j=0; j < n_coef; ++j)     var_cumhaz_2[j][nz]=(coxMR.rcumsumXRisk[j][t] / coxMR.rcumsumRisk[t]) * cumhaz_0[nz];
    nz++;
  }
}
break;
default :
throw new IllegalArgumentException("ties method must be either efron or breslow");
}
for (int t=1; t < cumhaz_0.length; ++t) {
cumhaz_0[t]=cumhaz_0[t - 1] + cumhaz_0[t];
var_cumhaz_1[t]=var_cumhaz_1[t - 1] + var_cumhaz_1[t];
for (int j=0; j < n_coef; ++j) var_cumhaz_2[j][t]=var_cumhaz_2[j][t - 1] + var_cumhaz_2[j][t];
}
}
