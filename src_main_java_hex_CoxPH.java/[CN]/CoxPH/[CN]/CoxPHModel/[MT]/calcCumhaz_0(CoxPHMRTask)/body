{
  int nz=0;
switch (parameters.ties) {
case efron:
    for (int t=0; t < coxMR.countEvents.length; t++) {
      if (coxMR.countEvents[t] > 0 || coxMR.countCensored[t] > 0) {
        cumhaz_0[nz]=0;
        var_cumhaz_1[nz]=0;
        var_cumhaz_2[nz]=0;
        for (long e=0; e < coxMR.countEvents[t]; e++) {
          double frac=((double)e) / ((double)coxMR.countEvents[t]);
          double haz=1 / (coxMR.rcumsumRisk[t] - frac * coxMR.sumRiskEvents[t]);
          cumhaz_0[nz]+=haz;
          var_cumhaz_1[nz]+=haz * haz;
          var_cumhaz_2[nz]+=(coxMR.rcumsumXRisk[t] - frac * coxMR.sumXRiskEvents[t]) * haz * haz;
        }
        nz++;
      }
    }
  break;
case breslow:
for (int t=0; t < coxMR.countEvents.length; t++) {
  if (coxMR.countEvents[t] > 0 || coxMR.countCensored[t] > 0) {
    cumhaz_0[nz]=coxMR.countEvents[t] / coxMR.rcumsumRisk[t];
    var_cumhaz_1[nz]=coxMR.countEvents[t] / (coxMR.rcumsumRisk[t] * coxMR.rcumsumRisk[t]);
    var_cumhaz_2[nz]=(coxMR.rcumsumXRisk[t] / coxMR.rcumsumRisk[t]) * cumhaz_0[nz];
    nz++;
  }
}
break;
default :
throw new IllegalArgumentException("ties method must be either efron or breslow");
}
for (int t=1; t < cumhaz_0.length; t++) {
cumhaz_0[t]=cumhaz_0[t - 1] + cumhaz_0[t];
var_cumhaz_1[t]=var_cumhaz_1[t - 1] + var_cumhaz_1[t];
var_cumhaz_2[t]=var_cumhaz_2[t - 1] + var_cumhaz_2[t];
}
}
