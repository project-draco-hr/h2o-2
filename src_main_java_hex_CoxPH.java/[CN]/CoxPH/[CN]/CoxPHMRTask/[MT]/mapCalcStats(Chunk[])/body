{
  final int x_ncol=_use_start_column ? cols.length - 3 : cols.length - 2;
  Chunk start=null;
  if (_use_start_column)   start=cols[cols.length - 3];
  Chunk stop=cols[cols.length - 2];
  Chunk events=cols[cols.length - 1];
  boolean[] hasNA=mapRowHasNA(cols);
  int[] time1=mapCalcTime1(start);
  int[] time2=mapCalcTime2(stop);
  double[] logRisk=mapCalcLogRisk(cols,hasNA);
  double[] risk=mapCalcRisk(logRisk,hasNA);
  final int nrow=cols[0]._len;
  for (int i=0; i < nrow; i++) {
    if (hasNA[i])     n_missing++;
 else {
      n++;
      int t2=time2[i];
      double risk_i=risk[i];
      if (events.at80(i) > 0) {
        countEvents[t2]++;
        sumLogRiskEvents[t2]+=logRisk[i];
        sumRiskEvents[t2]+=risk_i;
      }
 else       countCensored[t2]++;
      if (_use_start_column) {
        int t1=time1[i];
        for (int t=t1; t <= t2; t++) {
          countRiskSet[t]++;
          rcumsumRisk[t]+=risk_i;
        }
      }
 else {
        countRiskSet[t2]++;
        rcumsumRisk[t2]+=risk_i;
      }
    }
  }
  for (int j=0; j < x_ncol; j++) {
    for (int i=0; i < nrow; i++) {
      if (!hasNA[i]) {
        int t1=-1;
        if (_use_start_column)         t1=time1[i];
        int t2=time2[i];
        long event_i=events.at80(i);
        double x1_i=cols[j].at0(i) - _x_mean[j];
        double risk_i=risk[i];
        double xRisk_i=x1_i * risk_i;
        if (event_i > 0) {
          sumXEvents[j][t2]+=x1_i;
          sumXRiskEvents[j][t2]+=xRisk_i;
        }
        if (_use_start_column) {
          for (int t=t1; t <= t2; t++)           rcumsumXRisk[j][t]+=xRisk_i;
        }
 else {
          rcumsumXRisk[j][t2]+=xRisk_i;
        }
        for (int k=0; k < x_ncol; k++) {
          double x2_i=cols[k].at0(i) - _x_mean[k];
          double xxRisk_i=x2_i * xRisk_i;
          if (event_i > 0)           sumXXRiskEvents[j][k][t2]+=xxRisk_i;
          if (_use_start_column) {
            for (int t=t1; t <= t2; t++)             rcumsumXXRisk[j][k][t]+=xxRisk_i;
          }
 else {
            rcumsumXXRisk[j][k][t2]+=xxRisk_i;
          }
        }
      }
    }
  }
}
