{
  final int n_coef=use_start_column ? source.numCols() - 3 : source.numCols() - 2;
  final double[] step=MemoryManager.malloc8d(n_coef);
  final double[] oldCoef=MemoryManager.malloc8d(n_coef);
  final double[] newCoef=MemoryManager.malloc8d(n_coef);
  for (int j=0; j < n_coef; ++j)   step[j]=Double.NaN;
  for (int j=0; j < n_coef; ++j)   oldCoef[j]=Double.NaN;
  for (int j=0; j < n_coef; ++j)   newCoef[j]=init;
  double oldLoglik=-Double.MAX_VALUE;
  final int n_time=(int)(model.max_time - model.min_time + 1);
  for (int i=0; i <= iter_max; ++i) {
    model.iter=i;
    CoxPHMRTask coxMR=new CoxPHMRTask(newCoef,model.min_time,n_time,use_start_column,model.x_mean).doAll(source.vecs());
    coxMR.finish();
    if (i == 0)     model.calcCounts(coxMR);
    final double newLoglik=model.calcLoglik(coxMR);
    if (newLoglik > oldLoglik) {
      model.calcModelStats(newCoef,newLoglik);
      model.calcCumhaz_0(coxMR);
      if (newLoglik == 0)       model.lre=-Math.log10(Math.abs(oldLoglik - newLoglik));
 else       model.lre=-Math.log10(Math.abs((oldLoglik - newLoglik) / newLoglik));
      if (model.lre >= lre_min)       break;
      for (int j=0; j < n_coef; ++j)       step[j]=0;
      for (int j=0; j < n_coef; ++j)       for (int k=0; k < n_coef; ++k)       step[j]-=model.var_coef[j][k] * model.gradient[k];
      for (int j=0; j < n_coef; ++j)       if (Double.isNaN(step[j]) || Double.isInfinite(step[j]))       break;
      oldLoglik=newLoglik;
      for (int j=0; j < n_coef; ++j)       oldCoef[j]=newCoef[j];
    }
 else {
      for (int j=0; j < n_coef; ++j)       step[j]/=2;
    }
    for (int j=0; j < n_coef; ++j)     newCoef[j]=oldCoef[j] - step[j];
  }
  final Futures fs=new Futures();
  DKV.put(dest(),model,fs);
  fs.blockForPending();
}
