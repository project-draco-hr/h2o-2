{
  if (use_start_column && !start_column.isInt())   throw new IllegalArgumentException("start time must be null or of type integer");
  if (!stop_column.isInt())   throw new IllegalArgumentException("stop time must be of type integer");
  if (!event_column.isInt() && !event_column.isEnum())   throw new IllegalArgumentException("event must be of type integer or factor");
  if (Double.isNaN(lre_min) || lre_min <= 0)   throw new IllegalArgumentException("lre_min must be a positive number");
  if (iter_max < 1)   throw new IllegalArgumentException("iter_max must be a positive integer");
  String[] names;
  if (use_start_column) {
    names=new String[4];
    int i=0;
    for (int j=0; j < source.numCols(); j++) {
      Vec vec=source.vec(j);
      if (vec == start_column || vec == stop_column || vec == event_column || vec == x_column) {
        names[i]=source.names()[j];
        i++;
      }
    }
  }
 else {
    names=new String[3];
    int i=0;
    for (int j=0; j < source.numCols(); j++) {
      Vec vec=source.vec(j);
      if (vec == stop_column || vec == event_column || vec == x_column) {
        names[i]=source.names()[j];
        i++;
      }
    }
  }
  Frame cols=source.subframe(names);
  output=new CoxPHModel(this,dest(),cols._key,cols,null);
  H2O.H2OCountedCompleter task=new H2O.H2OCountedCompleter(){
    @Override public void compute2(){
      Vec[] cols;
      if (use_start_column) {
        cols=new Vec[4];
        cols[0]=start_column;
        cols[1]=stop_column;
        cols[2]=event_column;
        cols[3]=x_column;
      }
 else {
        cols=new Vec[3];
        cols[0]=stop_column;
        cols[1]=event_column;
        cols[2]=x_column;
      }
      if (use_start_column)       output.min_time=(long)start_column.min() + 1;
 else       output.min_time=(long)stop_column.min();
      output.max_time=(long)stop_column.max();
      int n_time=(int)(output.max_time - output.min_time + 1);
      output.x_mean=x_column.mean();
      output.cumhaz=MemoryManager.malloc8d(n_time);
      output.se_cumhaz=MemoryManager.malloc8d(n_time);
      output.surv=MemoryManager.malloc8d(n_time);
      double[] se_term=MemoryManager.malloc8d(n_time);
      int i, t;
      double step=Double.NaN;
      double oldCoef=Double.NaN;
      double oldLoglik=-Double.MAX_VALUE;
      double newCoef=init;
      double newLoglik;
      for (i=0; i <= iter_max; i++) {
        output.iter=i;
        CoxPHFitTask coxFit=new CoxPHFitTask(newCoef,output.min_time,n_time,use_start_column,output.x_mean).doAll(cols);
        if (!use_start_column) {
          for (t=n_time - 2; t >= 0; t--) {
            coxFit.rcumsumRisk[t]+=coxFit.rcumsumRisk[t + 1];
            coxFit.rcumsumXRisk[t]+=coxFit.rcumsumXRisk[t + 1];
            coxFit.rcumsumXXRisk[t]+=coxFit.rcumsumXXRisk[t + 1];
          }
        }
        if (i == 0) {
          output.n=coxFit.n;
          for (t=0; t < n_time; t++)           output.total_event+=coxFit.countEvents[t];
          output.n_risk=coxFit.countRiskSet.clone();
          output.n_event=coxFit.countEvents.clone();
          output.n_censor=coxFit.countCensored.clone();
          if (!use_start_column)           for (t=n_time - 2; t >= 0; t--)           output.n_risk[t]+=output.n_risk[t + 1];
        }
        newLoglik=0;
        output.gradient=0;
        output.hessian=0;
switch (ties) {
case efron:
          for (t=n_time - 1; t >= 0; t--) {
            if (coxFit.countEvents[t] > 0) {
              newLoglik+=coxFit.sumLogRiskEvents[t];
              output.gradient+=coxFit.sumXEvents[t];
              for (long e=0; e < coxFit.countEvents[t]; e++) {
                double frac=((double)e) / ((double)coxFit.countEvents[t]);
                double term=coxFit.rcumsumRisk[t] - frac * coxFit.sumRiskEvents[t];
                double dterm=coxFit.rcumsumXRisk[t] - frac * coxFit.sumXRiskEvents[t];
                double d2term=coxFit.rcumsumXXRisk[t] - frac * coxFit.sumXXRiskEvents[t];
                double dlogTerm=dterm / term;
                newLoglik-=Math.log(term);
                output.gradient-=dlogTerm;
                output.hessian-=d2term / term - (dlogTerm * (dterm / term));
              }
            }
          }
        break;
case breslow:
      for (t=n_time - 1; t >= 0; t--) {
        if (coxFit.countEvents[t] > 0) {
          newLoglik+=coxFit.sumLogRiskEvents[t];
          output.gradient+=coxFit.sumXEvents[t];
          double dlogTerm=coxFit.rcumsumXRisk[t] / coxFit.rcumsumRisk[t];
          newLoglik-=coxFit.countEvents[t] * Math.log(coxFit.rcumsumRisk[t]);
          output.gradient-=coxFit.countEvents[t] * dlogTerm;
          output.hessian-=coxFit.countEvents[t] * (((coxFit.rcumsumXXRisk[t] / coxFit.rcumsumRisk[t]) - (dlogTerm * (coxFit.rcumsumXRisk[t] / coxFit.rcumsumRisk[t]))));
        }
      }
    break;
default :
  throw new IllegalArgumentException("ties method must be either efron or breslow");
}
if (newLoglik > oldLoglik) {
if (i == 0) {
  output.null_loglik=newLoglik;
  output.maxrsq=1 - Math.exp(2 * output.null_loglik / output.n);
  output.score_test=-output.gradient * output.gradient / output.hessian;
}
output.coef=newCoef;
output.exp_coef=Math.exp(output.coef);
output.exp_neg_coef=Math.exp(-output.coef);
output.var_coef=-1 / output.hessian;
output.se_coef=Math.sqrt(output.var_coef);
output.z_coef=output.coef / output.se_coef;
output.loglik=newLoglik;
output.loglik_test=-2 * (output.null_loglik - output.loglik);
double diff_init=output.coef - init;
output.wald_test=(diff_init * diff_init) / output.var_coef;
output.rsq=1 - Math.exp(-output.loglik_test / output.n);
switch (ties) {
case efron:
  for (t=0; t < n_time; t++) {
    output.cumhaz[t]=0;
    output.se_cumhaz[t]=0;
    se_term[t]=0;
    for (long e=0; e < coxFit.countEvents[t]; e++) {
      double frac=((double)e) / ((double)coxFit.countEvents[t]);
      double haz=1 / (coxFit.rcumsumRisk[t] - frac * coxFit.sumRiskEvents[t]);
      output.cumhaz[t]+=haz;
      output.se_cumhaz[t]+=haz * haz;
      se_term[t]+=(coxFit.rcumsumXRisk[t] - frac * coxFit.sumXRiskEvents[t]) * haz * haz;
    }
  }
break;
case breslow:
for (t=0; t < n_time; t++) {
output.cumhaz[t]=coxFit.countEvents[t] / coxFit.rcumsumRisk[t];
output.se_cumhaz[t]=coxFit.countEvents[t] / (coxFit.rcumsumRisk[t] * coxFit.rcumsumRisk[t]);
se_term[t]=(coxFit.rcumsumXRisk[t] / coxFit.rcumsumRisk[t]) * output.cumhaz[t];
}
break;
default :
throw new IllegalArgumentException("ties method must be either efron or breslow");
}
for (t=1; t < n_time; t++) {
output.cumhaz[t]=output.cumhaz[t - 1] + output.cumhaz[t];
output.se_cumhaz[t]=output.se_cumhaz[t - 1] + output.se_cumhaz[t];
se_term[t]=se_term[t - 1] + se_term[t];
}
for (t=0; t < n_time; t++) {
output.se_cumhaz[t]=Math.sqrt(output.se_cumhaz[t] + (se_term[t] * output.var_coef * se_term[t]));
output.surv[t]=Math.exp(-output.cumhaz[t]);
}
if (newLoglik == 0) output.lre=-Math.log10(Math.abs(oldLoglik - newLoglik));
 else output.lre=-Math.log10(Math.abs((oldLoglik - newLoglik) / newLoglik));
if (output.lre >= lre_min) break;
step=output.gradient / output.hessian;
if (Double.isNaN(step) || Double.isInfinite(step)) break;
oldCoef=newCoef;
oldLoglik=newLoglik;
}
 else step/=2;
newCoef=oldCoef - step;
}
tryComplete();
}
@Override public void onCompletion(CountedCompleter cc){
Futures fs=new Futures();
DKV.put(dest(),output,fs);
fs.blockForPending();
remove();
}
}
;
start(task);
H2O.submitTask(task);
return CoxPHProgressPage.redirect(this,self(),dest());
}
