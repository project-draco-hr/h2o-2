def test_parse_bounds_libsvm(self):
    print 'Random 0/1 for col1. Last has max col = 1, All have zeros for class.'
    h2b.browseTheCloud()
    SYNDATASETS_DIR = h2o.make_syn_dir()
    tryList = [(100, 100, 'cA', 300), (100000, 100, 'cB', 300), (100, 100000, 'cC', 300)]
    for (rowCount, colCount, key2, timeoutSecs) in tryList:
        SEEDPERFILE = random.randint(0, sys.maxint)
        csvFilename = ('syn_%s_%s_%s.csv' % (SEEDPERFILE, rowCount, colCount))
        csvPathname = ((SYNDATASETS_DIR + '/') + csvFilename)
        print 'Creating random', csvPathname
        (colNumberMax, synColSumDict) = write_syn_dataset(csvPathname, rowCount, colCount, SEEDPERFILE)
        parseKey = h2o_cmd.parseFile(None, csvPathname, key2=key2, timeoutSecs=timeoutSecs, doSummary=False)
        print "Parse result['destination_key']:", parseKey['destination_key']
        inspect = h2o_cmd.runInspect(None, parseKey['destination_key'], timeoutSecs=timeoutSecs)
        num_cols = inspect['num_cols']
        num_rows = inspect['num_rows']
        summaryResult = h2o_cmd.runSummary(key=key2, timeoutSecs=timeoutSecs)
        h2o_cmd.infoFromSummary(summaryResult, noPrint=True)
        self.assertEqual((colNumberMax + 1), num_cols, msg=('generated %s cols (including output).  parsed to %s cols' % ((colNumberMax + 1), num_cols)))
        self.assertEqual(rowCount, num_rows, msg=('generated %s rows, parsed to %s rows' % (rowCount, num_rows)))
        summary = summaryResult['summary']
        columnsList = summary['columns']
        self.assertEqual((colNumberMax + 1), len(columnsList), msg=('generated %s cols (including output).  summary has %s columns' % ((colNumberMax + 1), len(columnsList))))
        for columns in columnsList:
            N = columns['N']
            name = columns['name']
            stype = columns['type']
            histogram = columns['histogram']
            bin_size = histogram['bin_size']
            bin_names = histogram['bin_names']
            bins = histogram['bins']
            nbins = histogram['bins']
            zeros = columns['zeros']
            na = columns['na']
            smax = columns['max']
            smin = columns['min']
            mean = columns['mean']
            sigma = columns['sigma']
            if (name == ('V' + str(colNumberMax))):
                synZeros = (num_rows - 1)
                synSigma = None
                synMean = (1.0 / num_rows)
                synMin = [0.0, 1.0]
                synMax = [1.0, 0.0]
            elif (name == 'V1'):
                synSum = synColSumDict[1]
                synZeros = (num_rows - synSum)
                synSigma = 0.5
                synMean = ((synSum + 0.0) / num_rows)
                synMin = [0.0, 1.0]
                synMax = [1.0, 0.0]
            else:
                synZeros = num_rows
                synSigma = 0.0
                synMean = 0.0
                synMin = [0.0]
                synMax = [0.0]
            self.assertAlmostEqual(float(mean), synMean, places=6, msg=('col %s mean %s is not equal to generated mean %s' % (name, mean, 0)))
            self.assertEqual(smin, synMin, msg=('col %s min %s is not equal to generated min %s' % (name, smin, synMin)))
            if ((name == 'V65536') or (name == 'V65537')):
                print 'columns around possible zeros mismatch:', h2o.dump_json(columns)
            self.assertEqual(zeros, synZeros, msg=('col %s zeros %s is not equal to generated zeros count %s' % (name, zeros, synZeros)))
            if synSigma:
                self.assertAlmostEqual(float(sigma), synSigma, places=2, msg=('col %s sigma %s is not equal to generated sigma %s' % (name, sigma, synSigma)))
            if CHECK_MAX:
                self.assertEqual(smax, synMax, msg=('col %s max %s is not equal to generated max %s' % (name, smax, synMax)))
            self.assertEqual(0, na, msg=('col %s num_missing_values %d should be 0' % (name, na)))
