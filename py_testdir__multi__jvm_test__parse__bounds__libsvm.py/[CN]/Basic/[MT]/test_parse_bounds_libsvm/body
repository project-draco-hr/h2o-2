def test_parse_bounds_libsvm(self):
    print 'Random 0/1 for col1. Last has max col = 1, All have zeros for class.'
    SYNDATASETS_DIR = h2o.make_syn_dir()
    tryList = [(100, 100, 'cA', 300), (100000, 100, 'cB', 300), (100, 100000, 'cC', 300)]
    for (rowCount, colCount, key2, timeoutSecs) in tryList:
        SEEDPERFILE = random.randint(0, sys.maxint)
        csvFilename = ('syn_%s_%s_%s.csv' % (SEEDPERFILE, rowCount, colCount))
        csvPathname = ((SYNDATASETS_DIR + '/') + csvFilename)
        print 'Creating random', csvPathname
        (colNumberMax, synColSumDict) = write_syn_dataset(csvPathname, rowCount, colCount, SEEDPERFILE)
        parseKey = h2o_cmd.parseFile(None, csvPathname, key2=key2, timeoutSecs=timeoutSecs, doSummary=False)
        print "Parse result['destination_key']:", parseKey['destination_key']
        inspect = h2o_cmd.runInspect(None, parseKey['destination_key'], timeoutSecs=timeoutSecs)
        num_cols = inspect['num_cols']
        num_rows = inspect['num_rows']
        row_size = inspect['row_size']
        value_size_bytes = inspect['value_size_bytes']
        print ('\n' + csvPathname), '    num_rows:', '{:,}'.format(num_rows), '    num_cols:', '{:,}'.format(num_cols), '    value_size_bytes:', '{:,}'.format(value_size_bytes), '    row_size:', '{:,}'.format(row_size)
        expectedRowSize = (num_cols * 1)
        expectedValueSize = (expectedRowSize * num_rows)
        self.assertEqual(row_size, expectedRowSize, msg=('row_size %s is not expected num_cols * 1 byte: %s' % (row_size, expectedRowSize)))
        self.assertEqual(value_size_bytes, expectedValueSize, msg=('value_size_bytes %s is not expected row_size * rows: %s' % (value_size_bytes, expectedValueSize)))
        col_limit = int(floor((0.3 * colNumberMax)))
        summaryResult = h2o_cmd.runSummary(key=key2, max_column_display=col_limit, timeoutSecs=timeoutSecs)
        h2o_cmd.infoFromSummary(summaryResult, noPrint=True)
        self.assertEqual(col_limit, len(summaryResult['summary']['columns']), ('summary respects column limit of %d on %d cols' % (col_limit, (colNumberMax + 1))))
        summaryResult = h2o_cmd.runSummary(key=key2, max_column_display=(10 * num_cols), timeoutSecs=timeoutSecs)
        h2o_cmd.infoFromSummary(summaryResult, noPrint=True)
        self.assertEqual((colNumberMax + 1), num_cols, msg=('generated %s cols (including output).  parsed to %s cols' % ((colNumberMax + 1), num_cols)))
        self.assertEqual(rowCount, num_rows, msg=('generated %s rows, parsed to %s rows' % (rowCount, num_rows)))
        summary = summaryResult['summary']
        columnsList = summary['columns']
        self.assertEqual((colNumberMax + 1), len(columnsList), msg=('generated %s cols (including output).  summary has %s columns' % ((colNumberMax + 1), len(columnsList))))
        for columns in columnsList:
            N = columns['N']
            name = columns['name']
            stype = columns['type']
            histogram = columns['histogram']
            bin_size = histogram['bin_size']
            bin_names = histogram['bin_names']
            bins = histogram['bins']
            nbins = histogram['bins']
            zeros = columns['zeros']
            na = columns['na']
            smax = columns['max']
            smin = columns['min']
            mean = columns['mean']
            sigma = columns['sigma']
            if (name == ('V' + str(colNumberMax))):
                synZeros = (num_rows - 1)
                synSigma = None
                synMean = (1.0 / num_rows)
                synMin = [0.0, 1.0]
                synMax = [1.0, 0.0]
            elif (name == 'V1'):
                synSum = synColSumDict[1]
                synZeros = (num_rows - synSum)
                synSigma = 0.5
                synMean = ((synSum + 0.0) / num_rows)
                synMin = [0.0, 1.0]
                synMax = [1.0, 0.0]
            else:
                synZeros = num_rows
                synSigma = 0.0
                synMean = 0.0
                synMin = [0.0]
                synMax = [0.0]
            self.assertAlmostEqual(float(mean), synMean, places=6, msg=('col %s mean %s is not equal to generated mean %s' % (name, mean, 0)))
            self.assertTrue((smin >= synMin), msg=('col %s min %s is not >= generated min %s' % (name, smin, synMin)))
            self.assertTrue((smax <= synMax), msg=('col %s max %s is not <= generated max %s' % (name, smax, synMax)))
            if ((name == 'V65536') or (name == 'V65537')):
                print 'columns around possible zeros mismatch:', h2o.dump_json(columns)
            self.assertEqual(zeros, synZeros, msg=('col %s zeros %s is not equal to generated zeros count %s' % (name, zeros, synZeros)))
            self.assertEqual(stype, 'number', msg=('col %s type %s is not equal to %s' % (name, stype, 'number')))
            if synSigma:
                self.assertAlmostEqual(float(sigma), synSigma, delta=0.03, msg=('col %s sigma %s is not equal to generated sigma %s' % (name, sigma, synSigma)))
            self.assertEqual(0, na, msg=('col %s num_missing_values %d should be 0' % (name, na)))
