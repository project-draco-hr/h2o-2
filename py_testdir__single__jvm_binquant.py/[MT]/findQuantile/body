def findQuantile(d, dmin, dmax, threshold):
    maxIterations = 30
    totalRows = len(d)
    desiredBinCnt = BIN_COUNT
    maxBinCnt = (desiredBinCnt + 1)
    newValStart = dmin
    newValEnd = dmax
    newValRange = (newValEnd - newValStart)
    desiredBinCnt = BIN_COUNT
    newValBinSize = (newValRange / (desiredBinCnt + 0.0))
    newLowCount = 0
    assert (maxBinCnt > 0)
    hcnt2 = [None for b in range(maxBinCnt)]
    hcnt2_min = [None for b in range(maxBinCnt)]
    hcnt2_max = [None for b in range(maxBinCnt)]
    hcnt2_low = 0
    hcnt2_high = 0
    assert (newValBinSize != 0)
    assert (newValEnd > newValStart)
    assert (newValRange > 0)
    iteration = 0
    done = False
    best_result = []

    def htot2():
        return ((sum(hcnt2) + hcnt2_low) + hcnt2_high)
    while ((iteration <= maxIterations) and (not done)):
        h2p.green_print('newValStart', newValStart)
        h2p.green_print('newValEnd', newValEnd)
        h2p.green_print('newValRange', newValRange)
        h2p.green_print('newValBinSize', newValBinSize)
        h2p.green_print('newLowCount', newLowCount)
        h2p.green_print('threshold', threshold)
        valStart = newValStart
        valEnd = newValEnd
        valRange = newValRange
        valBinSize = newValBinSize
        lowCount = newLowCount
        desiredBinCnt = BIN_COUNT
        maxBinCnt = (desiredBinCnt + 1)
        NUDGE = 0
        for b in range(maxBinCnt):
            hcnt2[b] = 0.0
        hcnt2_low = 0
        hcnt2_high = 0
        hcnt2_high_min = None
        for val in d:
            valOffset = (val - valStart)
            if (valOffset < 0):
                hcnt2_low += 1
            elif (val > valEnd):
                if ((hcnt2_high == 0) or (val < hcnt2_high_min)):
                    hcnt2_high_min = val
                hcnt2_high += 1
            else:
                binIdx2 = int((math.floor(((valOffset * 1000000.0) / valBinSize)) / 1000000.0))
                assert ((binIdx2 >= 0) and (binIdx2 <= maxBinCnt)), ('val %s %s %s %s binIdx2: %s maxBinCnt: %s valBinSize: %s' % (val, valStart, valEnd, valOffset, binIdx2, maxBinCnt, valBinSize))
                if ((hcnt2[binIdx2] == 0) or (val < hcnt2_min[binIdx2])):
                    hcnt2_min[binIdx2] = val
                if ((hcnt2[binIdx2] == 0) or (val > hcnt2_max[binIdx2])):
                    hcnt2_max[binIdx2] = val
                hcnt2[binIdx2] += 1
        totalBinnedRows = htot2()
        print ('totalRows check: %s htot2(): %s should be equal. hcnt2_low: %s hcnt2_high: %s' % (totalRows, totalBinnedRows, hcnt2_low, hcnt2_high))
        assert (totalRows == totalBinnedRows), ('totalRows: %s htot2() %s not equal. hcnt2_low: %s hcnt2_high: %s' % (totalRows, totalBinnedRows, hcnt2_low, hcnt2_high))
        currentCnt = hcnt2_low
        targetCntFull = (threshold * (totalRows - 1))
        targetCntInt = int(math.floor((threshold * (totalRows - 1))))
        targetCntFract = (targetCntFull - targetCntInt)
        assert ((targetCntFract >= 0) and (targetCntFract <= 1))
        print 'targetCntInt:', targetCntInt, 'targetCntFract', targetCntFract
        k = 0
        while ((currentCnt + hcnt2[k]) <= targetCntInt):
            currentCnt += hcnt2[k]
            k += 1
            assert (k <= maxBinCnt), ('k too large, k: %s maxBinCnt %s' % (k, maxBinCnt))
        print 'Found k (multi): ', k, ' ', currentCnt, ' ', targetCntInt, ' ', totalRows, ' ', hcnt2[k], ' ', hcnt2_min[k], ' ', hcnt2_max[k]
        assert ((hcnt2[k] != 1) or (hcnt2_min[k] == hcnt2_max[k]))
        done = False
        guess = ((hcnt2_max[k] - hcnt2_min[k]) / 2)
        if (currentCnt == targetCntInt):
            if (hcnt2[k] > 2):
                guess = hcnt2_min[k]
                done = True
                print 'Guess A', guess
            if (hcnt2[k] == 2):
                guess = ((hcnt2_max[k] + hcnt2_min[k]) / 2.0)
                done = True
                print 'Guess B', guess
            if ((hcnt2[k] == 1) and (targetCntFract == 0)):
                assert (hcnt2_min[k] == hcnt2_max[k])
                guess = hcnt2_min[k]
                done = True
                print 'k', k
                print 'Guess C', guess
            if ((hcnt2[k] == 1) and (targetCntFract != 0)):
                assert (hcnt2_min[k] == hcnt2_max[k])
                print '\nSingle value in this bin, but fractional means we need to interpolate to next non-zero'
                if (k < maxBinCnt):
                    nextK = (k + 1)
                else:
                    nextK = k
                while ((nextK < maxBinCnt) and (hcnt2[nextK] == 0)):
                    nextK += 1
                if (nextK >= maxBinCnt):
                    assert (hcnt2_high != 0)
                    print 'Using hcnt2_high_min for interpolate:', hcnt2_high_min
                    nextVal = hcnt2_high_min
                else:
                    print 'Using nextK for interpolate:', nextK
                    assert (hcnt2[nextK] != 0)
                    nextVal = hcnt2_min[nextK]
                guess = ((hcnt2_max[k] + nextVal) / 2.0)
                done = True
                print 'k', 'hcnt2_max[k]', 'nextVal'
                print 'hello3:', k, hcnt2_max[k], nextVal
                print ('\nInterpolating result using nextK: %s nextVal: %s' % (nextK, nextVal))
                print 'Guess D', guess
        if (not done):
            newValStart = (hcnt2_min[k] - NUDGE)
            newValEnd = (hcnt2_max[k] + NUDGE)
            newValRange = (newValEnd - newValStart)
            newValBinSize = (newValRange / (desiredBinCnt + 0.0))
            newLowCount = currentCnt
            if (newValBinSize == 0):
                print 'Assuming done because newValBinSize is 0.'
                print ('newValRange: %s, hcnt2[k]: %s hcnt2_min[k]: %s hcnt2_max[k]: %s' % (newValRange, hcnt2[k], hcnt2_min[k], hcnt2_max[k]))
                guess = newValStart
                print 'Guess E', guess
                done = True
        best_result.append(guess)
        iteration += 1
        h2p.blue_print('Ending Pass', iteration)
        h2p.blue_print('best_result:', best_result, 'done:', done, 'hcnt2[k]', hcnt2[k])
        print 'currentCnt', currentCnt, 'targetCntInt', targetCntInt, 'hcnt2_low', hcnt2_low, 'hcnt2_high', hcnt2_high
        print 'was', valStart, valEnd, valRange, valBinSize
        print 'next', newValStart, newValEnd, newValRange, newValBinSize
    return best_result[(-1)]
