{
  Vec va=null, vp;
  if (vactual == null || vpredict == null)   throw new IllegalArgumentException("Missing actual or predict!");
  if (vactual.length() != vpredict.length())   throw new IllegalArgumentException("Both arguments must have the same length!");
  if (!vactual.isInt())   throw new IllegalArgumentException("Actual column must be integer class labels!");
  if (vpredict.isInt())   throw new IllegalArgumentException("Predicted column must be a floating point probability!");
  try {
    va=vactual.toEnum();
    actual_domain=va._domain;
    vp=vpredict;
    if (!va.group().equals(vp.group())) {
      vp=va.align(vp);
    }
    if (thresholds != null) {
      if (_cms == null)       sort(thresholds);
      if (Utils.minValue(thresholds) < 0)       throw new InvalidArgumentException("Minimum threshold cannot be negative.");
      if (Utils.maxValue(thresholds) > 1)       throw new InvalidArgumentException("Maximum threshold cannot be greater than 1.");
    }
 else {
      HashSet hs=new HashSet();
      final int bins=(int)Math.min(vpredict.length(),200l);
      final long stride=Math.max(vpredict.length() / bins,1);
      for (int i=0; i < bins; ++i)       hs.add(new Float(vpredict.at(i * stride)));
      for (int i=0; i < 51; ++i)       hs.add(new Float(i / 50.));
      thresholds=new float[hs.size()];
      int i=0;
      for (      Object h : hs) {
        thresholds[i++]=(Float)h;
      }
      sort(thresholds);
    }
    if (_cms != null) {
      if (_cms.length != thresholds.length)       throw new InvalidArgumentException("Number of thresholds differs from number of confusion matrices.");
    }
 else {
      AUCTask at=new AUCTask(thresholds).doAll(va,vp);
      _cms=at.getCMs();
    }
    computeAUC();
    findBestThresholds();
    computeMetrics();
    return Response.done(this);
  }
 catch (  Throwable t) {
    return Response.error(t);
  }
 finally {
    if (va != null)     UKV.remove(va._key);
  }
}
