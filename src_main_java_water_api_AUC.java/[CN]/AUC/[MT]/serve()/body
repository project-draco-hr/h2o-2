{
  Vec va=null, vp=null;
  if (vactual == null || vpredict == null)   throw new IllegalArgumentException("Missing actual or predict!");
  if (vactual.length() != vpredict.length())   throw new IllegalArgumentException("Both arguments must have the same length!");
  if (!vactual.isInt())   throw new IllegalArgumentException("Actual column must be integer class labels!");
  if (vpredict.isInt())   throw new IllegalArgumentException("Predicted column must be a floating point probability!");
  try {
    va=vactual.toEnum();
    actual_domain=va._domain;
    vp=vpredict;
    if (!va.group().equals(vp.group())) {
      vp=va.align(vp);
    }
    final int bins=100;
    _cms=new hex.ConfusionMatrix[bins];
    _thresh=new double[bins];
    _tprs=new double[bins];
    _fprs=new double[bins];
    for (int i=0; i < bins; ++i) {
      _cms[i]=new hex.ConfusionMatrix(2);
      _thresh[i]=(0.5f + i) / bins;
    }
    AUCTask at=new AUCTask(_cms,_thresh,_tprs,_fprs).doAll(va,vp);
    auc=at.getAUC();
    best_threshold=at.getBestThreshold();
    return Response.done(this);
  }
 catch (  Throwable t) {
    return Response.error(t);
  }
 finally {
    if (va != null)     UKV.remove(va._key);
  }
}
