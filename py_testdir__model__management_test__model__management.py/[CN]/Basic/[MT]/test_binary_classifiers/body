def test_binary_classifiers(self):
    self.assertIsNotNone(Basic.prostate_hex)
    self.assertIsNotNone(Basic.airlines_train_hex)
    self.assertIsNotNone(Basic.airlines_test_hex)
    node = h2o.nodes[0]
    timeoutSecs = 200
    retryDelaySecs = 2
    print '##############################################################'
    print 'Generating AirlinesTrain GLM2 binary classification model. . .'
    glm_AirlinesTrain_1_params = {'destination_key': 'glm_AirlinesTrain_binary_1', 'response': 'IsDepDelayed', 'ignored_cols': 'IsDepDelayed_REC', 'family': 'binomial', 'alpha': 0.5, 'standardize': 0, 'lambda': 0.01, 'n_folds': 0, }
    glm_AirlinesTrain_1 = node.GLM(Basic.airlines_train_hex, timeoutSecs, retryDelaySecs, **glm_AirlinesTrain_1_params)
    h2o_glm.simpleCheckGLM(self, glm_AirlinesTrain_1, None, **glm_AirlinesTrain_1_params)
    print '####################################################################'
    print 'Generating AirlinesTrain simple GBM binary classification model. . .'
    gbm_AirlinesTrain_1_params = {'destination_key': 'gbm_AirlinesTrain_binary_1', 'response': 'IsDepDelayed', 'ignored_cols_by_name': 'IsDepDelayed_REC', 'ntrees': 3, 'max_depth': 1, 'classification': 1, }
    gbm_AirlinesTrain_1 = node.gbm(Basic.airlines_train_hex, timeoutSecs, retryDelaySecs, **gbm_AirlinesTrain_1_params)
    print '#####################################################################'
    print 'Generating AirlinesTrain complex GBM binary classification model. . .'
    gbm_AirlinesTrain_2_params = {'destination_key': 'gbm_AirlinesTrain_binary_2', 'response': 'IsDepDelayed', 'ignored_cols_by_name': 'IsDepDelayed_REC', 'ntrees': 50, 'max_depth': 5, 'classification': 1, }
    gbm_AirlinesTrain_2 = node.gbm(Basic.airlines_train_hex, timeoutSecs, retryDelaySecs, **gbm_AirlinesTrain_2_params)
    print '####################################################################'
    print 'Generating AirlinesTrain simple DRF binary classification model. . .'
    rf_AirlinesTrain_1_params = {'destination_key': 'rf_AirlinesTrain_binary_1', 'response': 'IsDepDelayed', 'ignored_cols_by_name': 'IsDepDelayed_REC', 'ntrees': 5, 'max_depth': 2, 'classification': 1, }
    rf_AirlinesTrain_1 = node.random_forest(Basic.airlines_train_hex, timeoutSecs, retryDelaySecs, **rf_AirlinesTrain_1_params)
    print '#####################################################################'
    print 'Generating AirlinesTrain complex DRF binary classification model. . .'
    rf_AirlinesTrain_2_params = {'destination_key': 'rf_AirlinesTrain_binary_2', 'response': 'IsDepDelayed', 'ignored_cols_by_name': 'IsDepDelayed_REC', 'ntrees': 50, 'max_depth': 10, 'classification': 1, }
    rf_AirlinesTrain_2 = node.random_forest(Basic.airlines_train_hex, timeoutSecs, retryDelaySecs, **rf_AirlinesTrain_2_params)
    print '######################################################################'
    print 'Generating AirlinesTrain DeepLearning binary classification model. . .'
    dl_AirlinesTrain_1_params = {'destination_key': 'dl_AirlinesTrain_binary_1', 'response': 'IsDepDelayed', 'ignored_cols': 'IsDepDelayed_REC', 'hidden': [10, 10], 'classification': 1, }
    dl_AirlinesTrain_1 = node.deep_learning(Basic.airlines_train_hex, timeoutSecs, retryDelaySecs, **dl_AirlinesTrain_1_params)
    print '##############################################################################################'
    print 'Generating AirlinesTrain GLM2 binary classification model with different response column. . .'
    glm_AirlinesTrain_A_params = {'destination_key': 'glm_AirlinesTrain_binary_A', 'response': 'IsDepDelayed_REC', 'ignored_cols': 'IsDepDelayed', 'family': 'binomial', 'alpha': 0.5, 'standardize': 0, 'lambda': 0.01, 'n_folds': 0, }
    glm_AirlinesTrain_A = node.GLM(Basic.airlines_train_hex, timeoutSecs, retryDelaySecs, **glm_AirlinesTrain_A_params)
    h2o_glm.simpleCheckGLM(self, glm_AirlinesTrain_A, None, **glm_AirlinesTrain_A_params)
    print '#########################################################'
    print 'Generating Prostate GLM2 binary classification model. . .'
    glm_Prostate_1_params = {'destination_key': 'glm_Prostate_binary_1', 'response': 'CAPSULE', 'ignored_cols': None, 'family': 'binomial', 'alpha': 0.5, 'n_folds': 0, }
    glm_Prostate_1 = node.GLM(Basic.prostate_hex, timeoutSecs, retryDelaySecs, **glm_Prostate_1_params)
    h2o_glm.simpleCheckGLM(self, glm_Prostate_1, None, **glm_Prostate_1_params)
    print '###############################################################'
    print 'Generating Prostate simple DRF binary classification model. . .'
    rf_Prostate_1_params = {'destination_key': 'rf_Prostate_binary_1', 'response': 'CAPSULE', 'ignored_cols_by_name': None, 'ntrees': 10, 'max_depth': 5, 'classification': 1, }
    rf_Prostate_1 = node.random_forest(Basic.prostate_hex, timeoutSecs, retryDelaySecs, **rf_Prostate_1_params)
    print '##############################################'
    print 'Generating Prostate GLM2 regression model. . .'
    glm_Prostate_regression_1_params = {'destination_key': 'glm_Prostate_regression_1', 'response': 'AGE', 'ignored_cols': None, 'family': 'gaussian', 'alpha': 0.5, 'n_folds': 0, }
    glm_Prostate_regression_1 = node.GLM(Basic.prostate_hex, timeoutSecs, retryDelaySecs, **glm_Prostate_regression_1_params)
    h2o_glm.simpleCheckGLM(self, glm_Prostate_regression_1, None, **glm_Prostate_regression_1_params)
    print '##############################################'
    print 'Testing /2/Frames with various options. . .'
    print '##############################################'
    print ''
    print '##############################################'
    print 'Testing /2/Frames list. . .'
    frames = node.frames()
    self.assertKeysExist(frames, 'frames', ['airlines_train.hex', 'airlines_test.hex', 'prostate.hex'])
    self.assertKeysDontExist(frames, 'frames', ['glm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_2', 'rf_AirlinesTrain_binary_1', 'rf_AirlinesTrain_binary_2', 'dl_AirlinesTrain_binary_1', 'glm_AirlinesTrain_binary_A', 'glm_Prostate_binary_1', 'rf_Prostate_binary_1', 'glm_Prostate_regression_1'])
    self.assertKeysDontExist(frames, '', ['models'])
    print '##############################################'
    print 'Testing /2/Frames?key=airlines_test.hex. . .'
    frames = node.frames(key='airlines_test.hex')
    self.assertKeysExist(frames, 'frames', ['airlines_test.hex'])
    self.assertKeysDontExist(frames, 'frames', ['glm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_2', 'rf_AirlinesTrain_binary_1', 'rf_AirlinesTrain_binary_2', 'dl_AirlinesTrain_binary_1', 'glm_AirlinesTrain_binary_A', 'glm_Prostate_binary_1', 'rf_Prostate_binary_1', 'glm_Prostate_regression_1', 'airlines_train.hex', 'prostate.hex'])
    self.assertKeysDontExist(frames, '', ['models'])
    print '##############################################'
    print 'Testing /2/Frames?key=airlines_test.hex&find_compatible_models=true. . .'
    frames = node.frames(key='airlines_test.hex', find_compatible_models=1)
    self.assertKeysExist(frames, 'frames', ['airlines_test.hex'])
    self.assertKeysDontExist(frames, 'frames', ['glm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_2', 'rf_AirlinesTrain_binary_1', 'rf_AirlinesTrain_binary_2', 'dl_AirlinesTrain_binary_1', 'glm_AirlinesTrain_binary_A', 'glm_Prostate_binary_1', 'rf_Prostate_binary_1', 'glm_Prostate_regression_1', 'airlines_train.hex', 'prostate.hex'])
    self.assertKeysExist(frames, '', ['models'])
    self.assertKeysExist(frames, 'models', ['glm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_2', 'rf_AirlinesTrain_binary_1', 'rf_AirlinesTrain_binary_2', 'dl_AirlinesTrain_binary_1', 'glm_AirlinesTrain_binary_A'])
    self.assertKeysDontExist(frames, 'models', ['glm_Prostate_binary_1', 'rf_Prostate_binary_1', 'glm_Prostate_regression_1', 'airlines_train.hex', 'airlines_train.hex', 'airlines_test.hex', 'prostate.hex'])
    print '##############################################'
    print 'Testing /2/Frames with various options. . .'
    print '##############################################'
    print ''
    print '##############################################'
    print 'Testing /2/Models list. . .'
    models = node.models()
    self.assertKeysExist(models, 'models', ['glm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_2', 'rf_AirlinesTrain_binary_1', 'rf_AirlinesTrain_binary_2', 'dl_AirlinesTrain_binary_1', 'glm_AirlinesTrain_binary_A', 'glm_Prostate_binary_1', 'rf_Prostate_binary_1', 'glm_Prostate_regression_1'])
    self.assertKeysDontExist(models, 'models', ['airlines_train.hex', 'airlines_test.hex', 'prostate.hex'])
    self.assertKeysDontExist(models, '', ['frames'])
    print '##############################################'
    print 'Testing /2/Models?key=rf_Prostate_binary_1. . .'
    models = node.models(key='rf_Prostate_binary_1')
    self.assertKeysExist(models, 'models', ['rf_Prostate_binary_1'])
    self.assertKeysDontExist(models, 'models', ['airlines_train.hex', 'airlines_test.hex', 'prostate.hex', 'glm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_2', 'rf_AirlinesTrain_binary_1', 'rf_AirlinesTrain_binary_2', 'dl_AirlinesTrain_binary_1', 'glm_AirlinesTrain_binary_A', 'glm_Prostate_binary_1', 'glm_Prostate_regression_1'])
    self.assertKeysDontExist(models, '', ['frames'])
    print '##############################################'
    print 'Testing /2/Models?key=rf_Prostate_binary_1&find_compatible_frames=true. . .'
    models = node.models(key='rf_Prostate_binary_1', find_compatible_frames=1)
    self.assertKeysExist(models, 'models', ['rf_Prostate_binary_1'])
    self.assertKeysDontExist(models, 'models', ['airlines_train.hex', 'airlines_test.hex', 'prostate.hex', 'glm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_1', 'gbm_AirlinesTrain_binary_2', 'rf_AirlinesTrain_binary_1', 'rf_AirlinesTrain_binary_2', 'dl_AirlinesTrain_binary_1', 'glm_AirlinesTrain_binary_A', 'glm_Prostate_binary_1', 'glm_Prostate_regression_1'])
    self.assertKeysExist(models, '', ['frames'])
    self.assertKeysExist(models, 'frames', ['prostate.hex'])
    self.assertKeysDontExist(models, 'frames', ['airlines_train.hex', 'airlines_test.hex'])
    print '##############################################'
    print 'Testing /2/Frames with scoring. . .'
    print '##############################################'
    print ''
    print '##############################################'
    print 'Scoring compatible models for /2/Frames?key=airlines_test.hex&find_compatible_models=true. . .'
    frames = node.frames(key='airlines_test.hex', find_compatible_models=1)
    compatible_models = frames['frames']['airlines_test.hex']['compatible_models']
    for model_key in compatible_models:
        print ('Scoring: /2/Frames?key=airlines_test.hex&score_model=' + model_key)
        scoring_result = node.frames(key='airlines_test.hex', score_model=model_key)
        self.assertKeysExist(scoring_result, '', ['metrics'])
        self.assertKeysExist(scoring_result, 'metrics', ['model_category'])
        model_category = scoring_result['metrics']['model_category']
        self.assertKeysExist(scoring_result, 'metrics', ['model', 'frame', 'duration_in_ms', 'error'])
        self.assertEqual(scoring_result['metrics']['model'], model_key, ((('Expected model key: ' + model_key) + ' but got: ') + scoring_result['metrics']['model']))
        self.assertEqual(scoring_result['metrics']['frame'], 'airlines_test.hex', ((('Expected frame key: ' + 'airlines_test.hex') + ' but got: ') + scoring_result['metrics']['frame']))
        if (model_category is 'Binomial'):
            self.assertKeysExist(scoring_result, 'metrics', ['cm', 'auc'])
        if (model_category is 'Regression'):
            self.assertKeysDontExist(scoring_result, 'metrics', ['cm', 'auc'])
    print '##############################################'
    print 'Scoring compatible models for /2/Frames?key=prostate.hex&find_compatible_models=true. . .'
    frames = node.frames(key='prostate.hex', find_compatible_models=1)
    compatible_models = frames['frames']['prostate.hex']['compatible_models']
    for model_key in compatible_models:
        print ('Scoring: /2/Frames?key=prostate.hex&score_model=' + model_key)
        scoring_result = node.frames(key='prostate.hex', score_model=model_key)
        self.assertKeysExist(scoring_result, '', ['metrics'])
        self.assertKeysExist(scoring_result, 'metrics', ['model_category'])
        model_category = scoring_result['metrics']['model_category']
        self.assertKeysExist(scoring_result, 'metrics', ['model', 'frame', 'duration_in_ms', 'error'])
        self.assertEqual(scoring_result['metrics']['model'], model_key, ((('Expected model key: ' + model_key) + ' but got: ') + scoring_result['metrics']['model']))
        self.assertEqual(scoring_result['metrics']['frame'], 'prostate.hex', ((('Expected frame key: ' + 'prostate.hex') + ' but got: ') + scoring_result['metrics']['frame']))
        if (model_category is 'Binomial'):
            self.assertKeysExist(scoring_result, 'metrics', ['cm', 'auc'])
        if (model_category is 'Regression'):
            self.assertKeysDontExist(scoring_result, 'metrics', ['cm', 'auc'])
