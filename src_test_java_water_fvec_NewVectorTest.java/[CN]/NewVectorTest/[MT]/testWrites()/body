{
  Key key=Vec.newKey();
  AppendableVec av=new AppendableVec(key);
  NewChunk nv=new NewChunk(av,0);
  nv._ls=new long[]{0,0,0,0};
  nv._xs=new int[]{0,0,0,0};
  nv._len=nv._sparseLen=nv._ls.length;
  long[] ls=nv._ls;
  nv.close(0,null);
  Futures fs=new Futures();
  Vec vec=av.close(fs);
  fs.blockForPending();
  assertEquals(nv._len,vec.length());
  Chunk c0=vec.chunkForChunkIdx(0);
  assertTrue("Found chunk class " + c0.getClass() + " but expected C0LChunk",c0 instanceof C0LChunk);
  assertEquals(false,c0.hasFloat());
  for (int i=0; i < ls.length; i++)   assertEquals(0,c0.at0(i),c0.at0(i) * EPSILON);
  vec.set(0,0);
  assertEquals(0,vec.at8(0));
  Chunk c1=vec.chunkForChunkIdx(0);
  assertTrue("Found chunk class " + c1.getClass() + " but expected C0LChunk",c1 instanceof C0LChunk);
  vec.set(1,1);
  assertEquals(1,vec.at8(1));
  Chunk c2=vec.chunkForChunkIdx(0);
  assertTrue("Found chunk class " + c2.getClass() + " but expected CBSChunk",c2 instanceof CBSChunk);
  vec.set(2,2);
  assertEquals(2,vec.at8(2));
  Chunk c3=vec.chunkForChunkIdx(0);
  assertTrue("Found chunk class " + c3.getClass() + " but expected C1NChunk",c3 instanceof C1NChunk);
  vec.set(3,3);
  assertEquals(3,vec.at8(3));
  Chunk c4=vec.chunkForChunkIdx(0);
  assertTrue("Found chunk class " + c4.getClass() + " but expected C1NChunk",c4 instanceof C1NChunk);
  Vec.Writer vw=vec.open();
  vw.set(1,4);
  vw.set(2,5);
  vw.set(3,6);
  vw.close();
  assertEquals(4,vec.at8(1));
  assertEquals(5,vec.at8(2));
  assertEquals(6,vec.at8(3));
  UKV.remove(av._key);
}
