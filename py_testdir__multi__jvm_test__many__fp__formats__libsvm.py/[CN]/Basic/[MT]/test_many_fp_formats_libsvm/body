def test_many_fp_formats_libsvm(self):
    h2b.browseTheCloud()
    SYNDATASETS_DIR = h2o.make_syn_dir()
    tryList = [(10, 10, 'cA', 30, 'sparse50'), (100, 10, 'cB', 30, 'sparse'), (100000, 100, 'cC', 30, 'sparse'), (1000, 10, 'cD', 30, 'sparse50'), (100, 100, 'cE', 30, 'sparse'), (100, 100, 'cF', 30, 'sparse50')]
    for (rowCount, colCount, hex_key, timeoutSecs, distribution) in tryList:
        for sel in [random.randint(0, 47)]:
            SEEDPERFILE = random.randint(0, sys.maxint)
            csvFilename = ('syn_%s_%s_%s_%s.csv' % (SEEDPERFILE, sel, rowCount, colCount))
            csvPathname = ((SYNDATASETS_DIR + '/') + csvFilename)
            print 'Creating random', csvPathname
            (synColSumDict, colNumberMax) = write_syn_dataset(csvPathname, rowCount, colCount, SEEDPERFILE, sel, distribution)
            selKey2 = ((hex_key + '_') + str(sel))
            parseResult = h2i.import_parse(path=csvPathname, schema='put', hex_key=selKey2, timeoutSecs=timeoutSecs)
            print csvFilename, 'parse time:', parseResult['response']['time']
            print "Parse result['destination_key']:", parseResult['destination_key']
            inspect = h2o_cmd.runInspect(None, parseResult['destination_key'])
            num_cols = inspect['num_cols']
            num_rows = inspect['num_rows']
            print ('\n' + csvFilename)
            goodX = h2o_glm.goodXFromColumnInfo(y=0, key=parseResult['destination_key'], timeoutSecs=300)
            if DO_SUMMARY:
                summaryResult = h2o_cmd.runSummary(key=selKey2, timeoutSecs=360)
                h2o_cmd.infoFromSummary(summaryResult, noPrint=True)
            print synColSumDict.keys(), colNumberMax
            self.assertEqual((colNumberMax + 1), num_cols, msg=('generated %s cols (including output).  parsed to %s cols' % ((colNumberMax + 1), num_cols)))
            h2e.exec_zero_list(zeroList)
            colSumList = h2e.exec_expr_list_across_cols(None, exprList, selKey2, maxCol=(colNumberMax + 1), timeoutSecs=timeoutSecs)
            self.assertEqual(rowCount, num_rows, msg=('generated %s rows, parsed to %s rows' % (rowCount, num_rows)))
            print '\ncolSumList:', colSumList
            print '\nsynColSumDict:', synColSumDict
            for (k, v) in synColSumDict.iteritems():
                if (k > colNumberMax):
                    continue
                self.assertTrue(((k >= 0) and (k < len(colSumList))), msg=('k: %s len(colSumList): %s num_cols: %s' % (k, len(colSumList), num_cols)))
                syn = {}
                if (k == 0):
                    syn['name'] = 'Target'
                    syn['size'] = {1, 2}
                    syn['type'] = {'int'}
                    syn['min'] = classMin
                    syn['max'] = classMax
                    syn['scale'] = {1}
                elif (k == 1):
                    syn['name'] = ('V' + str(k))
                    syn['size'] = {1}
                    syn['type'] = {'int'}
                    syn['min'] = 0
                    syn['max'] = 0
                    syn['scale'] = {1}
                    syn['base'] = 0
                    syn['variance'] = 0
                else:
                    syn['name'] = ('V' + str(k))
                    syn['size'] = {1, 2, 4, 8}
                    syn['type'] = {'int', 'float'}
                    syn['min'] = valMin
                    syn['max'] = valMax
                    syn['scale'] = {1, 10, 100, 1000}
                syn['num_missing_values'] = 0
                syn['enum_domain_size'] = 0
                cols = inspect['cols'][k]
                for synKey in syn:
                    if (synKey == 'min'):
                        self.assertTrue((syn[synKey] <= cols[synKey]), msg=('col %s %s %s should be <= %s' % (k, synKey, cols[synKey], syn[synKey])))
                    elif (synKey == 'max'):
                        self.assertTrue((syn[synKey] >= cols[synKey]), msg=('col %s %s %s should be >= %s' % (k, synKey, cols[synKey], syn[synKey])))
                    elif ((synKey == 'size') or (synKey == 'scale') or (synKey == 'type')):
                        if (cols[synKey] not in syn[synKey]):
                            print 'cols size/min/max:', cols['size'], cols['min'], cols['max']
                            print 'syn size/min/max:', syn['size'], syn['min'], syn['max']
                            raise Exception(('col %s %s %s should be in this allowed %s' % (k, synKey, cols[synKey], syn[synKey])))
                    else:
                        self.assertEqual(syn[synKey], cols[synKey], msg=('col %s %s %s should be %s' % (k, synKey, cols[synKey], syn[synKey])))
                colSum = colSumList[k]
                print '\nComparing col', k, 'sums:', v, colSum
                self.assertAlmostEqual(float(v), colSum, places=0, msg=('%0.6f col sum is not equal to expected %0.6f' % (v, colSum)))
