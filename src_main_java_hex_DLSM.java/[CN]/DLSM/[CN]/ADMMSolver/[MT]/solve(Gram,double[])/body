{
  final int N=gram._xy.length;
  Arrays.fill(z,0);
  if (_lambda > 0)   gram.addDiag(_lambda * (1 - _alpha) * 0.5 + _rho);
  int attempts=0;
  long t=System.currentTimeMillis();
  Cholesky chol=gram.cholesky(null,_jobKey);
  Log.info("GLM(" + _jobKey + ")"+ " cholesky decomp took "+ (System.currentTimeMillis() - t)+ "ms");
  double rhoAdd=0;
  if (!chol._isSPD && _autoHandleNonSPDMatrix) {
    Log.info("GLM(" + _jobKey + ")"+ " got non-spd matrix");
    while (!chol._isSPD && attempts < 10) {
      double rhoIncrement=_rho * (1 << ++attempts);
      gram.addDiag(rhoIncrement);
      rhoAdd+=rhoIncrement;
      gram.cholesky(chol,_jobKey);
    }
    Log.info("GLM(" + _jobKey + ")"+ " cholesky decomp after nonSPD took "+ (System.currentTimeMillis() - t)+ "ms");
  }
  if (!chol._isSPD)   throw new NonSPDMatrixException();
  if (_lambda == 0) {
    _alpha=0;
    _lambda=rhoAdd;
  }
 else   _rho+=rhoAdd;
  if (_alpha == 0 || _lambda == 0) {
    System.arraycopy(gram._xy,0,z,0,gram._xy.length);
    chol.solve(z);
    return _converged=true;
  }
  final double ABSTOL=Math.sqrt(N) * 1e-4;
  final double RELTOL=1e-2;
  double[] u=MemoryManager.malloc8d(N);
  double[] xyPrime=gram._xy.clone();
  double kappa=_lambda * _alpha / _rho;
  t=System.currentTimeMillis();
  for (int i=0; i < 1000; ++i) {
    for (int j=0; j < N - 1; ++j)     xyPrime[j]=gram._xy[j] + _rho * (z[j] - u[j]);
    xyPrime[N - 1]=gram._xy[N - 1];
    chol.solve(xyPrime);
    double x_norm=0;
    double z_norm=0;
    double u_norm=0;
    double r_norm=0;
    double s_norm=0;
    double eps_pri=0;
    double eps_dual=0;
    for (int j=0; j < N - 1; ++j) {
      double x_hat=xyPrime[j];
      x_norm+=x_hat * x_hat;
      x_hat=x_hat * _orlx + (1 - _orlx) * z[j];
      double zold=z[j];
      z[j]=shrinkage(x_hat + u[j],kappa);
      z_norm+=z[j] * z[j];
      s_norm+=(z[j] - zold) * (z[j] - zold);
      r_norm+=(xyPrime[j] - z[j]) * (xyPrime[j] - z[j]);
      u[j]+=x_hat - z[j];
      u_norm+=u[j] * u[j];
    }
    z[N - 1]=xyPrime[N - 1];
    r_norm=Math.sqrt(r_norm);
    s_norm=_rho * Math.sqrt(s_norm);
    eps_pri=ABSTOL + RELTOL * Math.sqrt(Math.max(x_norm,z_norm));
    eps_dual=ABSTOL + _rho * RELTOL * Math.sqrt(u_norm);
    if (r_norm < eps_pri && s_norm < eps_dual) {
      Log.info("GLM(" + _jobKey + ")"+ " ADMM solve took "+ i+ " iterations and "+ (System.currentTimeMillis() - t)+ "ms");
      return _converged=true;
    }
  }
  Log.info("GLM(" + _jobKey + ")"+ " ADMM solve DID NOT CONVERGE after 1000 iterations and "+ (System.currentTimeMillis() - t)+ "ms");
  return false;
}
