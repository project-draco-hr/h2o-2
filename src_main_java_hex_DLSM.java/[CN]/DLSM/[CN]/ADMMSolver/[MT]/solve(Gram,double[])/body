{
  final int N=gram._xy.length;
  Arrays.fill(z,0);
  if (_lambda > 0)   gram.addDiag(_lambda * (1 - _alpha) * 0.5 + _rho);
  int attempts=0;
  boolean isspd=false;
  while (!(isspd=gram.cholesky()) && attempts < 10)   gram.addDiag(_rho * (1 << ++attempts));
  if (!isspd)   throw new NonSPDMatrixException();
  if (_alpha == 0 || _lambda == 0) {
    System.arraycopy(gram._xy,0,z,0,gram._xy.length);
    gram.solve(z);
    return _converged=true;
  }
  final double ABSTOL=Math.sqrt(N) * 1e-4;
  final double RELTOL=1e-2;
  double[] u=MemoryManager.malloc8d(N);
  double[] xyPrime=gram._xy.clone();
  double kappa=_lambda * _alpha / _rho;
  for (int i=0; i < 1000; ++i) {
    for (int j=0; j < N - 1; ++j)     xyPrime[j]=gram._xy[j] + _rho * (z[j] - u[j]);
    xyPrime[N - 1]=gram._xy[N - 1];
    gram.solve(xyPrime);
    double x_norm=0;
    double z_norm=0;
    double u_norm=0;
    double r_norm=0;
    double s_norm=0;
    double eps_pri=0;
    double eps_dual=0;
    for (int j=0; j < N - 1; ++j) {
      double x_hat=xyPrime[j];
      x_norm+=x_hat * x_hat;
      x_hat=x_hat * _orlx + (1 - _orlx) * z[j];
      double zold=z[j];
      z[j]=shrinkage(x_hat + u[j],kappa);
      z_norm+=z[j] * z[j];
      s_norm+=(z[j] - zold) * (z[j] - zold);
      r_norm+=(xyPrime[j] - z[j]) * (xyPrime[j] - z[j]);
      u[j]+=x_hat - z[j];
      u_norm+=u[j] * u[j];
    }
    z[N - 1]=xyPrime[N - 1];
    r_norm=Math.sqrt(r_norm);
    s_norm=_rho * Math.sqrt(s_norm);
    eps_pri=ABSTOL + RELTOL * Math.sqrt(Math.max(x_norm,z_norm));
    eps_dual=ABSTOL + _rho * RELTOL * Math.sqrt(u_norm);
    if (r_norm < eps_pri && s_norm < eps_dual)     return _converged=true;
  }
  return false;
}
