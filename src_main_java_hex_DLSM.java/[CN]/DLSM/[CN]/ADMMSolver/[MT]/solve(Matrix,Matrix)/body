{
  final int N=xx.getRowDimension();
  double lambda=_lambda * (1 - _alpha) * 0.5 + _rho;
  if (_lambda != 0)   for (int i=0; i < N - 1; ++i)   xx.set(i,i,xx.get(i,i) + lambda);
  CholeskyDecomposition lu=new CholeskyDecomposition(xx);
  if (_alpha == 0 || _lambda == 0)   try {
    return lu.solve(xy).getColumnPackedCopy();
  }
 catch (  Exception e) {
    if (!e.getMessage().equals("Matrix is not symmetric positive definite."))     throw new Error(e);
    throw new NonSPDMatrixException();
  }
  final double ABSTOL=Math.sqrt(N) * 1e-4;
  final double RELTOL=1e-2;
  double[] z=new double[N];
  double[] u=new double[N - 1];
  Matrix xm=null;
  Matrix xyPrime=(Matrix)xy.clone();
  OUTER:   for (int a=0; a < 5; ++a) {
    double kappa=_lambda * _alpha / _rho;
    for (int i=0; i < 10000; ++i) {
      for (int j=0; j < N - 1; ++j) {
        xyPrime.set(j,0,xy.get(j,0) + _rho * (z[j] - u[j]));
      }
      try {
        xm=lu.solve(xyPrime);
      }
 catch (      Exception e) {
        if (!e.getMessage().equals("Matrix is not symmetric positive definite."))         throw new Error(e);
        _rho*=10;
        lambda=(_lambda * (1 - _alpha) + _rho) - lambda;
        for (int j=0; j < N - 1; ++j)         xx.set(j,j,xx.get(j,j) + lambda);
        Arrays.fill(z,0);
        Arrays.fill(u,0);
        continue OUTER;
      }
      double x_norm=0;
      double z_norm=0;
      double u_norm=0;
      double r_norm=0;
      double s_norm=0;
      double eps_pri=0;
      double eps_dual=0;
      for (int j=0; j < N - 1; ++j) {
        double x_hat=xm.get(j,0);
        x_norm+=x_hat * x_hat;
        x_hat=x_hat * _orlx + (1 - _orlx) * z[j];
        double zold=z[j];
        z[j]=shrinkage(x_hat + u[j],kappa);
        z_norm+=z[j] * z[j];
        s_norm+=(z[j] - zold) * (z[j] - zold);
        r_norm+=(xm.get(j,0) - z[j]) * (xm.get(j,0) - z[j]);
        u[j]+=x_hat - z[j];
        u_norm+=u[j] * u[j];
      }
      z[N - 1]=xm.get(N - 1,0);
      r_norm=Math.sqrt(r_norm);
      s_norm=_rho * Math.sqrt(s_norm);
      eps_pri=ABSTOL + RELTOL * Math.sqrt(Math.max(x_norm,z_norm));
      eps_dual=ABSTOL + _rho * RELTOL * Math.sqrt(u_norm);
      if (r_norm < eps_pri && s_norm < eps_dual)       break;
    }
    return z;
  }
  throw new NonSPDMatrixException();
}
