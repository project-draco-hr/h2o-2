{
  if (source_key == null)   return RequestServer._http404.serve();
  if (column == null)   return RequestServer._http404.serve();
  if (column.isEnum()) {
    throw new IllegalArgumentException("Column is an enum");
  }
  if (!((interpolation_type == 2) || (interpolation_type == 7))) {
    throw new IllegalArgumentException("Unsupported interpolation type. Currently only allow 2 or 7");
  }
  Vec[] vecs=new Vec[1];
  String[] names=new String[1];
  vecs[0]=column;
  names[0]=source_key.names()[source_key.find(column)];
  Frame fr=new Frame(names,vecs);
  Futures fs=new Futures();
  for (  Vec vec : vecs) {
    vec.rollupStats(fs);
    double vmax=vec.max();
    double vmin=vec.min();
    double vmean=vec.mean();
    double vsigma=vec.sigma();
    long vnaCnt=vec.naCnt();
    boolean visInt=vec.isInt();
  }
  fs.blockForPending();
  double valStart=vecs[0].min();
  double valEnd=vecs[0].max();
  boolean multiPass;
  Quantiles[] qbins;
  double approxResult;
  double exactResult;
  result_single=Double.NaN;
  result=Double.NaN;
  boolean done=false;
  if (multiple_pass == 0 || multiple_pass == 2) {
    multiPass=false;
    result_single=Double.NaN;
    if (multiple_pass == 0)     result=Double.NaN;
    qbins=new Quantiles.BinTask2(quantile,max_qbins,valStart,valEnd,multiPass,interpolation_type).doAll(fr)._qbins;
    Log.debug("Q_ for approx. valStart: " + valStart + " valEnd: "+ valEnd);
    if (qbins != null) {
      qbins[0].finishUp(vecs[0]);
      column_name=qbins[0].colname;
      quantile_requested=qbins[0].QUANTILES_TO_DO[0];
      iterations=1;
      done=qbins[0]._done;
      approxResult=qbins[0]._pctile[0];
      interpolated=qbins[0]._interpolated;
      interpolation_type_used=qbins[0]._interpolationType;
    }
 else {
      column_name="";
      quantile_requested=quantile;
      iterations=0;
      done=false;
      approxResult=Double.NaN;
      interpolated=false;
      interpolation_type_used=interpolation_type;
    }
    result_single=approxResult;
    if (multiple_pass == 0)     result=approxResult;
    qbins=null;
  }
  if (multiple_pass == 1 || multiple_pass == 2) {
    final int MAX_ITERATIONS=16;
    multiPass=true;
    exactResult=Double.NaN;
    Quantiles[] qbins2;
    int iteration;
    qbins2=null;
    for (int b=0; b < MAX_ITERATIONS; b++) {
      qbins2=new Quantiles.BinTask2(quantile,max_qbins,valStart,valEnd,multiPass,interpolation_type).doAll(fr)._qbins;
      iterations=b + 1;
      if (qbins2 != null) {
        qbins2[0].finishUp(vecs[0]);
        double valRange=qbins2[0]._valRange;
        double valBinSize=qbins2[0]._valBinSize;
        Log.debug("\nQ_ multipass iteration: " + iterations + " valStart: "+ valStart+ " valEnd: "+ valEnd);
        Log.debug("Q_ valBinSize: " + valBinSize);
        valStart=qbins2[0]._newValStart;
        valEnd=qbins2[0]._newValEnd;
        done=qbins2[0]._done;
        if (done)         break;
      }
    }
    if (qbins2 != null) {
      column_name=qbins2[0].colname;
      quantile_requested=qbins2[0].QUANTILES_TO_DO[0];
      done=qbins2[0]._done;
      exactResult=qbins2[0]._pctile[0];
      interpolated=qbins2[0]._interpolated;
      interpolation_type_used=qbins2[0]._interpolationType;
    }
 else {
      column_name="";
      quantile_requested=quantile;
      iterations=0;
      done=false;
      exactResult=Double.NaN;
      interpolated=false;
      interpolation_type_used=interpolation_type;
    }
    qbins2=null;
    result=exactResult;
  }
  return Response.done(this);
}
