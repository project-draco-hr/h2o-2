def findQuantile(d, dmin, dmax, threshold):
    maxIterations = 30
    totalRows = len(d)
    newValStart = dmin
    newValEnd = dmax
    newValRange = (newValEnd - newValStart)
    desiredBinCnt = BIN_COUNT
    newBinSize = (newValRange / (desiredBinCnt + 0.0))
    newLowCount = 0
    desiredBinCnt = BIN_COUNT
    maxBinCnt = (desiredBinCnt + 1)
    assert (maxBinCnt > 0)
    hcnt = [None for b in range(maxBinCnt)]
    hcnt_min = [None for b in range(maxBinCnt)]
    hcnt_max = [None for b in range(maxBinCnt)]
    hcnt_low = 0
    hcnt_high = 0
    assert (newBinSize != 0)
    assert (newValEnd > newValStart)
    assert (newValRange > 0)
    iteration = 0
    done = False
    best_result = []

    def htot2():
        return ((sum(hcnt) + hcnt_low) + hcnt_high)
    while ((iteration <= maxIterations) and (not done)):
        h2p.green_print('newValStart', newValStart)
        h2p.green_print('newValEnd', newValEnd)
        h2p.green_print('newValRange', newValRange)
        h2p.green_print('newBinSize', newBinSize)
        h2p.green_print('newLowCount', newLowCount)
        h2p.green_print('threshold', threshold)
        valStart = newValStart
        valEnd = newValEnd
        valRange = newValRange
        binSize = newBinSize
        lowCount = newLowCount
        desiredBinCnt = BIN_COUNT
        maxBinCnt = (desiredBinCnt + 1)
        NUDGE = 0.001
        NUDGE = ((1000 * (valEnd - valStart)) / 1000000)
        NUDGE = (binSize / desiredBinCnt)
        NUDGE = 0
        for b in range(maxBinCnt):
            hcnt[b] = 0.0
        hcnt_low = 0
        hcnt_high = 0
        hcnt_high_min = None
        for val in d:
            valOffset = (val - valStart)
            if (valOffset < 0):
                hcnt_low += 1
            elif (val > valEnd):
                if (hcnt_high == 0):
                    hcnt_high_min = val
                else:
                    hcnt_high_min = min(hcnt_high_min, val)
                hcnt_high += 1
            else:
                hcntIdx = int((round(((valOffset * 1000000.0) / binSize)) / 1000000.0))
                assert ((hcntIdx >= 0) and (hcntIdx <= maxBinCnt)), ('val %s %s %s %s hcntIdx: %s maxBinCnt: %s binSize: %s' % (val, valStart, valEnd, valOffset, hcntIdx, maxBinCnt, binSize))
                if (hcnt[hcntIdx] == 0):
                    hcnt_min[hcntIdx] = val
                    hcnt_max[hcntIdx] = val
                else:
                    hcnt_min[hcntIdx] = min(hcnt_min[hcntIdx], val)
                    hcnt_max[hcntIdx] = max(hcnt_max[hcntIdx], val)
                hcnt[hcntIdx] += 1
        totalBinnedRows = htot2()
        assert (totalRows == totalBinnedRows), ('totalRows: %s htot2() %s not equal' % (totalRows, totalBinnedRows))
        k = 0
        currentCnt = newLowCount
        targetCntFull = ((threshold * totalRows) + 0.5)
        targetCntInt = int(math.floor(targetCntFull))
        targetCntFract = (targetCntFull - targetCntInt)
        print 'targetCntInt:', targetCntInt, 'targetCntFract', targetCntFract
        while ((currentCnt + hcnt[k]) < targetCntInt):
            currentCnt += hcnt[k]
            k = (k + 1)
            assert (k <= maxBinCnt), ('k too large, k: %s maxBinCnt %s' % (k, maxBinCnt))
        if (hcnt[k] == 1):
            assert (hcnt_min[k] == hcnt_max[k])
        done = False
        if ((not done) and (hcnt_min[k] == hcnt_max[k]) and (currentCnt == targetCntInt)):
            if ((hcnt[k] >= 2) or (targetCntFract == 0)):
                done = True
                guess = hcnt_min[k]
                print 'Done:', 'hcnt_min[k]', 'hcnt_max[k]', 'currentCnt', 'targetCntInt', 'targetCntFract'
                print 'Done:', hcnt_min[k], hcnt_max[k], currentCnt, targetCntInt, targetCntFract
            else:
                guess = ((hcnt_max[k] - hcnt_min[k]) / 2)
        if ((not done) and (hcnt[k] > 1) and (hcnt_min[k] == hcnt_max[k]) and (targetCntFract != 0)):
            print '\nInterpolating result into single value of this bin'
            print 'Guess E:', 'guess', 'k', 'hcnt[k]', 'hcnt_min[k]', 'hcnt_max[k]', 'currentCnt', 'targetCntInt'
            print 'Guess E:', guess, k, hcnt[k], hcnt_min[k], hcnt_max[k], currentCnt, targetCntInt
            guess = hcnt_min[k]
            done = True
        if ((not done) and (hcnt[k] == 1) and (hcnt_min[k] == hcnt_max[k]) and (targetCntFract != 0)):
            print '\nSingle value in this bin, but fractional means we need to interpolate to next non-zero'
            if (k < maxBinCnt):
                nextK = (k + 1)
            else:
                nextK = k
            while ((nextK < maxBinCnt) and (hcnt[nextK] == 0)):
                nextK += 1
            if ((nextK >= maxBinCnt) and (hcnt_high_cnt != 0)):
                nextVal = hcnt_high_min
            else:
                assert (hcnt[nextK] != 0)
                nextVal = hcnt_min[nextK]
            guess = ((hcnt_max[k] + nextVal) / 2.0)
            done = True
            print ('\nInterpolating result using nextK: %s nextVal: %s' % (nextK, nextVal))
            print 'Guess G with nextK:', guess
        if (not done):
            newValStart = (hcnt_min[k] - NUDGE)
            newValEnd = (hcnt_max[k] + NUDGE)
            newValRange = (newValEnd - newValStart)
            newBinSize = (newValRange / (desiredBinCnt + 0.0))
            newLowCount = currentCnt
            print 'Saying done because newBinSize is 0.'
            print ('newValRange: %s, hcnt[k]: %s hcnt_min[k]: %s hcnt_max[k]: %s' % (newValRange, hcnt[k], hcnt_min[k], hcnt_max[k]))
            guess = newValStart
            done = (newBinSize == 0)
        best_result.append(guess)
        print ('Compare these two, should be identical? %s %s' % (guess, best_result[(-1)]))
        iteration += 1
        h2p.blue_print('Ending Pass', iteration)
        h2p.blue_print('best_result:', best_result, 'done:', done, 'hcnt[k]', hcnt[k])
        print 'currentCnt', currentCnt, 'targetCntInt', targetCntInt, 'hcnt_low', hcnt_low, 'hcnt_high', hcnt_high
        print 'was', valStart, valEnd, valRange, binSize
        print 'next', newValStart, newValEnd, newValRange, newBinSize
    return best_result[(-1)]
