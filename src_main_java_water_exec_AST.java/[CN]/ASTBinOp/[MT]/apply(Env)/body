{
  Frame fr0=null, fr1=null;
  double d0=0, d1=0;
  if (env.isFrame())   fr1=env.popFrame();
 else   d1=env.popDbl();
  if (env.isFrame())   fr0=env.popFrame();
 else   d0=env.popDbl();
  if (fr0 == null && fr1 == null) {
    env.poppush(op(d0,d1));
    return;
  }
  env.pop();
  final ASTBinOp bin=this;
  Frame fr=null;
  Frame fr2=null;
  if (fr0 != null && fr1 != null) {
    if (fr0.numCols() != fr1.numCols() || fr0.numRows() != fr1.numRows())     throw new IllegalArgumentException("Arrays must be same size: " + fr0 + " vs "+ fr1);
    fr=fr0;
    fr2=new MRTask2(){
      @Override public void map(      Chunk chks[],      NewChunk nchks[]){
        for (int i=0; i < nchks.length; i++) {
          Chunk c0=chks[i];
          Chunk c1=chks[i + nchks.length];
          NewChunk n=nchks[i];
          for (int r=0; r < c0._len; r++)           n.addNum(bin.op(c0.at0(r),c1.at0(r)));
        }
      }
    }
.doAll(fr0.numCols(),new Frame(fr0).add(fr1))._outputFrame;
  }
 else   if (fr0 != null) {
    fr=fr0;
    final double d=d1;
    final int ncols=fr.numCols();
    fr2=new MRTask2(){
      @Override public void map(      Chunk chks[],      NewChunk nchks[]){
        for (int i=0; i < nchks.length; i++) {
          Chunk c=chks[i];
          NewChunk n=nchks[i];
          for (int r=0; r < c._len; r++)           n.addNum(bin.op(c.at0(r),d));
        }
      }
    }
.doAll(fr.numCols(),fr)._outputFrame;
  }
 else {
    fr=fr1;
    final double d=d0;
    final int ncols=fr.numCols();
    fr2=new MRTask2(){
      @Override public void map(      Chunk chks[],      NewChunk nchks[]){
        for (int i=0; i < nchks.length; i++) {
          Chunk c=chks[i];
          NewChunk n=nchks[i];
          for (int r=0; r < c._len; r++)           n.addNum(bin.op(d,c.at0(r)));
        }
      }
    }
.doAll(fr.numCols(),fr)._outputFrame;
  }
  env.push(fr.copyHeaders(fr2,null));
}
