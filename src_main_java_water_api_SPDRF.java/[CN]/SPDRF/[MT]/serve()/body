{
  Frame fr=source;
  int classCol=fr.find(response);
  int ntree=_numTrees;
  Key dataKey=fr._key;
  Key modelKey=_modelKey != null ? _modelKey : RFModel.makeKey();
  Lockable.delete(modelKey);
  int features=_features;
  int exclusiveSplitLimit=_exclusiveSplitLimit;
  float[] samples=new float[(int)(response.max() - response.min() + 1)];
  for (int i=0; i < samples.length; ++i)   samples[i]=(float)67.0;
  double[] weigts=new double[(int)(response.max() - response.min() + 1)];
  for (int i=0; i < weigts.length; ++i)   weigts[i]=1.0;
  try {
    DRFJob drfJob=DRF.execute(modelKey,cols,fr,fr.vecs()[fr.find(fr._names[classCol])],ntree,_depth,_binLimit,StatType.ENTROPY,_seed,_parallel,weigts,features,Sampling.Strategy.RANDOM,_sample / 100.0f,samples,0,exclusiveSplitLimit,_useNonLocalData);
    JsonObject response=new JsonObject();
    response.addProperty(DATA_KEY,dataKey.toString());
    response.addProperty(MODEL_KEY,drfJob.dest().toString());
    response.addProperty(DEST_KEY,drfJob.dest().toString());
    response.addProperty(NUM_TREES,ntree);
    response.addProperty(CLASS,classCol);
    Response r=SPDRFView.redirect(response,drfJob.self(),drfJob.dest(),dataKey,ntree,classCol,"1.0,1.0",_oobee,_iterativeCM);
    r.setBuilder(DEST_KEY,new KeyElementBuilder());
    return r;
  }
 catch (  IllegalArgumentException e) {
    return Response.error("Incorrect input data: " + e.getMessage());
  }
}
