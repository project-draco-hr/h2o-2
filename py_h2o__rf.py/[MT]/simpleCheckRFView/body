def simpleCheckRFView(node=None, rfv=None, checkScoringOnly=False, noPrint=False, **kwargs):
    if (not node):
        node = h2o.nodes[0]
    if ('warnings' in rfv):
        warnings = rfv['warnings']
        for w in warnings:
            if (not noPrint):
                print '\nwarning:', w
            if (('Failed' in w) or ('failed' in w)):
                raise Exception(w)
    if h2o.beta_features:
        if ('cms' in rfv):
            midpoint = (len(cms) / 2)
            cm = rfv['cms'][(-1)]
        else:
            cms = rfv['drf_model']['cms']
            print 'number of cms:', len(cms)
            print 'cms[0]:', cms[0]
            midpoint = (len(cms) / 2)
            cm = cms[(-1)]
        scoresList = cm
    else:
        cm = rfv['confusion_matrix']
        header = cm['header']
        classification_error = cm['classification_error']
        rows_skipped = cm['rows_skipped']
        cm_type = cm['type']
        if (not noPrint):
            print 'classification_error * 100 (pct):', (classification_error * 100)
            print 'rows_skipped:', rows_skipped
            print 'type:', cm_type
        used_trees = cm['used_trees']
        if (used_trees <= 0):
            raise Exception('used_trees should be >0. used_trees:', used_trees)
        ntree = kwargs.get('ntree', None)
        if ((ntree is not None) and (used_trees != ntree)):
            raise Exception('used_trees should == ntree. used_trees:', used_trees)
        scoresList = cm['scores']
    totalScores = 0
    totalRight = 0
    classErrorPctList = []
    predictedClassDict = {}
    for (classIndex, s) in enumerate(scoresList):
        classSum = sum(s)
        if (classSum == 0):
            if (not noPrint):
                print 'class:', classIndex, 'classSum', classSum, '<- why 0?'
        else:
            classRightPct = (((s[classIndex] + 0.0) / classSum) * 100)
            totalRight += s[classIndex]
            classErrorPct = round((100 - classRightPct), 2)
            classErrorPctList.append(classErrorPct)
            if (not noPrint):
                print 'class:', classIndex, 'classSum', classSum, 'classErrorPct:', ('%4.2f' % classErrorPct)
            for (pIndex, p) in enumerate(s):
                if (pIndex not in predictedClassDict):
                    predictedClassDict[pIndex] = p
                else:
                    predictedClassDict[pIndex] += p
        totalScores += classSum
    if (not noPrint):
        print 'Predicted summary:'
        for (predictedClass, p) in predictedClassDict.items():
            print (str(predictedClass) + ':'), p
        print 'totalScores:', totalScores
        print 'totalRight:', totalRight
        if (totalScores != 0):
            pctRight = ((100.0 * totalRight) / totalScores)
        else:
            pctRight = 0.0
        pctWrong = (100 - pctRight)
        print 'pctRight:', ('%5.2f' % pctRight)
        print 'pctWrong:', ('%5.2f' % pctWrong)
    if checkScoringOnly:
        h2o.check_sandbox_for_errors()
        classification_error = pctWrong
        return (round(classification_error, 2), classErrorPctList, totalScores)
    if ((totalScores <= 0) or (totalScores > 5000000000.0)):
        raise Exception('scores in RFView seems wrong. scores:', scoresList)
    if h2o.beta_features:
        rf_model = rfv['drf_model']
        used_trees = rf_model['N']
        if (used_trees <= 0):
            raise Exception('used_trees should be >0. used_trees:', used_trees)
        varimp = rf_model['varimp']
        errs = rf_model['errs']
        print 'errs[0]:', errs[0]
        print 'errs[-1]:', errs[(-1)]
        print 'errs:', errs
        treeStats = rf_model['treeStats']
        data_key = rf_model['_dataKey']
        model_key = rf_model['_selfKey']
        classification_error = pctWrong
        if (not noPrint):
            print '\n             Leaves: {0} / {1} / {2}\n              Depth: {3} / {4} / {5}\n                Err: {6:0.2f} %\n            '.format(treeStats['minLeaves'], treeStats['meanLeaves'], treeStats['maxLeaves'], treeStats['minDepth'], treeStats['meanDepth'], treeStats['maxDepth'], classification_error)
    else:
        type = cm['type']
        used_trees = cm['used_trees']
        if ((used_trees <= 0) or (used_trees > 20000)):
            raise Exception('used_trees in RFView seems wrong. used_trees:', used_trees)
        data_key = rfv['data_key']
        model_key = rfv['model_key']
        ntree = rfv['ntree']
        if ((ntree <= 0) or (ntree > 20000)):
            raise Exception('ntree in RFView seems wrong. ntree:', ntree)
        response = rfv['response']
        rfv_h2o = response['h2o']
        rfv_node = response['node']
        status = response['status']
        time = response['time']
        trees = rfv['trees']
        depth = trees['depth']
        leaves = trees['leaves']
        if (' 0.0 ' in leaves):
            raise Exception('leaves in RFView seems wrong. leaves:', leaves)
        if (not noPrint):
            print '\n             Leaves: {0} / {1} / {2}\n              Depth: {3} / {4} / {5}\n               mtry: {6}\n               Type: {7}\n                Err: {8} %\n            '.format(rfv['trees']['leaves']['min'], rfv['trees']['leaves']['mean'], rfv['trees']['leaves']['max'], rfv['trees']['depth']['min'], rfv['trees']['depth']['mean'], rfv['trees']['depth']['max'], rfv['mtry'], rfv['confusion_matrix']['type'], (rfv['confusion_matrix']['classification_error'] * 100))
        number_built = trees['number_built']
        if ((number_built <= 0) or (number_built > 20000)):
            raise Exception('number_built in RFView seems wrong. number_built:', number_built)
        h2o.verboseprint('RFView response: number_built:', number_built, 'leaves:', leaves, 'depth:', depth)
    dataInspect = node.inspect(data_key)
    h2o.check_sandbox_for_errors()
    return (round(classification_error, 2), classErrorPctList, totalScores)
