def sh2junit(name='NoName', cmd_string='/bin/ls', timeout=300, **kwargs):
    print 'cmd_string:', cmd_string
    cmdList = cmd_string.split()
    (outfd, outpath) = sandbox_tmp_file(prefix=(name + '.stdout.'), suffix='.log')
    (errfd, errpath) = sandbox_tmp_file(prefix=(name + '.stderr.'), suffix='.log')
    print 'outpath:', outpath
    print 'errpath:', errpath
    start = time.time()
    print 'psutil.Popen:', cmdList, outpath, errpath
    import subprocess
    ps = psutil.Popen(cmdList, stdin=None, stdout=subprocess.PIPE, stderr=errfd, **kwargs)
    comment = ('PID %d, stdout %s, stderr %s' % (ps.pid, os.path.basename(outpath), os.path.basename(errpath)))
    print 'spawn_cmd', cmd_string, comment
    if (not ps.is_running()):
        raise Exception('sh2junit: not immediate ps.is_running after start')
    linesMayExist = True
    while linesMayExist:
        wasRunning = ps.is_running()
        for lineBurstCnt in range(20):
            line = ps.stdout.readline()
            if (len(line) != 0):
                sys.stdout.write(('R->' + line))
                os.write(outfd, line)
            else:
                linesMayExist = wasRunning
        if wasRunning:
            print 'ps.is_running():', ps.is_running(), ps.pid, ps.name, ps.status, ps.create_time
        rc = rc_if_exists_and_done(ps)
        elapsed = (time.time() - start)
        if (timeout and (elapsed > timeout)):
            raise Exception(('sh2junit: elapsed: %0.2f timeout: %s (secs) while echoing stdout from subprocess' % (elapsed, timeout)))
        time.sleep(0.25)
    rc = ps.wait(3)
    elapsed = (time.time() - start)
    print 'rc:', rc
    if (rc is None):
        errors = 0
    elif (rc == 0):
        errors = 0
    else:
        errors = 1
    sandboxErrorMessage = h2o_sandbox.check_sandbox_for_errors(LOG_DIR='./sandbox', python_test_name=name, cloudShutdownIsError=True, sandboxIgnoreErrors=True)
    if sandboxErrorMessage:
        errors += 1
    out = file(outpath).read()
    err = file(errpath).read()
    create_junit_xml(name, out, err, sandboxErrorMessage, errors=errors, elapsed=elapsed)
    if (not (rc or errors)):
        return (errors, outpath, errpath)
    else:
        if ps.is_running():
            print 'Before terminate:', ps.pid, ps.is_running()
            terminate_process_tree(ps.pid, including_parent=True)
        if (rc is None):
            raise Exception(('%s %s timed out after %d\nstdout:\n%s\n\nstderr:\n%s' % (name, cmd_string, (timeout or 0), out, err)))
        elif (rc != 0):
            raise Exception(('%s %s failed. errors: %s\nstdout:\n%s\n\nstderr:\n%s' % (name, cmd_string, errors, out, err)))
        else:
            raise Exception(('%s %s has errors %s in ./sandbox log files?.\nstdout:\n%s\n\nstderr:\n%s' % (name, cmd_string, errors, out, err)))
