{
  try {
    ArrayList<Class> classes=new ArrayList<Class>();
{
      Class c=getClass();
      while (c != null) {
        classes.add(c);
        c=c.getSuperclass();
      }
    }
    Collections.reverse(classes);
    ArrayList<Field> fields=new ArrayList<Field>();
    for (    Class c : classes)     for (    Field field : c.getDeclaredFields())     if (!Modifier.isStatic(field.getModifiers()))     fields.add(field);
    HashMap<String,FrameClassVec> classVecs=new HashMap<String,FrameClassVec>();
    for (    Field f : fields) {
      Annotation[] as=f.getAnnotations();
      API api=find(as,API.class);
      if (api != null && Helper.isInput(api)) {
        f.setAccessible(true);
        Object defaultValue=f.get(this);
        Argument arg=null;
        if (Argument.class.isAssignableFrom(api.filter()))         arg=(Argument)newInstance(api);
 else         if (f.getType() == float.class || f.getType() == double.class) {
          double val=((Number)defaultValue).doubleValue();
          arg=new Real(f.getName(),api.required(),val,null,null,api.help());
        }
 else         if (f.getType() == int.class || f.getType() == long.class) {
          long val=((Number)defaultValue).longValue();
          arg=new LongInt(f.getName(),api.required(),val,null,null,api.help());
        }
 else         if (f.getType() == boolean.class) {
          boolean val=(Boolean)defaultValue;
          arg=new Bool(f.getName(),val,api.help());
        }
 else         if (Enum.class.isAssignableFrom(f.getType())) {
          Enum val=(Enum)defaultValue;
          arg=new EnumArgument(f.getName(),val);
        }
 else         if (f.getType() == Key.class)         arg=new H2OKey(f.getName(),(Key)defaultValue,api.required());
 else         if (Freezable.class.isAssignableFrom(f.getType()) && api.filter() == Default.class)         arg=new H2OKey(f.getName(),api.required());
 else         if (ColumnSelect.class.isAssignableFrom(api.filter())) {
          ColumnSelect name=(ColumnSelect)newInstance(api);
          H2OHexKey key=null;
          for (          Argument a : _arguments)           if (a instanceof H2OHexKey && name._key.equals(((H2OHexKey)a)._name))           key=(H2OHexKey)a;
          arg=new HexAllColumnSelect(f.getName(),key);
        }
 else         if (VecSelect.class.isAssignableFrom(api.filter())) {
          VecSelect name=(VecSelect)newInstance(api);
          FrameKey key=null;
          for (          Argument a : _arguments)           if (a instanceof FrameKey && name._key.equals(((FrameKey)a)._name))           key=(FrameKey)a;
          arg=new FrameKeyVec(f.getName(),key);
        }
 else         if (VecClassSelect.class.isAssignableFrom(api.filter())) {
          VecClassSelect name=(VecClassSelect)newInstance(api);
          FrameKey key=null;
          for (          Argument a : _arguments)           if (a instanceof FrameKey && name._key.equals(((FrameKey)a)._name))           key=(FrameKey)a;
          classVecs.put(name._key,(FrameClassVec)(arg=new FrameClassVec(f.getName(),key)));
        }
 else         if (MultiVecSelect.class.isAssignableFrom(api.filter())) {
          MultiVecSelect name=(MultiVecSelect)newInstance(api);
          FrameKey key=null;
          FrameClassVec response=classVecs.get(name._key);
          for (          Argument a : _arguments)           if (a instanceof FrameKey && name._key.equals(((FrameKey)a)._name))           key=(FrameKey)a;
          arg=new FrameKeyMultiVec(f.getName(),key,response);
        }
        if (arg != null) {
          arg._name=f.getName();
          arg._required=api.required();
          arg._field=f;
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}
