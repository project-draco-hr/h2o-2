{
  final int n=y.length;
  _y=y;
  _blocksz=blocksz;
  _kRem=_xx.length % _blocksz;
  _iRem=(_y.length - _kRem) % _blocksz;
  int M=_xx.length / blocksz + (_kRem == 0 ? 0 : 1);
  ;
  int N=n / blocksz + (_kRem == 0 ? 0 : 1);
  _tasks=new DelayedTask[M][];
  int rsz=N - 1;
  for (int i=M - 1; i >= 0; --i)   _tasks[i]=new DelayedTask[rsz--];
  _diagLen=_diag == null ? 0 : _diag.length;
  int firstBlockSz=_kRem == 0 ? _blocksz : _kRem;
  int kfrom=_diagLen + _xx.length - 1;
  int kto=kfrom - firstBlockSz + 1;
  int ifrom=_y.length - _iRem - firstBlockSz;
  int pending=0;
  for (int k=_tasks.length - 1; k >= 0; --k) {
    _tasks[k][_tasks[k].length - 1]=new BackSolveDiagTsk(0,kfrom,kto,ifrom);
    for (int i=0; i < _tasks[k].length - 1; ++i)     _tasks[k][i]=new BackSolveInnerTsk(pending,kfrom,kto,i * blocksz);
    kfrom=kto - 1;
    kto-=blocksz;
    ifrom-=blocksz;
    pending=1;
  }
  addToPendingCount(_tasks[0].length - 1);
}
