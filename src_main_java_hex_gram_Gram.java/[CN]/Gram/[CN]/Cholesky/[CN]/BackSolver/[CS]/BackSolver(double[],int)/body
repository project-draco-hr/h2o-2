{
  final int n=y.length;
  _y=y;
  _blocksz=blocksz;
  int kRem=_xx.length % _blocksz;
  int M=_xx.length / blocksz + (kRem == 0 ? 0 : 1);
  ;
  int N=n / blocksz + (kRem == 0 ? 0 : 1);
  _tasks=new DelayedTask[M][];
  int rsz=N;
  for (int i=M - 1; i >= 0; --i)   _tasks[i]=new DelayedTask[rsz--];
  _diagLen=_diag == null ? 0 : _diag.length;
  int kFrom=_diagLen + _xx.length - 1;
  int kTo=_diagLen + _xx.length;
  int iFrom=n;
  int pending=0;
  int rem=0;
  if (kRem > 0) {
    rem=1;
    int k=_tasks.length - 1;
    int i=_tasks[k].length - 1;
    int iRem=(n - kRem) % _blocksz;
    iFrom=n - kRem - iRem;
    kTo=kFrom - kRem + 1;
    _tasks[k][i]=new BackSolveDiagTsk(0,kFrom,kTo,iFrom);
    for (int j=0; j < _tasks[k].length - 1; ++j)     _tasks[k][j]=new BackSolveInnerTsk(pending,kFrom,kTo,j * blocksz);
    pending=1;
  }
  for (int k=_tasks.length - 1 - rem; k >= 0; --k) {
    kFrom=kTo - 1;
    kTo-=blocksz;
    iFrom-=blocksz;
    iFrom-=iFrom % blocksz;
    _tasks[k][_tasks[k].length - 1]=new BackSolveDiagTsk(0,kFrom,kTo,iFrom);
    for (int i=0; i < _tasks[k].length - 1; ++i)     _tasks[k][i]=new BackSolveInnerTsk(pending,kFrom,kTo,i * blocksz);
    pending=1;
  }
  addToPendingCount(_tasks[0].length - 1);
}
