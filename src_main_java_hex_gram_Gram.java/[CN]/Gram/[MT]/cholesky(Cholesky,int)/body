{
  long start=System.currentTimeMillis();
  if (chol == null) {
    double[][] xx=_xx.clone();
    for (int i=0; i < xx.length; ++i)     xx[i]=xx[i].clone();
    chol=new Cholesky(xx,_diag.clone());
  }
  final Cholesky fchol=chol;
  final int sparseN=_diag.length;
  final int denseN=_fullN - sparseN;
  if (_diag != null)   for (int i=0; i < sparseN; ++i) {
    double d=1.0 / (chol._diag[i]=Math.sqrt(_diag[i]));
    for (int j=0; j < denseN; ++j)     chol._xx[j][i]=d * _xx[j][i];
  }
  Futures fs=new Futures();
  for (int i=0; i < denseN; ++i) {
    final int fi=i;
    fs.add(new RecursiveAction(){
      @Override protected void compute(){
        double[] rowi=fchol._xx[fi];
        int[] nz=new int[sparseN];
        int n=0;
        for (int k=0; k < sparseN; ++k)         if (rowi[k] != .0)         nz[n++]=k;
        for (int j=0; j <= fi; ++j) {
          double[] rowj=fchol._xx[j];
          double s=0;
          for (int z=0; z < n; z++) {
            int k=nz[z];
            s+=rowi[k] * rowj[k];
          }
          rowi[j + sparseN]=_xx[fi][j + sparseN] - s;
        }
      }
    }
.fork());
  }
  fs.blockForPending();
  double[][] arr=new double[denseN][];
  for (int i=0; i < arr.length; ++i)   arr[i]=Arrays.copyOfRange(fchol._xx[i],sparseN,sparseN + denseN);
  start=System.currentTimeMillis();
  if (parallelize == 1) {
    int p=Runtime.getRuntime().availableProcessors();
    InPlaceCholesky d=InPlaceCholesky.decompose_2(arr,10,p);
    fchol.setSPD(d.isSPD());
    arr=d.getL();
  }
 else {
    for (int i=0; i < arr.length; ++i)     for (int j=0; j < i; ++j)     arr[j][i]=arr[i][j];
    CholeskyDecomposition c=new Matrix(arr).chol();
    fchol.setSPD(c.isSPD());
    arr=c.getL().getArray();
  }
  for (int i=0; i < arr.length; ++i)   System.arraycopy(arr[i],0,fchol._xx[i],sparseN,i + 1);
  return chol;
}
