{
  InetAddress inet=findInetAddressForSelf();
  API_PORT=OPT_ARGS.port != 0 ? OPT_ARGS.port : DEFAULT_PORT;
  while (true) {
    UDP_PORT=API_PORT + 1;
    try {
      _apiSocket=new ServerSocket(API_PORT);
      _udpSocket=DatagramChannel.open();
      _udpSocket.socket().setReuseAddress(true);
      _udpSocket.socket().bind(new InetSocketAddress(inet,UDP_PORT));
      break;
    }
 catch (    IOException e) {
      try {
        if (_apiSocket != null)         _apiSocket.close();
      }
 catch (      IOException ohwell) {
      }
      Closeables.closeQuietly(_udpSocket);
      _apiSocket=null;
      _udpSocket=null;
      if (OPT_ARGS.port != 0)       Log.die("On " + H2O.findInetAddressForSelf() + " some of the required ports "+ (OPT_ARGS.port + 0)+ ", "+ (OPT_ARGS.port + 1)+ " are not available, change -port PORT and try again.");
    }
    API_PORT+=2;
  }
  SELF=H2ONode.self(inet);
  L.info("Internal communication uses port: ",UDP_PORT,"\nListening for HTTP and REST traffic on  http:/",inet,":" + _apiSocket.getLocalPort() + "/");
  NAME=OPT_ARGS.name == null ? System.getProperty("user.name") : OPT_ARGS.name;
  STATIC_H2OS=parseFlatFile(OPT_ARGS.flatfile);
  int hash=NAME.hashCode() & 0x7fffffff;
  int port=(hash % (0xF0000000 - 0xE1000000)) + 0xE1000000;
  byte[] ip=new byte[4];
  for (int i=0; i < 4; i++)   ip[i]=(byte)(port >>> ((3 - i) << 3));
  try {
    CLOUD_MULTICAST_GROUP=InetAddress.getByAddress(ip);
  }
 catch (  UnknownHostException e) {
    throw new Error(e);
  }
  CLOUD_MULTICAST_PORT=(port >>> 16);
}
