{
  _cMeans=new double[_clusters.length][_clusters[0].length];
  _cSqrs=new double[_clusters.length][_clusters[0].length];
  _betwnSqrs=new double[_clusters.length];
  _rows=new long[_clusters.length];
  _gm=new double[_clusters[0].length];
  double[] values=new double[_clusters[0].length];
  ClusterDist cd=new ClusterDist();
  int[] clusters=new int[cs[0]._len];
  for (int row=0; row < cs[0]._len; row++) {
    data(values,cs,row,_means,_mults);
    closest(_clusters,values,_ncats,cd);
    int clu=clusters[row]=cd._cluster;
    _sqr+=cd._dist;
    if (clu == -1)     continue;
    for (int col=0; col < values.length; col++)     _cMeans[clu][col]+=values[col];
    _rows[clu]++;
  }
  int[] validMeans=new int[_gm.length];
  for (int clu=0; clu < _cMeans.length; clu++)   for (int col=0; col < _cMeans[clu].length; col++) {
    if (_rows[clu] != 0) {
      _cMeans[clu][col]/=_rows[clu];
      _gm[col]+=_cMeans[clu][col];
      validMeans[col]++;
    }
  }
  for (int col=0; col < _gm.length; col++)   if (validMeans[col] != 0)   _gm[col]/=validMeans[col];
  for (int clu=0; clu < _cMeans.length; clu++)   for (int col=0; col < _gm.length; col++) {
    double mean_delta=_cMeans[clu][col] - _gm[col];
    _betwnSqrs[clu]+=_rows[clu] * mean_delta * mean_delta;
  }
  for (int row=0; row < cs[0]._len; row++) {
    int clu=clusters[row];
    if (clu == -1)     continue;
    data(values,cs,row,_means,_mults);
    for (int col=0; col < values.length; col++) {
      double delta=values[col] - _cMeans[clu][col];
      _cSqrs[clu][col]+=delta * delta;
    }
  }
  _clusters=null;
  _means=_mults=null;
}
