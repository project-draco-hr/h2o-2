{
  KMeans2Model model=null;
  try {
    logStart();
    source.read_lock(self());
    String sourceArg=input("source");
    Key sourceKey=null;
    if (sourceArg != null)     sourceKey=Key.make(sourceArg);
    Frame fr=DataInfo.prepareFrame(source,ignored_cols,false,drop_na_cols);
    String[] names=fr.names();
    Vec[] vecs=fr.vecs();
    if (vecs == null || vecs.length == 0)     throw new IllegalArgumentException("No columns selected. Check that selected columns have not been dropped due to too many NAs.");
    DataInfo dinfo=new DataInfo(fr,0,false,DataInfo.TransformType.STANDARDIZE,DataInfo.TransformType.NONE);
    String[] domain=new String[k];
    for (int i=0; i < domain.length; i++)     domain[i]="Cluster " + i;
    String[] namesResp=Utils.append(names,"response");
    String[][] domaiResp=(String[][])Utils.append((new Frame(names,vecs)).domains(),(Object)domain);
    model=new KMeans2Model(this,destination_key,sourceKey,namesResp,domaiResp);
    model.delete_and_lock(self());
    model.k=k;
    model.normalized=normalize;
    model.max_iter=max_iter;
    double[] means=new double[vecs.length];
    double[] mults=normalize ? new double[vecs.length] : null;
    for (int i=0; i < vecs.length; i++) {
      means[i]=(float)vecs[i].mean();
      if (mults != null) {
        double sigma=vecs[i].sigma();
        mults[i]=normalize(sigma) ? 1.0 / sigma : 1.0;
      }
    }
    Random rand=Utils.getRNG(seed - 1);
    double[][] clusters;
    if (initialization == Initialization.None) {
      clusters=new double[k][vecs.length];
      for (      double[] cluster : clusters)       randomRow(vecs,rand,cluster,means,mults);
    }
 else {
      clusters=new double[1][];
      clusters[0]=new double[vecs.length];
      randomRow(vecs,rand,clusters[0],means,mults);
      while (model.iterations < 5) {
        SumSqr sqr=new SumSqr();
        sqr._clusters=clusters;
        sqr._means=means;
        sqr._mults=mults;
        sqr.doAll(vecs);
        Sampler sampler=new Sampler();
        sampler._clusters=clusters;
        sampler._sqr=sqr._sqr;
        sampler._probability=k * 3;
        sampler._seed=seed;
        sampler._ncats=dinfo._cats;
        sampler._means=means;
        sampler._mults=mults;
        sampler.doAll(vecs);
        clusters=Utils.append(clusters,sampler._sampled);
        if (!isRunning(self()))         return;
        model.centers=normalize ? denormalize(clusters,vecs) : clusters;
        model.total_within_SS=sqr._sqr;
        model.iterations++;
        model.update(self());
      }
      clusters=recluster(clusters,k,rand,initialization);
    }
    LOOP:     for (; ; ) {
      Lloyds task=new Lloyds();
      task._clusters=clusters;
      task._means=means;
      task._mults=mults;
      task._ncats=dinfo._cats;
      task._nnums=dinfo._nums;
      task.doAll(vecs);
      boolean badrow=false;
      for (int clu=0; clu < k; clu++)       if (task._rows[clu] == 0) {
        if (badrow) {
          Log.warn("KMeans: Re-running Lloyds to re-init another cluster");
          model.iterations--;
          continue LOOP;
        }
        long row=task._worse_row;
        Log.warn("KMeans: Re-initing cluster " + clu + " to row "+ row);
        data(clusters[clu]=task._cMeans[clu],vecs,row,means,mults);
        task._rows[clu]=1;
        badrow=true;
      }
      model.centers=clusters=normalize ? denormalize(task._cMeans,vecs) : task._cMeans;
      model.between_cluster_variances=task._betwnSqrs;
      double[] variances=new double[task._cSqrs.length];
      for (int clu=0; clu < task._cSqrs.length; clu++)       for (int col=0; col < task._cSqrs[clu].length; col++)       variances[clu]+=task._cSqrs[clu][col];
      double between_cluster_SS=0.0;
      for (int clu=0; clu < task._betwnSqrs.length; clu++)       between_cluster_SS+=task._betwnSqrs[clu];
      model.between_cluster_SS=between_cluster_SS;
      model.within_cluster_variances=variances;
      model.total_within_SS=task._sqr;
      model.total_SS=model.total_within_SS + model.between_cluster_SS;
      model.size=task._rows;
      model.iterations++;
      model.update(self());
      if (model.iterations >= max_iter) {
        Clusters cc=new Clusters();
        cc._clusters=clusters;
        cc._means=means;
        cc._mults=mults;
        cc.doAll(1,vecs);
        Frame fr2=cc.outputFrame(model._clustersKey,new String[]{"Cluster ID"},new String[][]{Utils.toStringMap(0,cc._clusters.length - 1)});
        fr2.delete_and_lock(self()).unlock(self());
        break;
      }
      if (!isRunning(self()))       break;
    }
  }
  finally {
    if (model != null)     model.unlock(self());
    source.unlock(self());
    remove();
    state=UKV.<Job>get(self()).state;
    new TAtomic<KMeans2Model>(){
      @Override public KMeans2Model atomic(      KMeans2Model m){
        if (m != null)         m.get_params().state=state;
        return m;
      }
    }
.invoke(dest());
  }
}
