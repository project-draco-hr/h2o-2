def test_glm_predict3(self):
    SYNDATASETS_DIR = h2o.make_syn_dir()
    trees = 15
    timeoutSecs = 120
    if (1 == 1):
        csvPathname = 'mnist/mnist_training.csv.gz'
        hexKey = 'mnist.hex'
    else:
        csvPathname = 'mnist/mnist_testing.csv.gz'
        hexKey = 'mnist.hex'
    predictHexKey = 'predict_0.hex'
    predictCsv = 'predict_0.csv'
    actualCsv = 'actual_0.csv'
    bucket = 'home-0xdiag-datasets'
    csvPredictPathname = ((SYNDATASETS_DIR + '/') + predictCsv)
    csvSrcOutputPathname = ((SYNDATASETS_DIR + '/') + actualCsv)
    csvFullname = h2i.find_folder_and_filename(bucket, csvPathname, schema='put', returnFullPath=True)

    def predict_and_compare_csvs(model_key, hex_key, translate):
        dataKey = 'P.hex'
        h2e.exec_expr(execExpr=((dataKey + '=') + hex_key), timeoutSecs=30)
        if HAS_HEADER:
            print 'Has header in dataset, so should be able to chop out col 0 for predict and get right answer'
            print "hack for now, can't chop out col 0 in Exec currently"
            dataKey = hex_key
        else:
            print "No header in dataset, can't chop out cols, since col numbers are used for names"
            dataKey = hex_key
        h2e.exec_expr(execExpr=(('Z.hex=' + hex_key) + '[0]'), timeoutSecs=30)
        start = time.time()
        predict = h2o.nodes[0].generate_predictions(model_key=model_key, data_key=dataKey, destination_key=predictHexKey)
        print 'generate_predictions end on ', hexKey, ' took', (time.time() - start), 'seconds'
        h2o.check_sandbox_for_errors()
        inspect = h2o_cmd.runInspect(key=predictHexKey)
        h2o_cmd.infoFromInspect(inspect, 'predict.hex')
        h2o.nodes[0].csv_download(src_key='Z.hex', csvPathname=csvSrcOutputPathname)
        h2o.nodes[0].csv_download(src_key=predictHexKey, csvPathname=csvPredictPathname)
        h2o.check_sandbox_for_errors()
        skipSrcOutputHeader = 1
        skipPredictHeader = 1
        print 'Do a check of the original output col against predicted output'
        (rowNum1, originalOutput) = compare_csv_at_one_col(csvSrcOutputPathname, msg='Original', colIndex=0, translate=translate, skipHeader=skipSrcOutputHeader)
        (rowNum2, predictOutput) = compare_csv_at_one_col(csvPredictPathname, msg='Predicted', colIndex=0, skipHeader=skipPredictHeader)
        if ((rowNum1 - skipSrcOutputHeader) != (rowNum2 - skipPredictHeader)):
            raise Exception(('original rowNum1: %s - %d not same as downloaded predict: rowNum2: %s - %d                     %s' % (rowNum1, skipSrcOutputHeader, rowNum2, skipPredictHeader)))
        wrong = 0
        wrong0 = 0
        wrong1 = 0
        for (rowNum, (o, p)) in enumerate(zip(originalOutput, predictOutput)):
            o = float(o)
            p = float(p)
            if (o != p):
                msg = ('Comparing original output col vs predicted. row %s differs.                         original: %s predicted: %s' % (rowNum, o, p))
                if ((p == 0.0) and (wrong0 == 10)):
                    print 'Not printing any more predicted=0 mismatches'
                elif ((p == 0.0) and (wrong0 < 10)):
                    print msg
                if ((p == 1.0) and (wrong1 == 10)):
                    print 'Not printing any more predicted=1 mismatches'
                elif ((p == 1.0) and (wrong1 < 10)):
                    print msg
                if (p == 0.0):
                    wrong0 += 1
                elif (p == 1.0):
                    wrong1 += 1
                wrong += 1
        print 'wrong0:', wrong0
        print 'wrong1:', wrong1
        print '\nTotal wrong:', wrong
        print 'Total:', len(originalOutput)
        pctWrong = ((100.0 * wrong) / len(originalOutput))
        print 'wrong/Total * 100 ', pctWrong
        if (pctWrong > 6.0):
            raise Exception('pct wrong too high. Expect < 6% error')
    parseResult = h2i.import_parse(bucket=bucket, path=csvPathname, schema='put', hex_key=hexKey)
    print 'Use H2O GeneratePredictionsPage with a H2O generated model and the same data key.'
    print "Does this work? (feeding in same data key)if you're predicting, "
    print "don't you need one less column (the last is output?)"
    print 'WARNING: max_iter set to 8 for benchmark comparisons'
    max_iter = 4
    for case in [0, 3, 7]:
        translate = {}
        for i in range(10):
            if (i == case):
                translate[i] = 1.0
            else:
                translate[i] = 0.0
        print 'translate:', translate
        kwargs = {'x': '', 'y': 0, 'family': 'binomial', 'link': 'logit', 'n_folds': 1, 'case_mode': '=', 'case': case, 'max_iter': max_iter, 'beta_epsilon': 0.001, }
        timeoutSecs = 120
        start = time.time()
        kwargs.update({'alpha': 0, 'lambda': 0, })
        glm = h2o_cmd.runGLM(parseResult=parseResult, timeoutSecs=timeoutSecs, **kwargs)
        print 'glm (L2) end on ', csvPathname, 'took', (time.time() - start), 'seconds'
        h2o_glm.simpleCheckGLM(self, glm, 13, **kwargs)
        predict_and_compare_csvs(model_key=glm['destination_key'], hex_key=hexKey, translate=translate)
        kwargs.update({'alpha': 0.5, 'lambda': 0.0001, })
        start = time.time()
        glm = h2o_cmd.runGLM(parseResult=parseResult, timeoutSecs=timeoutSecs, **kwargs)
        print 'glm (Elastic) end on ', csvPathname, 'took', (time.time() - start), 'seconds'
        h2o_glm.simpleCheckGLM(self, glm, 13, allowZeroCoeff=True, **kwargs)
        predict_and_compare_csvs(model_key=glm['destination_key'], hex_key=hexKey, translate=translate)
        kwargs.update({'alpha': 1, 'lambda': 0.0001, })
        start = time.time()
        glm = h2o_cmd.runGLM(parseResult=parseResult, timeoutSecs=timeoutSecs, **kwargs)
        print 'glm (L1) end on ', csvPathname, 'took', (time.time() - start), 'seconds'
        h2o_glm.simpleCheckGLM(self, glm, 13, allowZeroCoeff=True, **kwargs)
        predict_and_compare_csvs(model_key=glm['destination_key'], hex_key=hexKey, translate=translate)
