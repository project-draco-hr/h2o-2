{
  TestUtil.stall_till_cloudsize(ARGS.clusterSize);
  if (ARGS.ntrees <= 0 || ARGS.ntrees > 100000)   throw new RuntimeException("ntrees " + ARGS.ntrees + " out of bounds");
  if (ARGS.sample < 0 || ARGS.sample > 1.0f)   throw new RuntimeException("sample " + ARGS.sample + " out of bounds");
  if (ARGS.nbins < 2 || ARGS.nbins > 100000)   throw new RuntimeException("nbins " + ARGS.nbins + " out of bounds");
  if (ARGS.depth <= 1)   throw new RuntimeException("depth " + ARGS.depth + " out of bounds");
  if ((ARGS.trainFile != OptArgs.defaultTrainFile) ^ (ARGS.testFile != OptArgs.defaultTestFile))   throw new RuntimeException("Set both trainFile and testFile; a missing testFile will use OOBEE on train data");
  String cs[]=(ARGS.cols + "," + ARGS.response).split("[, \t]");
  if (ARGS.mtries == 0)   ARGS.mtries=(int)Math.sqrt(cs.length);
  if (ARGS.mtries <= 0 || ARGS.mtries > cs.length)   throw new RuntimeException("mtries " + ARGS.mtries + " out of bounds");
  Timer t_load=new Timer();
  Frame train=TestUtil.parseFrame(Key.make("train.hex"),ARGS.trainFile);
  Frame test=ARGS.testFile.length() == 0 ? null : TestUtil.parseFrame(Key.make("test.hex"),ARGS.testFile);
  Log.info(Sys.DRF__,"Data loaded in " + t_load);
  Vec response=train.subframe(new String[]{ARGS.response}).vecs()[0];
  train=train.subframe(cs);
  if (test != null)   test=test.subframe(cs);
  for (  Vec v : train.vecs())   v.min();
  for (int i=0; i < train.numCols(); i++)   Log.info(Sys.DRF__,train._names[i] + ", " + train.vecs()[i]);
  Log.info(Sys.DRF__,"Arguments used:\n" + ARGS.toString());
  Timer t_drf=new Timer();
  DRF drf=new DRF();
  drf.source=train;
  drf.validation=test;
  drf.response=response;
  drf.ntrees=ARGS.ntrees;
  drf.max_depth=ARGS.depth;
  drf.min_rows=ARGS.min_rows;
  drf.mtries=ARGS.mtries;
  drf.sample_rate=ARGS.sample;
  drf.seed=ARGS.seed;
  drf.destination_key=Key.make("DRF_Model_" + ARGS.trainFile);
  drf.invoke();
  Log.info(Sys.DRF__,"Model trained in " + t_drf);
  DRF.DRFModel model=UKV.get(drf.dest());
}
