{
  Random rand=Utils.getRNG(res._randSeed - 1);
  double[][] clusters;
  if (init == Initialization.None) {
    clusters=new double[k][];
    for (int i=0; i < clusters.length; i++) {
      clusters[i]=new double[cols.length - 1];
      randomRow(va,cols,rand,res._normalized,clusters[i]);
    }
  }
 else {
    clusters=new double[1][];
    clusters[0]=new double[cols.length - 1];
    randomRow(va,cols,rand,res._normalized,clusters[0]);
    while (res._iteration < 5) {
      Sqr sqr=new Sqr();
      sqr._arykey=va._key;
      sqr._cols=cols;
      sqr._clusters=clusters;
      sqr._normalize=res._normalized;
      sqr.invoke(va._key);
      Sampler sampler=new Sampler();
      sampler._arykey=va._key;
      sampler._cols=cols;
      sampler._clusters=clusters;
      sampler._normalize=res._normalized;
      sampler._sqr=sqr._sqr;
      sampler._probability=k * 3;
      sampler._seed=res._randSeed;
      sampler.invoke(va._key);
      clusters=Utils.append(clusters,sampler._clust2);
      if (!isRunning(self())) {
        remove();
        return;
      }
      res._iteration++;
      res._clusters=clusters;
      res.update(self());
    }
    clusters=recluster(clusters,k,rand,init);
  }
  res._clusters=clusters;
  for (; ; ) {
    Lloyds task=new Lloyds();
    task._arykey=va._key;
    task._cols=cols;
    task._clusters=clusters;
    task._normalize=res._normalized;
    task.invoke(va._key);
    double[] betwnSqrs=new double[clusters.length];
    double[] gm=new double[cols.length - 1];
    int[] validMeans=new int[cols.length - 1];
    for (int cluster=0; cluster < clusters.length; cluster++) {
      if (task._counts[cluster] > 0) {
        for (int column=0; column < cols.length - 1; column++) {
          double value=task._sums[cluster][column] / task._counts[cluster];
          clusters[cluster][column]=value;
          gm[column]+=value;
          validMeans[column]++;
        }
      }
    }
    for (int column=0; column < cols.length - 1; column++) {
      if (validMeans[column] != 0)       gm[column]/=validMeans[column];
    }
    for (int cluster=0; cluster < clusters.length; cluster++) {
      for (int column=0; column < cols.length - 1; column++) {
        double mean_delta=clusters[cluster][column] - gm[column];
        betwnSqrs[cluster]+=task._counts[cluster] * mean_delta * mean_delta;
      }
    }
    double between_cluster_SS=0.0;
    for (int clu=0; clu < betwnSqrs.length; clu++)     between_cluster_SS+=betwnSqrs[clu];
    res._between_cluster_SS=between_cluster_SS;
    res._error=task._error;
    res._total_SS=res._error + res._between_cluster_SS;
    res._iteration++;
    res.update(self());
    if (res._iteration >= res._maxIter)     break;
    if (!isRunning(self()))     break;
  }
  res.unlock(self());
  va.unlock(self());
  remove();
}
