{
  Random rand=Utils.getRNG(res._randSeed - 1);
  double[][] clusters;
  if (init == Initialization.None) {
    clusters=new double[k][];
    for (int i=0; i < clusters.length; i++) {
      clusters[i]=new double[cols.length - 1];
      randomRow(va,cols,rand,res._normalized,clusters[i]);
    }
  }
 else {
    clusters=new double[1][];
    clusters[0]=new double[cols.length - 1];
    randomRow(va,cols,rand,res._normalized,clusters[0]);
    while (res._iteration < 5) {
      Sqr sqr=new Sqr();
      sqr._arykey=va._key;
      sqr._cols=cols;
      sqr._clusters=clusters;
      sqr._normalize=res._normalized;
      sqr.invoke(va._key);
      Sampler sampler=new Sampler();
      sampler._arykey=va._key;
      sampler._cols=cols;
      sampler._clusters=clusters;
      sampler._normalize=res._normalized;
      sampler._sqr=sqr._sqr;
      sampler._probability=k * 3;
      sampler._seed=res._randSeed;
      sampler.invoke(va._key);
      clusters=Utils.append(clusters,sampler._clust2);
      if (cancelled()) {
        remove();
        return;
      }
      res._iteration++;
      res._clusters=clusters;
      res.update(self());
    }
    clusters=recluster(clusters,k,rand,init);
  }
  res._clusters=clusters;
  for (; ; ) {
    Lloyds task=new Lloyds();
    task._arykey=va._key;
    task._cols=cols;
    task._clusters=clusters;
    task._normalize=res._normalized;
    task.invoke(va._key);
    for (int cluster=0; cluster < clusters.length; cluster++) {
      if (task._counts[cluster] > 0) {
        for (int column=0; column < cols.length - 1; column++) {
          double value=task._sums[cluster][column] / task._counts[cluster];
          clusters[cluster][column]=value;
        }
      }
    }
    res._error=task._error;
    res._iteration++;
    res.update(self());
    if (res._iteration >= res._maxIter)     break;
    if (cancelled())     break;
  }
  res.unlock(self());
  remove();
}
