{
  int cols2[]=Arrays.copyOf(cols,cols.length + 1);
  cols2[cols.length]=-1;
  KMeansModel res=new KMeansModel(job.dest(),cols2,va._key);
  cols=res.columnMapping(va.colNames());
  double[][] clusters=new double[1][];
  clusters[0]=new double[cols.length - 1];
  AutoBuffer bits=va.getChunk(0);
  datad(va,bits,0,cols,clusters[0]);
  while (res._iteration < 5) {
    Sqr sqr=new Sqr();
    sqr._arykey=va._key;
    sqr._cols=cols;
    sqr._clusters=clusters;
    sqr.invoke(va._key);
    Sampler sampler=new Sampler();
    sampler._arykey=va._key;
    sampler._cols=cols;
    sampler._clusters=clusters;
    sampler._sqr=sqr._sqr;
    sampler._probability=k * 3;
    sampler.invoke(va._key);
    clusters=DRemoteTask.merge(clusters,sampler._clust2);
    if (job.cancelled()) {
      job.remove();
      return;
    }
    res._iteration++;
    res._clusters=clusters;
    UKV.put(job.dest(),res);
  }
  clusters=recluster(clusters,k);
  res._clusters=clusters;
  boolean moved=true;
  while (moved) {
    moved=false;
    Lloyds task=new Lloyds();
    task._arykey=va._key;
    task._cols=cols;
    task._clusters=clusters;
    task.invoke(va._key);
    for (int cluster=0; cluster < clusters.length; cluster++) {
      for (int column=0; column < cols.length - 1; column++) {
        double value=task._sums[cluster][column] / task._counts[cluster];
        if (Math.abs(value - clusters[cluster][column]) > epsilon)         moved=true;
        clusters[cluster][column]=value;
      }
    }
    res._iteration++;
    UKV.put(job.dest(),res);
    if (job.cancelled())     break;
  }
  job.remove();
}
