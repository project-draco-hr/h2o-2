{
  KMeansModel res=new KMeansModel(job.dest(),cols,va._key);
  cols=res.columnMapping(va.colNames());
  double[][] clusters=new double[1][];
  clusters[0]=new double[cols.length];
  AutoBuffer bits=va.getChunk(0);
  for (int c=0; c < cols.length; c++)   clusters[0][c]=datad(va,bits,0,va._cols[cols[c]]);
  while (res._iteration < 5) {
    Sqr sqr=new Sqr();
    sqr._arykey=va._key;
    sqr._cols=cols;
    sqr._clusters=clusters;
    sqr.invoke(va._key);
    Sampler sampler=new Sampler();
    sampler._arykey=va._key;
    sampler._cols=cols;
    sampler._clusters=clusters;
    sampler._sqr=sqr._sqr;
    sampler._probability=k * 3;
    sampler.invoke(va._key);
    clusters=DRemoteTask.merge(clusters,sampler._newClusters);
    if (job.cancelled()) {
      job.remove();
      return;
    }
    res._iteration++;
    UKV.put(job.dest(),res);
  }
  clusters=recluster(clusters,k);
  res._clusters=clusters;
  boolean moved=true;
  while (moved) {
    moved=false;
    Lloyds task=new Lloyds();
    task._arykey=va._key;
    task._cols=cols;
    task._clusters=clusters;
    task.invoke(va._key);
    for (int cluster=0; cluster < clusters.length; cluster++) {
      for (int column=0; column < cols.length; column++) {
        double value=task._sums[cluster][column] / task._counts[cluster];
        if (Math.abs(value - clusters[cluster][column]) > epsilon)         moved=true;
        clusters[cluster][column]=value;
      }
    }
    res._iteration++;
    UKV.put(job.dest(),res);
    if (job.cancelled())     break;
  }
  job.remove();
}
