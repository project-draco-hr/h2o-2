{
  Vec[] vecs=Utils.append(_train,response);
  reChunk(vecs);
  final Vec[] train=new Vec[vecs.length - 1];
  System.arraycopy(vecs,0,train,0,train.length);
  final Vec trainResp=classification ? vecs[vecs.length - 1].toEnum() : vecs[vecs.length - 1];
  final Layer[] ls=new Layer[hidden.length + 2];
  ls[0]=new VecsInput(train,null);
  for (int i=0; i < hidden.length; i++) {
    if (activation == Activation.Rectifier)     ls[i + 1]=new Layer.Rectifier(hidden[i]);
 else     ls[i + 1]=new Layer.Tanh(hidden[i]);
    ls[i + 1].rate=(float)rate;
    ls[i + 1].rate_annealing=(float)rate_annealing;
    ls[i + 1].l2=(float)l2;
  }
  if (classification)   ls[ls.length - 1]=new VecSoftmax(trainResp,null);
 else   ls[ls.length - 1]=new VecLinear(trainResp,null);
  ls[ls.length - 1].rate=(float)rate;
  ls[ls.length - 1].l2=(float)l2;
  for (int i=0; i < ls.length; i++)   ls[i].init(ls,i);
  final Key sourceKey=Key.make(input("source"));
  final Frame frame=new Frame(_names,train);
  frame.add(_responseName,trainResp);
  final NeuralNetModel model=new NeuralNetModel(destination_key,sourceKey,frame,ls);
  UKV.put(destination_key,model);
  final Trainer trainer=new Trainer.MapReduce(ls,epochs,self());
  Thread thread=new Thread(){
    @Override public void run(){
      try {
        Frame[] adapted=null;
        Vec[] valid=null;
        Vec validResp=null;
        if (validation != null) {
          adapted=model.adapt(validation,false);
          valid=new Vec[adapted[0].vecs().length];
          System.arraycopy(adapted[0].vecs(),0,valid,0,valid.length);
          validResp=_validResponse;
        }
        while (!cancelled()) {
          eval(valid,validResp);
          try {
            Thread.sleep(2000);
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
        eval(valid,validResp);
        if (adapted != null && adapted[1] != null)         adapted[1].remove();
      }
 catch (      Exception ex) {
        cancel(ex);
      }
    }
    private void eval(    Vec[] valid,    Vec validResp){
      long[][] cm=null;
      if (classification) {
        int classes=ls[ls.length - 1].units;
        cm=new long[classes][classes];
      }
      Error trainE=NeuralNet.eval(ls,train,trainResp,EVAL_ROW_COUNT,valid == null ? cm : null);
      Error validE=null;
      if (valid != null)       validE=NeuralNet.eval(ls,valid,validResp,EVAL_ROW_COUNT,cm);
      model.processed_samples=trainer.samples();
      model.train_classification_error=trainE.classification;
      model.train_mse=trainE.mse;
      model.validation_classification_error=validE != null ? validE.classification : Double.NaN;
      model.validation_mse=validE != null ? validE.mse : Double.NaN;
      model.confusion_matrix=cm;
      UKV.put(model._selfKey,model);
    }
  }
;
  trainer.start();
  thread.start();
}
