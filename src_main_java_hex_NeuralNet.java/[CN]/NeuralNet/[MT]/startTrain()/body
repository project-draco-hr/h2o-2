{
  Vec[] vecs=Utils.add(_train,response);
  reChunk(vecs);
  System.arraycopy(vecs,0,_train,0,_train.length);
  response=vecs[vecs.length - 1];
  final Layer[] ls=new Layer[hidden.length + 2];
  ls[0]=new VecsInput(vecs,null);
  for (int i=0; i < hidden.length; i++) {
    if (activation == Activation.Rectifier)     ls[i + 1]=new Layer.Rectifier(hidden[i]);
 else     ls[i + 1]=new Layer.Tanh(hidden[i]);
    ls[i + 1]._rate=(float)rate;
    ls[i + 1]._l2=(float)l2;
  }
  if (classification)   ls[ls.length - 1]=new VecSoftmax(response,null);
 else {
  }
  ls[ls.length - 1]._rate=(float)rate;
  ls[ls.length - 1]._l2=(float)l2;
  for (int i=0; i < ls.length; i++)   ls[i].init(ls,i);
  final Key sourceKey=Key.make(input("source"));
  final Frame frame=new Frame(_names,_train);
  frame.add(_responseName,response);
  final NeuralNetModel model=new NeuralNetModel(destination_key,sourceKey,frame,ls);
  UKV.put(destination_key,model);
  final Trainer trainer=new Trainer.MapReduce(ls,epochs,self());
  Thread thread=new Thread(){
    @Override public void run(){
      long start=System.nanoTime();
      Frame[] adapted=null;
      Vec[] valid=null;
      Vec validResp=null;
      if (validation != null) {
        adapted=model.adapt(validation,false,true);
        valid=new Vec[adapted[0].vecs().length - 1];
        System.arraycopy(adapted[0].vecs(),0,valid,0,valid.length);
        validResp=adapted[0].vecs()[adapted[0].vecs().length - 1];
      }
      while (running()) {
        long[][] cm=null;
        if (classification) {
          int classes=ls[ls.length - 1]._units;
          cm=new long[classes][classes];
        }
        Error trainE=eval(_train,response,EVAL_ROW_COUNT,valid == null ? cm : null);
        Error validE=null;
        if (valid != null)         validE=eval(valid,validResp,EVAL_ROW_COUNT,cm);
        double time=(System.nanoTime() - start) / 1e9;
        model.items=trainer.items();
        model.items_per_second=(int)(model.items / time);
        model.train_classification_error=trainE.Value;
        model.train_sqr_error=trainE.SqrDist;
        model.validation_classification_error=validE != null ? validE.Value : Double.NaN;
        model.validation_sqr_error=validE != null ? validE.SqrDist : Double.NaN;
        model.confusion_matrix=cm;
        UKV.put(model._selfKey,model);
        try {
          Thread.sleep(2000);
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(e);
        }
      }
      if (adapted != null && adapted[1] != null)       adapted[1].remove();
    }
  }
;
  trainer.start();
  thread.start();
}
