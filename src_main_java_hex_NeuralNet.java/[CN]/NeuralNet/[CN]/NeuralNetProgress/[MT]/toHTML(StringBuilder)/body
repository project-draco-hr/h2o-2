{
  final String mse_format="%2.6f";
  final String cross_entropy_format="%2.6f";
  if (model != null) {
    final boolean classification=model.isClassifier();
    final String cmTitle="Confusion Matrix" + (model.validation_errors == null ? " (Training Data)" : "");
    final Errors train=model.training_errors[model.training_errors.length - 1];
    final Errors valid=model.validation_errors != null ? model.validation_errors[model.validation_errors.length - 1] : null;
    if (classification) {
      DocGen.HTML.section(sb,"Training classification error: " + formatPct(train.classification));
    }
    DocGen.HTML.section(sb,"Training mean square error: " + String.format(mse_format,train.mean_square));
    if (classification) {
      DocGen.HTML.section(sb,"Training cross entropy: " + String.format(cross_entropy_format,train.cross_entropy));
      if (valid != null) {
        DocGen.HTML.section(sb,"Validation classification error: " + formatPct(valid.classification));
      }
    }
    if (model.validation_errors != null) {
      DocGen.HTML.section(sb,"Validation mean square error: " + String.format(mse_format,valid.mean_square));
      if (classification) {
        DocGen.HTML.section(sb,"Validation mean cross entropy: " + String.format(cross_entropy_format,valid.cross_entropy));
      }
      if (job != null) {
        long ps=valid.training_samples * 1000 / job.runTimeMs();
        DocGen.HTML.section(sb,"Training speed: " + ps + " samples/s");
      }
    }
 else {
      if (job != null) {
        long ps=train.training_samples * 1000 / job.runTimeMs();
        DocGen.HTML.section(sb,"Training speed: " + ps + " samples/s");
      }
    }
    if (parameters != null && parameters.diagnostics) {
      DocGen.HTML.section(sb,"Hidden Layer Status");
      sb.append("<table class='table table-striped table-bordered table-condensed'>");
      sb.append("<tr>");
      sb.append("<th>").append("#").append("</th>");
      sb.append("<th>").append("Units").append("</th>");
      sb.append("<th>").append("Activation").append("</th>");
      sb.append("<th>").append("Rate").append("</th>");
      sb.append("<th>").append("L1").append("</th>");
      sb.append("<th>").append("L2").append("</th>");
      sb.append("<th>").append("Momentum").append("</th>");
      sb.append("<th>").append("Weight (Mean, RMS)").append("</th>");
      sb.append("<th>").append("Bias (Mean, RMS)").append("</th>");
      sb.append("</tr>");
      for (int i=1; i < model.layers.length - 1; ++i) {
        sb.append("<tr>");
        sb.append("<td>").append("<b>").append(i).append("</b>").append("</td>");
        sb.append("<td>").append("<b>").append(model.layers[i].units).append("</b>").append("</td>");
        sb.append("<td>").append(model.layers[i].getClass().getSimpleName()).append("</td>");
        sb.append("<td>").append(model.layers[i].rate(train.training_samples)).append("</td>");
        sb.append("<td>").append(model.layers[i].l1).append("</td>");
        sb.append("<td>").append(model.layers[i].l2).append("</td>");
        final String format="%g";
        sb.append("<td>").append(model.layers[i].momentum(train.training_samples)).append("</td>");
        sb.append("<td>(").append(String.format(format,model.mean_weight[i])).append(", ").append(String.format(format,model.rms_weight[i])).append(")</td>");
        sb.append("<td>(").append(String.format(format,model.mean_bias[i])).append(", ").append(String.format(format,model.rms_bias[i])).append(")</td>");
        sb.append("</tr>");
      }
      sb.append("</table>");
    }
    if (model.unstable) {
      final String msg="Job was aborted due to observed numerical instability (exponential growth)." + "  Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.";
      DocGen.HTML.section(sb,"============================================================================================================");
      DocGen.HTML.section(sb,msg);
      DocGen.HTML.section(sb,"============================================================================================================");
    }
    if (model.confusion_matrix != null && model.confusion_matrix.length < 100) {
      assert(classification);
      String[] classes=model.classNames();
      NeuralNetScore.confusion(sb,cmTitle,classes,model.confusion_matrix);
    }
    sb.append("<h3>" + "Progress" + "</h3>");
    String training="Number of training set samples for scoring: " + train.score_training;
    if (train.score_training > 0) {
      if (train.score_training < 1000)       training+=" (low, scoring might be inaccurate)";
      if (train.score_training > 10000)       training+=" (large, scoring can be slow -> consider scoring manually)";
    }
    DocGen.HTML.section(sb,training);
    if (valid != null) {
      String validation="Number of validation set samples for scoring: " + valid.score_validation;
      if (valid.score_validation > 0) {
        if (valid.score_validation < 1000)         validation+=" (low, scoring might be inaccurate)";
        if (valid.score_validation > 10000)         validation+=" (large, scoring can be slow -> consider scoring manually)";
      }
      DocGen.HTML.section(sb,validation);
    }
    sb.append("<table class='table table-striped table-bordered table-condensed'>");
    sb.append("<tr>");
    sb.append("<th>Training Time</th>");
    sb.append("<th>Training Samples</th>");
    sb.append("<th>Training MSE</th>");
    if (classification) {
      sb.append("<th>Training MCE</th>");
      sb.append("<th>Training Classification Error</th>");
    }
    sb.append("<th>Validation MSE</th>");
    if (classification) {
      sb.append("<th>Validation MCE</th>");
      sb.append("<th>Validation Classification Error</th>");
    }
    sb.append("</tr>");
    for (int i=training_errors.length - 1; i >= 0; i--) {
      sb.append("<tr>");
      sb.append("<td>" + PrettyPrint.msecs(training_errors[i].training_time_ms,true) + "</td>");
      if (validation_errors != null) {
        sb.append("<td>" + String.format("%,d",validation_errors[i].training_samples) + "</td>");
      }
 else {
        sb.append("<td>" + String.format("%,d",training_errors[i].training_samples) + "</td>");
      }
      sb.append("<td>" + String.format(mse_format,training_errors[i].mean_square) + "</td>");
      if (classification) {
        sb.append("<td>" + String.format(cross_entropy_format,training_errors[i].cross_entropy) + "</td>");
        sb.append("<td>" + formatPct(training_errors[i].classification) + "</td>");
      }
      if (validation_errors != null) {
        sb.append("<td>" + String.format(mse_format,validation_errors[i].mean_square) + "</td>");
        if (classification) {
          sb.append("<td>" + String.format(cross_entropy_format,validation_errors[i].cross_entropy) + "</td>");
          sb.append("<td>" + formatPct(validation_errors[i].classification) + "</td>");
        }
      }
 else       sb.append("<td></td><td></td><td></td>");
      sb.append("</tr>");
    }
    sb.append("</table>");
  }
  return true;
}
