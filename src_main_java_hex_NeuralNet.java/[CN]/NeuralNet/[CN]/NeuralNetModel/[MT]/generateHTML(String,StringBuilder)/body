{
  final String mse_format="%2.6f";
  final String cross_entropy_format="%2.6f";
  DocGen.HTML.title(sb,title);
  DocGen.HTML.paragraph(sb,"Model Key: " + _selfKey);
  sb.append("<div class='alert'>Actions: " + water.api.Predict.link(_selfKey,"Score on dataset") + ", "+ NeuralNet.link(_dataKey,"Compute new model")+ "</div>");
{
    float[] train_err=new float[training_errors.length];
    float[] train_samples=new float[training_errors.length];
    for (int i=0; i < train_err.length; ++i) {
      train_err[i]=(float)training_errors[i].classification;
      train_samples[i]=training_errors[i].training_samples;
    }
    new D3Plot(train_samples,train_err,"training samples","classification error","Classification Error on Training Set").generate(sb);
  }
  if (validation_errors != null) {
    float[] valid_err=new float[validation_errors.length];
    float[] valid_samples=new float[validation_errors.length];
    for (int i=0; i < valid_err.length; ++i) {
      valid_err[i]=(float)validation_errors[i].classification;
      valid_samples[i]=validation_errors[i].training_samples;
    }
    new D3Plot(valid_samples,valid_err,"training samples","classification error","Classification Error on Validation Set").generate(sb);
  }
  final boolean classification=isClassifier();
  final String cmTitle="Confusion Matrix" + (validation_errors == null ? " (Training Data)" : "");
  final Errors train=training_errors[training_errors.length - 1];
  final Errors valid=validation_errors != null ? validation_errors[validation_errors.length - 1] : null;
  if (classification) {
    DocGen.HTML.section(sb,"Training classification error: " + formatPct(train.classification));
  }
  DocGen.HTML.section(sb,"Training mean square error: " + String.format(mse_format,train.mean_square));
  if (classification) {
    DocGen.HTML.section(sb,"Training cross entropy: " + String.format(cross_entropy_format,train.cross_entropy));
    if (valid != null) {
      DocGen.HTML.section(sb,"Validation classification error: " + formatPct(valid.classification));
    }
  }
  if (validation_errors != null) {
    DocGen.HTML.section(sb,"Validation mean square error: " + String.format(mse_format,valid.mean_square));
    if (classification) {
      DocGen.HTML.section(sb,"Validation mean cross entropy: " + String.format(cross_entropy_format,valid.cross_entropy));
    }
    if (valid.training_time_ms > 0)     DocGen.HTML.section(sb,"Training speed: " + valid.training_samples * 1000 / valid.training_time_ms + " samples/s");
  }
 else {
    if (train.training_time_ms > 0)     DocGen.HTML.section(sb,"Training speed: " + train.training_samples * 1000 / train.training_time_ms + " samples/s");
  }
  if (parameters != null && parameters.diagnostics) {
    DocGen.HTML.section(sb,"Status of Hidden and Output Layers");
    sb.append("<table class='table table-striped table-bordered table-condensed'>");
    sb.append("<tr>");
    sb.append("<th>").append("#").append("</th>");
    sb.append("<th>").append("Units").append("</th>");
    sb.append("<th>").append("Activation").append("</th>");
    sb.append("<th>").append("Rate").append("</th>");
    sb.append("<th>").append("L1").append("</th>");
    sb.append("<th>").append("L2").append("</th>");
    sb.append("<th>").append("Momentum").append("</th>");
    sb.append("<th>").append("Weight (Mean, RMS)").append("</th>");
    sb.append("<th>").append("Bias (Mean, RMS)").append("</th>");
    sb.append("</tr>");
    for (int i=1; i < layers.length; ++i) {
      sb.append("<tr>");
      sb.append("<td>").append("<b>").append(i).append("</b>").append("</td>");
      sb.append("<td>").append("<b>").append(layers[i].units).append("</b>").append("</td>");
      sb.append("<td>").append(layers[i].getClass().getSimpleName().replace("Vec","").replace("Chunk","")).append("</td>");
      sb.append("<td>").append(String.format("%.5g",layers[i].rate(train.training_samples))).append("</td>");
      sb.append("<td>").append(layers[i].l1).append("</td>");
      sb.append("<td>").append(layers[i].l2).append("</td>");
      final String format="%g";
      sb.append("<td>").append(layers[i].momentum(train.training_samples)).append("</td>");
      sb.append("<td>(").append(String.format(format,mean_weight[i])).append(", ").append(String.format(format,rms_weight[i])).append(")</td>");
      sb.append("<td>(").append(String.format(format,mean_bias[i])).append(", ").append(String.format(format,rms_bias[i])).append(")</td>");
      sb.append("</tr>");
    }
    sb.append("</table>");
  }
  if (unstable) {
    final String msg="Job was aborted due to observed numerical instability (exponential growth)." + "  Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.";
    DocGen.HTML.section(sb,"=======================================================================================");
    DocGen.HTML.section(sb,msg);
    DocGen.HTML.section(sb,"=======================================================================================");
  }
  if (confusion_matrix != null && confusion_matrix.length < 100) {
    assert(classification);
    String[] classes=classNames();
    confusion(sb,cmTitle,classes,confusion_matrix);
  }
  sb.append("<h3>" + "Progress" + "</h3>");
  String training="Number of training set samples for scoring: " + train.score_training;
  if (train.score_training > 0) {
    if (train.score_training < 1000)     training+=" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)";
    if (train.score_training > 10000)     training+=" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)";
  }
  DocGen.HTML.section(sb,training);
  if (valid != null) {
    String validation="Number of validation set samples for scoring: " + valid.score_validation;
    if (valid.score_validation > 0) {
      if (valid.score_training < 1000)       training+=" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)";
      if (valid.score_training > 10000)       training+=" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)";
    }
    DocGen.HTML.section(sb,validation);
  }
  sb.append("<table class='table table-striped table-bordered table-condensed'>");
  sb.append("<tr>");
  sb.append("<th>Training Time</th>");
  sb.append("<th>Training Samples</th>");
  sb.append("<th>Training MSE</th>");
  if (classification) {
    sb.append("<th>Training MCE</th>");
    sb.append("<th>Training Classification Error</th>");
  }
  sb.append("<th>Validation MSE</th>");
  if (classification) {
    sb.append("<th>Validation MCE</th>");
    sb.append("<th>Validation Classification Error</th>");
  }
  sb.append("</tr>");
  for (int i=training_errors.length - 1; i >= 0; i--) {
    sb.append("<tr>");
    sb.append("<td>" + PrettyPrint.msecs(training_errors[i].training_time_ms,true) + "</td>");
    if (validation_errors != null) {
      sb.append("<td>" + String.format("%,d",validation_errors[i].training_samples) + "</td>");
    }
 else {
      sb.append("<td>" + String.format("%,d",training_errors[i].training_samples) + "</td>");
    }
    sb.append("<td>" + String.format(mse_format,training_errors[i].mean_square) + "</td>");
    if (classification) {
      sb.append("<td>" + String.format(cross_entropy_format,training_errors[i].cross_entropy) + "</td>");
      sb.append("<td>" + formatPct(training_errors[i].classification) + "</td>");
    }
    if (validation_errors != null) {
      sb.append("<td>" + String.format(mse_format,validation_errors[i].mean_square) + "</td>");
      if (classification) {
        sb.append("<td>" + String.format(cross_entropy_format,validation_errors[i].cross_entropy) + "</td>");
        sb.append("<td>" + formatPct(validation_errors[i].classification) + "</td>");
      }
    }
 else     sb.append("<td></td><td></td><td></td>");
    sb.append("</tr>");
  }
  sb.append("</table>");
  return true;
}
