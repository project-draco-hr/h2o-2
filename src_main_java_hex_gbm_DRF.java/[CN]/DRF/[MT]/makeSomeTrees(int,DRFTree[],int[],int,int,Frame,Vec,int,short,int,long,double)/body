{
  for (int depth=0; depth < maxDepth; depth++) {
    Timer t_pass=new Timer();
    ScoreBuildHistogram sbh=new ScoreBuildHistogram(trees,leafs,ncols,nclass,ymin,fr).doAll(fr);
    for (int t=0; t < ntrees; t++) {
      final int tmax=trees[t]._len;
      final DTree tree=trees[t];
      long sum=0;
      for (int i=leafs[t]; i < tmax; i++) {
        DHistogram hs[]=sbh.getFinalHisto(t,i);
        tree.undecided(i)._hs=hs;
        for (        DHistogram h : hs)         if (h != null)         sum+=h.byteSize();
      }
    }
    boolean still_splitting=false;
    for (int t=0; t < ntrees; t++) {
      final DTree tree=trees[t];
      final int tmax=tree._len;
      int leaf=leafs[t];
      for (; leaf < tmax; leaf++) {
        new DRFDecidedNode((DRFUndecidedNode)tree.undecided(leaf));
      }
      leafs[t]=leaf;
      if (tmax < tree._len)       still_splitting=true;
    }
    if (!still_splitting)     return depth;
  }
  return maxDepth;
}
