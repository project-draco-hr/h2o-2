{
  final DTree[] ktrees=new DTree[_nclass];
  for (int k=0; k < _nclass; k++) {
    if (_distribution[k] != 0) {
      ktrees[k]=new DRFTree(fr,_ncols,(char)nbins,(char)_nclass,min_rows,mtrys,rand.nextLong());
      new DRFUndecidedNode(ktrees[k],-1,DBinHistogram.initialHist(fr,_ncols,(char)nbins));
    }
  }
  for (int k=0; k < _nclass; k++) {
    if (ktrees[k] != null)     new Sample(((DRFTree)ktrees[k]),sample_rate).doAll(vec_nids(fr,k));
  }
  int[] leafs=new int[_nclass];
  int depth=0;
  for (; depth < max_depth; depth++) {
    if (cancelled())     return null;
    ScoreBuildHistogram sbh=new ScoreBuildHistogram(ktrees,leafs).doAll(fr);
    boolean did_split=false;
    for (int k=0; k < _nclass; k++) {
      DTree tree=ktrees[k];
      if (tree == null)       continue;
      int tmax=tree._len;
      for (int leaf=leafs[k]; leaf < tmax; leaf++) {
        UndecidedNode udn=tree.undecided(leaf);
        udn._hs=sbh.getFinalHisto(k,leaf);
        DRFDecidedNode dn=new DRFDecidedNode((DRFUndecidedNode)udn);
        if (dn._split._col == -1)         udn.do_not_split();
 else         did_split=true;
      }
      leafs[k]=tmax;
    }
    if (!did_split)     break;
  }
  for (int k=0; k < _nclass; k++) {
    DTree tree=ktrees[k];
    if (tree == null)     continue;
    int leaf=leafs[k]=tree._len;
    for (int nid=0; nid < leaf; nid++) {
      if (tree.node(nid) instanceof DecidedNode) {
        DecidedNode dn=tree.decided(nid);
        for (int i=0; i < dn._nids.length; i++) {
          int cnid=dn._nids[i];
          if (cnid == -1 || tree.node(cnid) instanceof UndecidedNode || (tree.node(cnid) instanceof DecidedNode && ((DecidedNode)tree.node(cnid))._split._col == -1)) {
            DRFLeafNode nleaf=new DRFLeafNode(tree,nid);
            dn._nids[i]=nleaf._nid;
          }
        }
        if (nid == 0 && dn._split._col == -1)         new DRFLeafNode(tree,-1,0);
      }
    }
  }
  CollectPreds gp=new CollectPreds(ktrees,leafs).doAll(fr);
  for (int k=0; k < _nclass; k++) {
    final DTree tree=ktrees[k];
    if (tree == null)     continue;
    for (int i=0; i < tree._len - leafs[k]; i++) {
      ((LeafNode)tree.node(leafs[k] + i))._pred=gp._votes[k][i];
      ;
    }
  }
  new MRTask2(){
    @Override public void map(    Chunk chks[]){
      for (int k=0; k < _nclass; k++) {
        final DTree tree=ktrees[k];
        if (tree == null)         continue;
        final Chunk nids=chk_nids(chks,k);
        final Chunk ct=chk_tree(chks,k);
        for (int row=0; row < nids._len; row++) {
          int nid=(int)nids.at80(row);
          if (isOOBRow(nid)) {
            nid=oob2Nid(nid);
            ct.set0(row,(float)(ct.at0(row) + ((LeafNode)tree.node(nid))._pred));
          }
          nids.set0(row,0);
        }
      }
    }
  }
.doAll(fr);
  printGenerateTrees(ktrees);
  return ktrees;
}
