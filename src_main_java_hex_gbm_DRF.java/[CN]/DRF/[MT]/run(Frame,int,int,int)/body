{
  Timer t_drf=new Timer();
  final String names[]=fr._names;
  Vec vs[]=fr._vecs;
  final int ncols=vs.length - 1;
  Vec vresponse=vs[ncols];
  final long nrows=vresponse.length();
  int ymin=(int)vresponse.min();
  int numClasses=vresponse._isInt ? ((int)vresponse.max() - ymin + 1) : 0;
  Random rand=new MersenneTwisterRNG(new int[]{1,2});
  Histogram hs[]=Histogram.initialHist(fr,ncols);
  DRFTree trees[]=new DRFTree[ntrees];
  for (int t=0; t < ntrees; t++) {
    trees[t]=new DRFTree(names,mtrys,rand);
    new UndecidedNode(trees[t],-1,hs);
    fr.add("NIDs" + t,Vec.makeZero(vs[0]));
  }
  int leafs[]=new int[ntrees];
  int depth=0;
  for (; depth < maxDepth; depth++) {
    ScoreBuildHistogram sbh=new ScoreBuildHistogram(trees,leafs,ncols,numClasses,ymin).doAll(fr);
    for (int t=0; t < ntrees; t++) {
      final int tmax=trees[t]._len;
      final DTree tree=trees[t];
      for (int i=leafs[t]; i < tmax; i++)       tree.undecided(i)._hs=sbh.getFinalHisto(t,i);
    }
    boolean still_splitting=false;
    for (int t=0; t < ntrees; t++) {
      final DTree tree=trees[t];
      final int tmax=tree._len;
      int leaf=leafs[t];
      for (; leaf < tmax; leaf++) {
        new DRFDecidedNode(tree.undecided(leaf));
      }
      leafs[t]=leaf;
      if (tmax < tree._len)       still_splitting=true;
    }
    if (!still_splitting)     break;
    new BulkScore(trees,ncols,numClasses,ymin).doAll(fr).report(Sys.DRF__,nrows,depth);
  }
  Log.info(Sys.DRF__,"DRF done in " + t_drf);
  Timer t_score=new Timer();
  new BulkScore(trees,ncols,numClasses,ymin).doAll(fr).report(Sys.DRF__,nrows,depth);
  Log.info(Sys.DRF__,"DRF score done in " + t_score);
  while (fr.numCols() > ncols + 1)   UKV.remove(fr.remove(fr.numCols() - 1)._key);
}
