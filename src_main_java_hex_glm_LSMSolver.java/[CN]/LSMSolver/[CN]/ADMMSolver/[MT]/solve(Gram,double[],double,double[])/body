{
  final int N=xy.length;
  Arrays.fill(z,0);
  if (_lambda > 0) {
    gram.addDiag(_lambda * (1 - _alpha) * 0.5);
    if (_alpha > 0)     gram.addDiag(_rho,true);
  }
  int attempts=0;
  Cholesky chol=gram.cholesky(null);
  while (!chol.isSPD() && attempts < 10) {
    _rho*=8;
    ++attempts;
    gram.addDiag(_rho,true);
    gram.cholesky(chol);
  }
  if (!chol.isSPD()) {
    if (xy.length < 1000)     System.out.println(Utils.pprint(gram.getXX()));
 else     System.out.println("NON SPD matrix of dimension " + xy.length);
    throw new NonSPDMatrixException();
  }
  if (_alpha == 0 || _lambda == 0) {
    System.arraycopy(xy,0,z,0,xy.length);
    chol.solve(z);
    return _converged=true;
  }
  final double ABSTOL=Math.sqrt(N) * 1e-4;
  final double RELTOL=1e-2;
  double[] u=MemoryManager.malloc8d(N);
  double[] xyPrime=xy.clone();
  double kappa=_lambda * _alpha / _rho;
  for (int i=0; i < 1000; ++i) {
    for (int j=0; j < N - 1; ++j)     xyPrime[j]=xy[j] + _rho * (z[j] - u[j]);
    xyPrime[N - 1]=xy[N - 1];
    chol.solve(xyPrime);
    double x_norm=0;
    double z_norm=0;
    double u_norm=0;
    double r_norm=0;
    double s_norm=0;
    double eps_pri=0;
    double eps_dual=0;
    for (int j=0; j < N - 1; ++j) {
      double x_hat=xyPrime[j];
      x_norm+=x_hat * x_hat;
      x_hat=x_hat * _orlx + (1 - _orlx) * z[j];
      double zold=z[j];
      z[j]=shrinkage(x_hat + u[j],kappa);
      z_norm+=z[j] * z[j];
      s_norm+=(z[j] - zold) * (z[j] - zold);
      r_norm+=(xyPrime[j] - z[j]) * (xyPrime[j] - z[j]);
      u[j]+=x_hat - z[j];
      u_norm+=u[j] * u[j];
    }
    z[N - 1]=xyPrime[N - 1];
    r_norm=Math.sqrt(r_norm);
    s_norm=_rho * Math.sqrt(s_norm);
    eps_pri=ABSTOL + RELTOL * Math.sqrt(Math.max(x_norm,z_norm));
    eps_dual=ABSTOL + _rho * RELTOL * Math.sqrt(u_norm);
    if (r_norm < eps_pri && s_norm < eps_dual)     return _converged=true;
  }
  return false;
}
