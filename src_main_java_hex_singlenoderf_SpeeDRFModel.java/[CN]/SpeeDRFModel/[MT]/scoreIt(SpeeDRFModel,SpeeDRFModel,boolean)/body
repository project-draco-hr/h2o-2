{
  Futures fs=new Futures();
  final CMTask[] cmTask=new CMTask[1];
  final SpeeDRFModel score_model=(SpeeDRFModel)m.clone();
  H2O.H2OCountedCompleter task4var=new H2O.H2OCountedCompleter(){
    @Override public void compute2(){
      cmTask[0]=CMTask.scoreTask(score_model.test_frame == null ? score_model.fr : score_model.test_frame,score_model,score_model.size(),score_model.weights,score_model.oobee,score_model._priorClassDist,score_model._modelClassDist,score_new_only);
      tryComplete();
    }
  }
;
  H2O.submitTask(task4var);
  fs.add(task4var);
  fs.blockForPending();
  if (m.regression) {
    float mse=cmTask[0]._ss / ((float)(cmTask[0]._rowcnt));
    m.errs=Arrays.copyOf(old.errs,old.errs.length + 1);
    m.errs[m.errs.length - 1]=mse;
    m.cms=Arrays.copyOf(old.cms,old.cms.length + 1);
    m.cms[m.cms.length - 1]=null;
  }
 else   if (!score_new_only) {
    _domain=cmTask[0].domain();
    m.confusion=CMTask.CMFinal.make(cmTask[0]._matrix,m,cmTask[0].domain(),cmTask[0]._errorsPerTree,m.oobee,cmTask[0]._sum,cmTask[0]._cms);
    m.cm=cmTask[0]._matrix._matrix;
    m.errorsPerTree=cmTask[0]._errorsPerTree;
    m.errs=Arrays.copyOf(old.errs,old.errs.length + 1);
    m.errs[m.errs.length - 1]=m.confusion.mse();
    m.cms=Arrays.copyOf(old.cms,old.cms.length + 1);
    ConfusionMatrix new_cm=new ConfusionMatrix(m.confusion._matrix);
    m.cms[m.cms.length - 1]=new_cm;
    if (m.classes() == 2) {
      m.validAUC=makeAUC(toCMArray(m.confusion._cms),ModelUtils.DEFAULT_THRESHOLDS,m.cmDomain);
    }
    if (m.importance && !m.regression)     m.varimp=m.doVarImpCalc(m);
  }
 else {
    m.errorsPerTree=old.errorsPerTree == null ? cmTask[0]._errorsPerTree : Arrays.copyOf(old.errorsPerTree,old.errorsPerTree.length + 1);
    m.errorsPerTree[m.errorsPerTree.length - 1]=cmTask[0]._errorsPerTree[cmTask[0]._errorsPerTree.length - 1];
    m.errs=Arrays.copyOf(old.errs,old.errs.length + 1);
    m.errs[m.errs.length - 1]=-1.f;
    m.cms=Arrays.copyOf(old.cms,old.cms.length + 1);
    m.cms[m.cms.length - 1]=null;
  }
}
