{
  DeepLearningModel cp=null;
  if (checkpoint == null) {
    cp=initModel();
    cp.start_training(null);
  }
 else {
    final DeepLearningModel previous=UKV.get(checkpoint);
    if (previous == null)     throw new IllegalArgumentException("Checkpoint not found.");
    Log.info("Resuming from checkpoint.");
    if (source == null || !Arrays.equals(source._key._kb,previous.model_info().get_params().source._key._kb)) {
      throw new IllegalArgumentException("source must be the same as for the checkpointed model.");
    }
    if (response == null || !Arrays.equals(response._key._kb,previous.model_info().get_params().response._key._kb)) {
      throw new IllegalArgumentException("response must be the same as for the checkpointed model.");
    }
    if (Utils.difference(ignored_cols,previous.model_info().get_params().ignored_cols).length != 0 || Utils.difference(previous.model_info().get_params().ignored_cols,ignored_cols).length != 0) {
      ignored_cols=previous.model_info().get_params().ignored_cols;
      Log.warn("Automatically re-using ignored_cols from the checkpointed model.");
    }
    if ((validation != null) != (previous.model_info().get_params().validation != null) || (validation != null && validation._key != null && previous.model_info().get_params().validation._key != null && !Arrays.equals(validation._key._kb,previous.model_info().get_params().validation._key._kb))) {
      throw new IllegalArgumentException("validation must be the same as for the checkpointed model.");
    }
    if (classification != previous.model_info().get_params().classification) {
      Log.warn("Automatically switching to " + ((classification=!classification) ? "classification" : "regression") + " (same as the checkpointed model).");
    }
    epochs+=previous.epoch_counter;
    Log.info("Adding " + String.format("%.3f",previous.epoch_counter) + " epochs from the checkpointed model.");
    try {
      final DataInfo dataInfo=prepareDataInfo();
      cp=new DeepLearningModel(previous,destination_key,job_key,dataInfo);
      cp.write_lock(self());
      cp.start_training(previous);
      assert(state == JobState.RUNNING);
      final DeepLearning mp=cp.model_info().get_params();
      Object A=mp, B=this;
      for (      Field fA : A.getClass().getDeclaredFields()) {
        if (Utils.contains(cp_modifiable,fA.getName())) {
          if (!expert_mode && Utils.contains(expert_options,fA.getName()))           continue;
          for (          Field fB : B.getClass().getDeclaredFields()) {
            if (fA.equals(fB)) {
              try {
                if (fB.get(B) == null || fA.get(A) == null || !fA.get(A).toString().equals(fB.get(B).toString())) {
                  if (fA.get(A) == null && fB.get(B) == null)                   continue;
                  Log.info("Applying user-requested modification of '" + fA.getName() + "': "+ fA.get(A)+ " -> "+ fB.get(B));
                  fA.set(A,fB.get(B));
                }
              }
 catch (              IllegalAccessException e) {
                e.printStackTrace();
              }
            }
          }
        }
      }
      cp.update(self());
    }
  finally {
      if (cp != null)       cp.unlock(self());
    }
  }
  trainModel(cp);
  cp.stop_training();
  delete();
}
