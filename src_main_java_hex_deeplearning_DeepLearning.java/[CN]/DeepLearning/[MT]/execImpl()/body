{
  DeepLearningModel cp;
  if (checkpoint == null)   cp=initModel();
 else {
    final DeepLearningModel previous=UKV.get(checkpoint);
    cp=new DeepLearningModel(previous,destination_key,job_key);
    try {
      cp.write_lock(self());
      assert(state == JobState.RUNNING);
      if (source == null || source._key != previous.model_info().get_params().source._key) {
        throw new IllegalArgumentException("source must be the same as for the checkpointed model.");
      }
      if (response == null || response._key != previous.model_info().get_params().response._key) {
        throw new IllegalArgumentException("response must be the same as for the checkpointed model.");
      }
      if (Utils.difference(ignored_cols,previous.model_info().get_params().ignored_cols).length != 0) {
        throw new IllegalArgumentException("ignored_cols must be the same as for the checkpointed model.");
      }
      if ((validation != null) != (previous.model_info().get_params().validation != null) || (validation != null && validation._key != previous.model_info().get_params().validation._key)) {
        throw new IllegalArgumentException("validation must be the same as for the checkpointed model.");
      }
      if (classification != previous.model_info().get_params().classification) {
        throw new IllegalArgumentException("classification must be the same as for the checkpointed model.");
      }
      cp.model_info().get_params().expert_mode=expert_mode;
      cp.model_info().get_params().seed=seed;
      cp.model_info().get_params().epochs=previous.epoch_counter + epochs;
      cp.model_info().get_params().score_interval=score_interval;
      cp.model_info().get_params().score_duty_cycle=score_duty_cycle;
      cp.model_info().get_params().quiet_mode=quiet_mode;
      cp.model_info().get_params().diagnostics=diagnostics;
      cp.update(self());
    }
  finally {
      cp.unlock(self());
    }
  }
  trainModel(cp);
  delete();
  return JobState.DONE;
}
