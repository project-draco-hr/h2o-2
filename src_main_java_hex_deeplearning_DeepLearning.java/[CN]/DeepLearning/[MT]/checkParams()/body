{
  if (source.numCols() <= 1)   throw new IllegalArgumentException("Training data must have at least 2 features (incl. response).");
  if (hidden == null)   throw new IllegalArgumentException("There must be at least one hidden layer.");
  for (int i=0; i < hidden.length; ++i) {
    if (hidden[i] == 0)     throw new IllegalArgumentException("Hidden layer size must be >0.");
  }
  if (hidden_dropout_ratios == null) {
    hidden_dropout_ratios=new double[hidden.length];
    if (activation == Activation.TanhWithDropout || activation == Activation.MaxoutWithDropout || activation == Activation.RectifierWithDropout) {
      Arrays.fill(hidden_dropout_ratios,0.5);
    }
  }
 else   if (hidden_dropout_ratios.length != hidden.length)   throw new IllegalArgumentException("Must have " + hidden.length + " hidden layer dropout ratios.");
  if (replicate_training_data && (mini_batch >= source.numRows() * H2O.CLOUD.size()) && !shuffle_training_data) {
    Log.warn("Enabling training data shuffling, because all nodes train on the full dataset (replicated training data)");
    shuffle_training_data=true;
  }
  if (!classification && loss != Loss.MeanSquare) {
    Log.warn("Setting loss to MeanSquare for regression.");
    loss=Loss.MeanSquare;
  }
  if (dest() == null) {
    destination_key=Key.make();
  }
  if (self() == null) {
    job_key=Key.make();
  }
  if (UKV.get(self()) == null) {
    start_time=System.currentTimeMillis();
    state=JobState.RUNNING;
    UKV.put(self(),this);
    _fakejob=true;
  }
}
