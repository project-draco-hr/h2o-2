{
  if (use_start_column && !start_column.isInt())   throw new IllegalArgumentException("start time must be null or of type integer");
  if (!stop_column.isInt())   throw new IllegalArgumentException("stop time must be of type integer");
  if (!event_column.isInt() && !event_column.isEnum())   throw new IllegalArgumentException("event must be of type integer or factor");
  Vec[] cols;
  if (use_start_column) {
    cols=new Vec[4];
    cols[0]=start_column;
    cols[1]=stop_column;
    cols[2]=event_column;
    cols[3]=x_column;
  }
 else {
    cols=new Vec[3];
    cols[0]=stop_column;
    cols[1]=event_column;
    cols[2]=x_column;
  }
  if (use_start_column)   min_time=(long)start_column.min() + 1;
 else   min_time=(long)stop_column.min();
  max_time=(long)stop_column.max();
  int n_time=(int)(max_time - min_time + 1);
  x_mean=x_column.mean();
  cumhaz=MemoryManager.malloc8d(n_time);
  se_cumhaz=MemoryManager.malloc8d(n_time);
  surv=MemoryManager.malloc8d(n_time);
  double[] se_term=MemoryManager.malloc8d(n_time);
  int i, t;
  double step=Double.NaN;
  double oldCoef=Double.NaN;
  double oldLoglik=-Double.MAX_VALUE;
  double newCoef=0;
  double newLoglik;
  for (i=0; i < 100; i++) {
    iter=i + 1;
    CoxphFitTask cox1=new CoxphFitTask(newCoef,min_time,n_time,use_start_column,x_mean).doAll(cols);
    if (!use_start_column) {
      for (t=n_time - 2; t >= 0; t--) {
        cox1.rcumsumRisk[t]+=cox1.rcumsumRisk[t + 1];
        cox1.rcumsumXRisk[t]+=cox1.rcumsumXRisk[t + 1];
        cox1.rcumsumXXRisk[t]+=cox1.rcumsumXXRisk[t + 1];
      }
    }
    if (i == 0) {
      n=cox1.n;
      for (t=0; t < n_time; t++)       total_event+=cox1.countEvents[t];
      n_risk=cox1.countRiskSet.clone();
      n_event=cox1.countEvents.clone();
      n_censor=cox1.countCensored.clone();
      if (!use_start_column)       for (t=n_time - 2; t >= 0; t--)       n_risk[t]+=n_risk[t + 1];
    }
    newLoglik=0;
    gradient=0;
    hessian=0;
    for (t=n_time - 1; t >= 0; t--) {
      if (cox1.countEvents[t] > 0) {
        newLoglik+=cox1.sumLogRiskEvents[t];
        gradient+=cox1.sumXEvents[t];
        double gamma=cox1.rcumsumXRisk[t] / cox1.rcumsumRisk[t];
        newLoglik-=cox1.countEvents[t] * Math.log(cox1.rcumsumRisk[t]);
        gradient-=cox1.countEvents[t] * gamma;
        hessian-=cox1.countEvents[t] * (((cox1.rcumsumXXRisk[t] / cox1.rcumsumRisk[t]) - (gamma * (cox1.rcumsumXRisk[t] / cox1.rcumsumRisk[t]))));
      }
    }
    if (i == 0)     null_loglik=newLoglik;
    if (newLoglik > oldLoglik) {
      coef=newCoef;
      exp_coef=Math.exp(coef);
      exp_neg_coef=Math.exp(-coef);
      var_coef=-1 / hessian;
      se_coef=Math.sqrt(var_coef);
      z_coef=coef / se_coef;
      loglik=newLoglik;
      loglik_test=-2 * (null_loglik - loglik);
      wald_test=coef * coef / var_coef;
      if (i == 0)       score_test=-gradient * gradient / hessian;
      for (t=0; t < n_time; t++) {
        cumhaz[t]=cox1.countEvents[t] / cox1.rcumsumRisk[t];
        se_cumhaz[t]=cox1.countEvents[t] / (cox1.rcumsumRisk[t] * cox1.rcumsumRisk[t]);
        se_term[t]=(cox1.rcumsumXRisk[t] / cox1.rcumsumRisk[t]) * cumhaz[t];
      }
      for (t=1; t < n_time; t++) {
        cumhaz[t]=cumhaz[t - 1] + cumhaz[t];
        se_cumhaz[t]=se_cumhaz[t - 1] + se_cumhaz[t];
        se_term[t]=se_term[t - 1] + se_term[t];
      }
      for (t=0; t < n_time; t++) {
        se_cumhaz[t]=Math.sqrt(se_cumhaz[t] + (se_term[t] * var_coef * se_term[t]));
        surv[t]=Math.exp(-cumhaz[t]);
      }
      if (newLoglik == 0)       lre=-Math.log10(Math.abs(oldLoglik - newLoglik));
 else       lre=-Math.log10(Math.abs((oldLoglik - newLoglik) / newLoglik));
      if (lre > 9)       break;
      step=gradient / hessian;
      if (Double.isNaN(step) || Double.isInfinite(step))       break;
      oldCoef=newCoef;
      oldLoglik=newLoglik;
    }
 else     step/=2;
    newCoef=oldCoef - step;
  }
  return Response.done(this);
}
