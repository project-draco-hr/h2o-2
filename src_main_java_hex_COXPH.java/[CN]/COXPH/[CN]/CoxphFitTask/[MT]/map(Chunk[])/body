{
  Chunk start, stop, events, xs;
  if (_use_start_column) {
    start=cols[0];
    stop=cols[1];
    events=cols[2];
    xs=cols[3];
  }
 else {
    start=null;
    stop=cols[0];
    events=cols[1];
    xs=cols[2];
  }
  int i, t, t1=-1, t2;
  long start_i, stop_i, event_i;
  double x_i, xbeta_i, expXBeta_i, xExpXBeta_i, xxExpXBeta_i;
  countRisk=MemoryManager.malloc8(_n_time);
  countCensored=MemoryManager.malloc8(_n_time);
  countEvents=MemoryManager.malloc8(_n_time);
  sumXEvents=MemoryManager.malloc8d(_n_time);
  sumXBetaEvents=MemoryManager.malloc8d(_n_time);
  cumsumExpXBeta=MemoryManager.malloc8d(_n_time);
  cumsumXExpXBeta=MemoryManager.malloc8d(_n_time);
  cumsumXXExpXBeta=MemoryManager.malloc8d(_n_time);
  for (i=0; i < stop._len; i++) {
    event_i=events.at80(i);
    stop_i=stop.at80(i);
    t2=(int)(stop_i - _min_time);
    if (_use_start_column) {
      start_i=start.at80(i);
      if (start_i >= stop_i)       throw new IllegalArgumentException("start values must be strictly less than stop values");
      t1=(int)((start_i + 1) - _min_time);
    }
    x_i=xs.at0(i) - _x_mean;
    if (!Double.isNaN(x_i)) {
      xbeta_i=x_i * _beta;
      expXBeta_i=Math.exp(xbeta_i);
      xExpXBeta_i=x_i * expXBeta_i;
      xxExpXBeta_i=x_i * xExpXBeta_i;
      n++;
      if (event_i > 0) {
        countEvents[t2]++;
        sumXEvents[t2]+=x_i;
        sumXBetaEvents[t2]+=xbeta_i;
      }
 else       countCensored[t2]++;
      if (_use_start_column) {
        for (t=t1; t <= t2; t++) {
          countRisk[t]++;
          cumsumExpXBeta[t]+=expXBeta_i;
          cumsumXExpXBeta[t]+=xExpXBeta_i;
          cumsumXXExpXBeta[t]+=xxExpXBeta_i;
        }
      }
 else {
        countRisk[t2]++;
        cumsumExpXBeta[t2]+=expXBeta_i;
        cumsumXExpXBeta[t2]+=xExpXBeta_i;
        cumsumXXExpXBeta[t2]+=xxExpXBeta_i;
      }
    }
  }
}
