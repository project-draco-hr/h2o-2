{
  try {
    if (fs == null)     return;
    for (    FileStatus file : fs.listStatus(p)) {
      Path pfs=file.getPath();
      if (file.isDir()) {
        addFolder(fs,pfs,succeeded,failed);
      }
 else {
        Key k=Key.make(pfs.toString());
        long size=file.getLen();
        Value val=null;
        if (pfs.getName().endsWith(Extensions.JSON)) {
          JsonParser parser=new JsonParser();
          JsonObject json=parser.parse(new InputStreamReader(fs.open(pfs))).getAsJsonObject();
          JsonElement v=json.get(Constants.VERSION);
          if (v == null)           throw new InvalidDataException("Missing version");
          JsonElement type=json.get(Constants.TYPE);
          if (type == null)           throw new InvalidDataException("Missing type");
          Class c=Class.forName(type.getAsString());
          Model model=(Model)c.newInstance();
          model.fromJson(json);
        }
 else         if (pfs.getName().endsWith(Extensions.HEX)) {
          FSDataInputStream s=fs.open(pfs);
          int sz=(int)Math.min(1L << 20,size);
          byte[] mem=MemoryManager.malloc1(sz);
          s.readFully(mem);
          ValueArray ary=new ValueArray(k,0).read(new AutoBuffer(mem));
          val=new Value(k,ary,Value.HDFS);
        }
 else         if (size >= 2 * ValueArray.CHUNK_SZ) {
          val=new Value(k,new ValueArray(k,size),Value.HDFS);
        }
 else {
          val=new Value(k,(int)size,Value.HDFS);
        }
        val.setdsk();
        DKV.put(k,val);
        JsonObject o=new JsonObject();
        o.addProperty(Constants.KEY,k.toString());
        o.addProperty(Constants.FILE,pfs.toString());
        o.addProperty(Constants.VALUE_SIZE,file.getLen());
        succeeded.add(o);
      }
    }
  }
 catch (  Exception e) {
    Log.err(e);
    JsonObject o=new JsonObject();
    o.addProperty(Constants.FILE,p.toString());
    o.addProperty(Constants.ERROR,e.getMessage());
    failed.add(o);
  }
}
