{
  Vec va=null, vp=null, avp=null;
  if (vactual == null || vpredict == null)   throw new IllegalArgumentException("Missing actual or predict!");
  if (!vactual.isInt() || !vpredict.isInt())   throw new IllegalArgumentException("Cannot provide confusion matrix for float vectors!");
  if (vactual.length() != vpredict.length())   throw new IllegalArgumentException("Both arguments must have the same length!");
  try {
    va=vactual.toEnum();
    actual_domain=va._domain;
    vp=vpredict.toEnum();
    predicted_domain=vp._domain;
    if (!Arrays.equals(actual_domain,predicted_domain)) {
      domain=Utils.union(actual_domain,predicted_domain);
      int[][] vamap=Model.getDomainMapping(domain,actual_domain,true);
      va=TransfVec.compose((TransfVec)va,vamap,domain,false);
      int[][] vpmap=Model.getDomainMapping(domain,predicted_domain,true);
      vp=TransfVec.compose((TransfVec)vp,vpmap,domain,false);
    }
 else     domain=actual_domain;
    if (!va.group().equals(vp.group())) {
      avp=vp;
      vp=va.align(vp);
    }
    cm=new CM(domain.length).doAll(va,vp)._cm;
    return Response.done(this);
  }
 catch (  Throwable t) {
    return Response.error(t);
  }
 finally {
    if (va != null)     UKV.remove(va._key);
    if (vp != null)     UKV.remove(vp._key);
    if (avp != null)     UKV.remove(avp._key);
  }
}
