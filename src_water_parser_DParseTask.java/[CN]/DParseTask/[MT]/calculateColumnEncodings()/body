{
  assert(_bases != null);
  assert(_min != null);
  for (int i=0; i < _ncolumns; ++i) {
switch (_colTypes[i]) {
case UCOL:
      _colTypes[i]=BYTE;
    break;
case ECOL:
  if (_enums[i] == null || _enums[i].isKilled()) {
    _max[i]=0;
    _min[i]=0;
    _colTypes[i]=STRINGCOL;
  }
 else {
    _max[i]=_colDomains[i].length - 1;
    _min[i]=0;
    if (_max[i] < 256)     _colTypes[i]=BYTE;
 else     if (_max[i] < 65536)     _colTypes[i]=SHORT;
 else     _colTypes[i]=INT;
  }
break;
case ICOL:
if (_max[i] - _min[i] < 255) {
_colTypes[i]=BYTE;
_bases[i]=(int)_min[i];
}
 else if ((_max[i] - _min[i]) < 65535) {
_colTypes[i]=SHORT;
_bases[i]=(int)_min[i];
}
 else if (_max[i] - _min[i] < (1l << 32)) {
_colTypes[i]=INT;
_bases[i]=(int)_min[i];
}
 else _colTypes[i]=LONG;
break;
case FCOL:
case DCOL:
if (_scale[i] >= -4 && (_max[i] <= powers10i[powers10i.length - 1]) && (_min[i] >= -powers10i[powers10i.length - 1])) {
double s=pow10(-_scale[i]);
double range=s * (_max[i] - _min[i]);
double base=s * _min[i];
if (range < 256) {
if (fitsIntoInt(base)) {
_colTypes[i]=DBYTE;
_bases[i]=(int)base;
break;
}
}
 else if (range < 65535) {
if (fitsIntoInt(base)) {
_colTypes[i]=DSHORT;
_bases[i]=(int)(base);
break;
}
}
}
_scale[i]=0;
_bases[i]=0;
_colTypes[i]=(_colTypes[i] == FCOL) ? FLOAT : DOUBLE;
break;
case TCOL:
_scale[i]=-1;
_bases[i]=0;
_min[i]=0.0;
_max[i]=System.currentTimeMillis();
_colTypes[i]=LONG;
break;
default :
throw H2O.unimpl();
}
}
}
