{
  Key file=NFSFileVec.make(find_test_file("smalldata/./logreg/prostate.csv"));
  Frame frame=ParseDataset2.parse(Key.make(),new Key[]{file});
  Key dest=Key.make("prostate");
{
    DeepLearning p=new DeepLearning();
    p.epochs=35;
    p.source=frame;
    p.validation=frame;
    p.response=frame.vecs()[1];
    p.destination_key=dest;
    p.seed=0xC01DF337;
    p.force_load_balance=true;
    p.shuffle_training_data=true;
    p.score_training_samples=100;
    DeepLearningModel mymodel=p.initModel();
    p.trainModel(mymodel);
    p.trainModel(mymodel,p.epochs);
    p.trainModel(mymodel,p.epochs);
    p.delete();
  }
{
    DeepLearningModel mymodel=UKV.get(dest);
    Frame pred=mymodel.score(frame);
    StringBuilder sb=new StringBuilder();
    AUC auc=new AUC();
    auc.actual=frame;
    auc.vactual=frame.vecs()[1];
    auc.predict=pred;
    auc.vpredict=pred.vecs()[2];
    auc.threshold_criterion=AUC.ThresholdCriterion.maximum_F1;
    auc.serve();
    auc.toASCII(sb);
    final double threshold=auc.threshold();
    final double error=auc.err();
    Log.info(sb);
    Assert.assertEquals(new ConfusionMatrix(auc.cm()).err(),error,1e-15);
    Assert.assertEquals(mymodel.calcError(frame,pred,"training",false,null,auc),error,1e-15);
    double CMerrorOrig;
{
      sb=new StringBuilder();
      water.api.ConfusionMatrix CM=new water.api.ConfusionMatrix();
      CM.actual=frame;
      CM.vactual=frame.vecs()[1];
      CM.predict=pred;
      CM.vpredict=pred.vecs()[0];
      CM.serve();
      sb.append("\n");
      CM.toASCII(sb);
      Log.info(sb);
      CMerrorOrig=new ConfusionMatrix(CM.cm).err();
    }
{
      Frame pred2=new Frame(Key.make("pred2"),pred.names(),pred.vecs());
      pred2.delete_and_lock(null);
      pred2.unlock(null);
      Env ev=Exec2.exec("pred2[,1]=pred2[,3]>=" + 0.5);
      pred2=ev.popAry();
      ev.subRef(pred2,"pred2");
      ev.remove_and_unlock();
      water.api.ConfusionMatrix CM=new water.api.ConfusionMatrix();
      CM.actual=frame;
      CM.vactual=frame.vecs()[1];
      CM.predict=pred2;
      CM.vpredict=pred2.vecs()[0];
      CM.serve();
      sb=new StringBuilder();
      sb.append("\n");
      CM.toASCII(sb);
      Log.info(sb);
      double threshErr=new ConfusionMatrix(CM.cm).err();
      Assert.assertEquals(threshErr,CMerrorOrig,1e-15);
      ev=Exec2.exec("pred2[,1]=pred2[,3]>=" + threshold);
      pred2=ev.popAry();
      ev.subRef(pred2,"pred2");
      ev.remove_and_unlock();
      CM=new water.api.ConfusionMatrix();
      CM.actual=frame;
      CM.vactual=frame.vecs()[1];
      CM.predict=pred2;
      CM.vpredict=pred2.vecs()[0];
      CM.serve();
      sb=new StringBuilder();
      sb.append("\n");
      CM.toASCII(sb);
      Log.info(sb);
      double threshErr2=new ConfusionMatrix(CM.cm).err();
      Assert.assertEquals(threshErr2,error,1e-15);
      pred2.delete();
    }
    pred.delete();
    mymodel.delete();
  }
  frame.delete();
}
