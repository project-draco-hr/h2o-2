{
  final Key progressKey=Key.make();
  int maxChunks=2 * H2O.CLOUD.size() * H2O.NUMCPUS;
  int minChunks=H2O.CLOUD.size();
  int optChunks=(maxChunks + minChunks) >> 1;
  if (y.anyVec().nChunks() > maxChunks || y.anyVec().nChunks() < minChunks) {
    Log.info("rebalancing frame from " + y.anyVec().nChunks() + " chunks to "+ optChunks);
    y=new Frame(y.names(),RebalanceDataSet.rebalanceAndReplace(optChunks,100,y.vecs()));
  }
  Frame z=new Frame(x.anyVec().makeZeros(y.numCols()));
  DKV.put(progressKey,new MatrixMulStats(z.vecs().length * z.anyVec().nChunks()));
  Job j=new Job(Key.make(),progressKey){
    @Override public float progress(){
      MatrixMulStats p=DKV.get(progressKey).get();
      return p.progress();
    }
  }
;
  j.description=(x._key != null && y._key != null) ? (x._key + " %*% " + y._key) : "matrix multiplication";
  if (x.numCols() != y.numRows())   throw new IllegalArgumentException("dimensions do not match! x.numcols = " + x.numCols() + ", y.numRows = "+ y.numRows());
  j.start(new H2OEmptyCompleter());
  x=transpose(x,new Frame(y.anyVec().makeZeros((int)x.numRows())));
  x.reloadVecs();
  new MatrixMulTsk2(x,y,progressKey).doAll(z);
  z.reloadVecs();
  x.delete();
  j.remove();
  return z;
}
