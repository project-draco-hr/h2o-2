{
  _hcs=new DHistogram[_nclass][][];
  for (int k=0; k < _nclass; k++) {
    final DTree tree=_trees[k];
    if (tree == null)     continue;
    final int leaf=_leafs[k];
    final DHistogram hcs[][]=_hcs[k]=new DHistogram[tree._len - leaf][];
    final Chunk nids=chk_nids(chks,k);
    final Chunk wrks=chk_work(chks,k);
    for (int i=0; i < nids._len; i++) {
      int nid=(int)nids.at80(i);
      if (nid == -2)       continue;
      if (leaf > 0) {
        DTree.DecidedNode dn=tree.decided(nid);
        if (dn._split._col == -1)         nids.set0(i,(nid=dn._pid));
        nid=tree.decided(nid).ns(chks,i);
        if (nid != -1)         nids.set0(i,nid);
      }
      if (nid < leaf)       continue;
      DHistogram nhs[]=hcs[nid - leaf];
      if (nhs != null)       continue;
      nhs=hcs[nid - leaf]=new DHistogram[_ncols];
      DHistogram ohs[]=tree.undecided(nid)._hs;
      int sCols[]=tree.undecided(nid)._scoreCols;
      if (sCols != null) {
        for (int j=0; j < sCols.length; j++) {
          int idx=sCols[j];
          nhs[idx]=ohs[idx].bigCopy();
        }
        for (int j=0; j < nhs.length; j++)         if (ohs[j] != null && nhs[j] == null)         nhs[j]=ohs[j].smallCopy();
      }
 else {
        for (int j=0; j < nhs.length; j++)         if (ohs[j] != null)         nhs[j]=ohs[j].bigCopy();
      }
    }
    for (int row=0; row < nids._len; row++) {
      int nid=(int)nids.at80(row);
      if (nid < leaf)       continue;
      if (wrks.isNA0(row))       continue;
      DHistogram nhs[]=hcs[nid - leaf];
      double y=wrks.at0(row);
      for (int j=0; j < _ncols; j++) {
        DHistogram nh=nhs[j];
        if (nh == null)         continue;
        float col_data=(float)chks[j].at0(row);
        if (nh instanceof DBinHistogram)         ((DBinHistogram)nh).incr(row,col_data,y);
 else         nh.incr(col_data);
      }
    }
    for (    DHistogram dbh[] : hcs)     if (dbh != null)     for (int j=0; j < dbh.length; j++)     if (dbh[j] != null)     ((DBinHistogram)dbh[j]).fini();
  }
}
