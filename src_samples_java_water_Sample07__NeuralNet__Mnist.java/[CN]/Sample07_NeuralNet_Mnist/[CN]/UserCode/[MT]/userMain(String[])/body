{
  H2O.main(args);
  Frame train=TestUtil.parseFrame("smalldata/mnist/train.csv");
  Frame test=TestUtil.parseFrame("smalldata/mnist/test.csv.gz");
  System.out.println(train.anyVec().nChunks());
  Layer[] ls=new Layer[3];
  ls[0]=new FrameInput(train);
  ls[0].init(null,PIXELS);
  ls[1]=new Layer.Tanh();
  ls[2]=new Layer.Softmax();
  ls[1]._rate=.05f;
  ls[2]._rate=.02f;
  ls[1]._l2=.0001f;
  ls[2]._l2=.0001f;
  ls[1].init(ls[0],500);
  ls[2].init(ls[1],10);
  for (int i=1; i < ls.length; i++)   ls[i].randomize();
  final Trainer trainer=new Trainer.MR2(ls,0);
  Thread thread=new Thread(){
    @Override public void run(){
      trainer.run();
    }
  }
;
  thread.start();
  long start=System.nanoTime();
  long lastTime=start;
  long lastItems=0;
  for (; ; ) {
    try {
      Thread.sleep(3000);
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
    Layer[] clones1=Layer.clone(ls,train);
    Error trainE=NeuralNetScore.eval(clones1,NeuralNet.EVAL_ROW_COUNT);
    Layer[] clones2=Layer.clone(ls,test);
    Error testE=NeuralNetScore.eval(clones2,NeuralNet.EVAL_ROW_COUNT);
    long time=System.nanoTime();
    double delta=(time - lastTime) / 1e9;
    double total=(time - start) / 1e9;
    lastTime=time;
    long items=trainer.steps();
    int ps=(int)((items - lastItems) / delta);
    lastItems=items;
    String m=_format.format(total) + "s " + (ps)+ "/s, train: "+ trainE+ ", test: "+ testE;
    System.out.println(m);
  }
}
