{
  if (vec.length() - vec.naCnt() <= RESAMPLE_SZ) {
    int rs=0;
    _samples=new double[(int)(vec.length() - vec.naCnt())];
    for (int r=0; r < vec.length(); r++) {
      double v=vec.at(r);
      if (!Double.isNaN(v))       _samples[rs++]=v;
    }
    _samples=Arrays.copyOf(_samples,rs);
  }
  Arrays.sort(_samples);
  _pctile=new double[DEFAULT_PERCENTILES.length];
  for (int i=0; i < _pctile.length; i++)   _pctile[i]=quantile(DEFAULT_PERCENTILES[i]);
  computeMajorities();
  for (int i=0; i < _mins.length; i++) {
    if (Double.isNaN(_mins[i])) {
      _mins=Arrays.copyOf(_mins,i);
      break;
    }
  }
  for (int i=0; i < _maxs.length; i++) {
    if (Double.isNaN(_maxs[i])) {
      _maxs=Arrays.copyOf(_maxs,i);
      break;
    }
  }
  for (int i=0; i < _maxs.length >>> 1; i++) {
    double t=_maxs[i];
    _maxs[i]=_maxs[_maxs.length - 1 - i];
    _maxs[_maxs.length - 1 - i]=t;
  }
  this.stats=_type == T_ENUM ? new EnumStats(vec.domain().length) : new NumStats(vec.mean(),vec.sigma(),_zeros,_mins,_maxs,_pctile);
  if (_type == T_ENUM) {
    this.hstart=0;
    this.hstep=1;
    this.hbrk=_domain;
  }
 else {
    this.hstart=_start;
    this.hstep=_binsz;
    this.hbrk=new String[hcnt.length];
    for (int i=0; i < hbrk.length; i++)     hbrk[i]=Utils.p2d(i == 0 ? _start : binValue(i));
  }
}
