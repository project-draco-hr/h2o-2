{
  if (hcnt != null)   Utils.add(hcnt,other.hcnt);
  double merged[]=new double[_samples.length + other._samples.length];
  System.arraycopy(_samples,0,merged,0,_samples.length);
  System.arraycopy(other._samples,0,merged,_samples.length,other._samples.length);
  _samples=merged;
  if (_type == T_ENUM)   return this;
  double[] ds=MemoryManager.malloc8d(_mins.length);
  int i=0, j=0;
  for (int k=0; k < ds.length; k++)   if (_mins[i] < other._mins[j])   ds[k]=_mins[i++];
 else   if (Double.isNaN(other._mins[j]))   ds[k]=_mins[i++];
 else {
    if (_mins[i] == other._mins[j])     i++;
    ds[k]=other._mins[j++];
  }
  System.arraycopy(ds,0,_mins,0,ds.length);
  for (i=_maxs.length - 1; Double.isNaN(_maxs[i]); i--)   if (i == 0) {
    i--;
    break;
  }
  for (j=_maxs.length - 1; Double.isNaN(other._maxs[j]); j--)   if (j == 0) {
    j--;
    break;
  }
  ds=MemoryManager.malloc8d(i + j + 2);
  int k=0, ii=0, jj=0;
  while (ii <= i && jj <= j) {
    if (_maxs[ii] < other._maxs[jj])     ds[k]=_maxs[ii++];
 else     if (_maxs[ii] > other._maxs[jj])     ds[k]=other._maxs[jj++];
 else {
      ds[k]=_maxs[ii++];
      jj++;
    }
    k++;
  }
  while (ii <= i)   ds[k++]=_maxs[ii++];
  while (jj <= j)   ds[k++]=other._maxs[jj++];
  System.arraycopy(ds,Math.max(0,k - _maxs.length),_maxs,0,Math.min(k,_maxs.length));
  for (int t=k; t < _maxs.length; t++)   _maxs[t]=Double.NaN;
  return this;
}
