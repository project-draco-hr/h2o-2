{
  if (_job != null && _job.cancelled())   throw new JobCancelledException();
  chunkInit();
  final int nrows=chunks[0]._len;
  double[] nums=MemoryManager.malloc8d(_dinfo._nums);
  int[] cats=MemoryManager.malloc4(_dinfo._cats);
  OUTER:   for (int r=0; r < nrows; ++r) {
    if (_dinfo._nfolds > 0 && (r % _dinfo._nfolds) == _dinfo._foldId)     continue;
    for (    Chunk c : chunks)     if (c.isNA0(r))     continue OUTER;
    int i=0, ncats=0;
    for (; i < _dinfo._cats; ++i) {
      int c=(int)chunks[i].at80(r);
      if (c != 0)       cats[ncats++]=c + _dinfo._catOffsets[i] - 1;
    }
    final int n=_dinfo._hasResponse ? chunks.length - 1 : chunks.length;
    for (; i < n; ++i) {
      double d=chunks[i].at0(r);
      if (_dinfo._normMul != null)       d=(d - _dinfo._normSub[i - _dinfo._cats]) * _dinfo._normMul[i - _dinfo._cats];
      nums[i - _dinfo._cats]=d;
    }
    if (outputs != null && outputs.length > 0) {
      if (!_dinfo._hasResponse)       processRow(nums,ncats,cats,outputs);
 else       processRow(nums,ncats,cats,chunks[chunks.length - 1].at0(r),outputs);
    }
 else {
      if (!_dinfo._hasResponse)       processRow(nums,ncats,cats);
 else       processRow(nums,ncats,cats,chunks[chunks.length - 1].at0(r));
    }
  }
  chunkDone();
}
