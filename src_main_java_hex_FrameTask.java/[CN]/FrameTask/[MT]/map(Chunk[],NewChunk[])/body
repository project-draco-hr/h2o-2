{
  if (_job != null && _job.self() != null && !Job.isRunning(_job.self()))   throw new JobCancelledException();
  final int nrows=chunks[0]._len;
  chunkInit();
  double[] nums=MemoryManager.malloc8d(_dinfo._nums);
  int[] cats=MemoryManager.malloc4(_dinfo._cats);
  double[] response=MemoryManager.malloc8d(_dinfo._responses);
  int start=0;
  int end=nrows;
  boolean contiguous=false;
  Random _random=null;
  if (_useFraction < 1.0) {
    if (contiguous) {
      final int howmany=(int)Math.ceil(_useFraction * nrows);
      if (howmany > 0) {
        start=new Random().nextInt(nrows - howmany);
        end=start + howmany;
      }
      assert(start < nrows);
      assert(end <= nrows);
    }
 else {
      _random=water.util.Utils.getDeterRNG(new Random().nextLong());
      start=0;
      end=nrows;
    }
  }
  OUTER:   for (int r=start; r < end; ++r) {
    if ((_dinfo._nfolds > 0 && (r % _dinfo._nfolds) == _dinfo._foldId) || (_random != null && _random.nextFloat() > _useFraction))     continue;
    for (    Chunk c : chunks)     if (c.isNA0(r))     continue OUTER;
    int i=0, ncats=0;
    for (; i < _dinfo._cats; ++i) {
      int c=(int)chunks[i].at80(r);
      if (c != 0)       cats[ncats++]=c + _dinfo._catOffsets[i] - 1;
    }
    final int n=chunks.length - _dinfo._responses;
    for (; i < n; ++i) {
      double d=chunks[i].at0(r);
      if (_dinfo._normMul != null)       d=(d - _dinfo._normSub[i - _dinfo._cats]) * _dinfo._normMul[i - _dinfo._cats];
      nums[i - _dinfo._cats]=d;
    }
    for (i=0; i < _dinfo._responses; ++i)     response[i]=chunks[chunks.length - _dinfo._responses + i].at0(r);
    if (outputs != null && outputs.length > 0)     processRow(nums,ncats,cats,response,outputs);
 else     processRow(nums,ncats,cats,response);
  }
  chunkDone();
}
