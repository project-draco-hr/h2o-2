{
  int xmin=Integer.MAX_VALUE;
  long lemin=0, lemax=lemin;
  boolean overflow=false;
  boolean floatOverflow=false;
  if (_naCnt == _len)   return new C0DChunk(Double.NaN,_len);
  if (type() == AppendableVec.ENUM) {
    int sz=Integer.MIN_VALUE;
    for (    int x : _xs)     if (x > sz)     sz=x;
    if (sz < Enum.MAX_ENUM_SIZE) {
      if (sz < 255) {
        byte[] bs=MemoryManager.malloc1(_len);
        for (int i=0; i < _len; ++i)         bs[i]=(byte)(_xs[i] >= 0 ? (0xFF & _xs[i]) : C1Chunk._NA);
        return new C1Chunk(bs);
      }
 else       if (sz < 65535) {
        byte[] bs=MemoryManager.malloc1(_len << 1);
        int bias=sz < 32767 ? 0 : -(Short.MIN_VALUE + 1);
        for (int i=0; i < _len; ++i)         UDP.set2(bs,i << 1,(short)((_xs[i] >= 0) ? _xs[i] - bias : C2Chunk._NA));
        return sz < 32767 ? new C2Chunk(bs) : new C2SChunk(bs,bias,1);
      }
 else       throw H2O.unimpl();
    }
  }
  if (_ds != null) {
    for (int i=0; i < _len; i++)     if ((double)(float)_ds[i] != _ds[i])     return new C8DChunk(bufF(3));
    return new C4FChunk(bufF(2));
  }
  boolean first=true;
  for (int i=0; i < _len; i++) {
    if (isNA(i))     continue;
    long l=_ls[i];
    int x=_xs[i];
    double d=l * DParseTask.pow10(x);
    if (d < _min)     _min=d;
    if (d > _max)     _max=d;
    if (l == 0)     x=0;
    long t;
    while (l != 0 && (t=l / 10) * 10 == l) {
      l=t;
      x++;
    }
    floatOverflow=Math.abs(l) > MAX_FLOAT_MANTISSA;
    if (first) {
      first=false;
      xmin=x;
      lemin=lemax=l;
      continue;
    }
    if (overflow || (overflow=(Math.abs(xmin - x)) >= 10))     continue;
    if (x < xmin) {
      lemin*=DParseTask.pow10i(xmin - x);
      lemax*=DParseTask.pow10i(xmin - x);
      xmin=x;
    }
    long le=l * DParseTask.pow10i(x - xmin);
    if (le < lemin)     lemin=le;
    if (le > lemax)     lemax=le;
  }
  if (_min == _max) {
    return ((long)_min == _min) ? new C0LChunk((long)_min,_len) : new C0DChunk(_min,_len);
  }
  if (lemax - lemin == 1 && lemin == 0 && xmin == 0) {
    int bpv=_strCnt + _naCnt > 0 ? 2 : 1;
    byte[] cbuf=bufB(CBSChunk.OFF,bpv);
    return new CBSChunk(cbuf,cbuf[0],cbuf[1]);
  }
  if (overflow || ((xmin != 0) && floatOverflow || -35 > xmin || xmin > 35))   return new C8DChunk(bufF(3));
  if (xmin != 0) {
    if (lemax - lemin < 255)     return new C1SChunk(bufX(lemin,xmin,C1SChunk.OFF,0),(int)lemin,DParseTask.pow10(xmin));
    if (lemax - lemin < 65535)     return new C2SChunk(bufX(lemin,xmin,C2SChunk.OFF,1),(int)lemin,DParseTask.pow10(xmin));
    return new C4FChunk(bufF(2));
  }
  if (0 <= lemin && lemax <= 255 && ((_naCnt + _strCnt) == 0))   return new C1NChunk(bufX(0,0,C1NChunk.OFF,0));
  if (lemax - lemin < 255) {
    if (0 <= lemin && lemax < 255)     return new C1Chunk(bufX(0,0,C1Chunk.OFF,0));
    return new C1SChunk(bufX(lemin,0,C1SChunk.OFF,0),(int)lemin,1);
  }
  if (lemax - lemin < 65535) {
    if (Short.MIN_VALUE < lemin && lemax <= Short.MAX_VALUE)     return new C2Chunk(bufX(0,0,C2Chunk.OFF,1));
    int bias=(int)(lemin - (Short.MIN_VALUE + 1));
    return new C2SChunk(bufX(bias,0,C2SChunk.OFF,1),bias,1);
  }
  if (Integer.MIN_VALUE < lemin && lemax <= Integer.MAX_VALUE)   return new C4Chunk(bufX(0,0,0,2));
  return new C8Chunk(bufX(0,0,0,3));
}
