{
  long processed=_minfo.get_processed_total();
  float momentum=momentum(processed);
  float rate=rate(processed) * (1 - momentum);
  final float rho=(float)params.rho;
  final float eps=(float)params.epsilon;
  final float l1=(float)params.l1;
  final float l2=(float)params.l2;
  final boolean have_momenta=_minfo.has_momenta();
  final boolean have_ada=_minfo.adaDelta();
  final boolean nesterov=params.nesterov_accelerated_gradient;
  final boolean update_prev=_previous._e != null;
  for (int row=0; row < _a.size(); row++) {
    float avg_grad2=0;
    final float partial_grad=_previous._previous._a.get(row) - _a.get(row);
    for (int col=0; col < _previous._a.size(); col++) {
      final float weight=_w.get(col,row);
      if (update_prev)       _previous._e.add(col,partial_grad * weight);
      final float grad=partial_grad * _previous._a.get(col) - Math.signum(weight) * l1 - weight * l2;
      if (have_ada) {
        assert(!have_momenta);
        avg_grad2+=grad * grad;
        float brate=computeAdaDeltaRateForWeight(grad,row * _previous._a.size() + col,(DenseRowMatrix)_ada_dx_g,rho,eps);
        _w.add(col,row,brate * grad);
      }
 else {
        if (!nesterov) {
          final float delta=rate * grad;
          _w.add(col,row,delta);
          if (have_momenta) {
            _w.add(col,row,momentum * _wm.get(row,col));
            _wm.set(col,row,delta);
          }
        }
 else {
          float tmp=grad;
          if (have_momenta) {
            float val=_wm.get(col,row);
            val*=momentum;
            val+=tmp;
            tmp=val;
            _wm.set(col,row,val);
          }
          _w.add(col,row,rate * tmp);
        }
      }
    }
    if (have_ada)     avg_grad2/=_previous._a.size();
    update_bias(_b,_bm,row,partial_grad,avg_grad2,rate,momentum);
  }
}
