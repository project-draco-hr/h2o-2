{
  _a=_dvec;
  Arrays.fill(_a.raw(),0f);
  if (params.max_input_layer_size < _dinfo.fullN()) {
    final boolean random_projection=false;
    final boolean hash_trick=true;
    if (random_projection) {
      final int N=_dinfo.fullN();
      final int M=params.max_input_layer_size;
      assert(_a.size() == M);
      DenseVector orig=new DenseVector(N);
      for (int i=0; i < numcat; ++i)       orig.set(cats[i],1f);
      for (int i=0; i < nums.length; ++i)       orig.set(_dinfo.numStart() + i,Double.isNaN(nums[i]) ? 0f : (float)nums[i]);
      Random rng=new Random(params.seed);
      for (int i=0; i < M; ++i) {
        for (int j=0; j < N; ++j) {
          final float rnd=rng.nextFloat();
          float val=0;
          if (rnd < 1. / 6.)           val=(float)Math.sqrt(3);
          if (rnd > 5. / 6.)           val=-(float)Math.sqrt(3);
          _a.add(i,orig.get(j) * val);
        }
      }
    }
 else     if (hash_trick) {
      final int M=params.max_input_layer_size;
      assert(_a.size() == M);
      final int cM=M - nums.length;
      if (cM <= 0)       throw new IllegalArgumentException("max_input_layer_size must be at least " + (nums.length + 1));
      assert(_a.size() == M);
      Hash murmur=MurmurHash.getInstance();
      for (int i=0; i < numcat; ++i) {
        ByteBuffer buf=ByteBuffer.allocate(4);
        int hashval=murmur.hash(buf.putInt(cats[i]).array(),4,(int)params.seed);
        _a.add(Math.abs(hashval % cM),1f);
      }
      for (int i=0; i < nums.length; ++i)       _a.set(cM + i,Double.isNaN(nums[i]) ? 0f : (float)nums[i]);
    }
  }
 else {
    for (int i=0; i < numcat; ++i)     _a.set(cats[i],1f);
    for (int i=0; i < nums.length; ++i)     _a.set(_dinfo.numStart() + i,Double.isNaN(nums[i]) ? 0f : (float)nums[i]);
  }
  if (_dropout == null)   return;
  seed+=params.seed + 0x1337B4BE;
  _dropout.randomlySparsifyActivation(_a,seed);
  if (params.sparse) {
    _svec=new SparseVector(_dvec);
    _a=_svec;
  }
}
